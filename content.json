{"meta":{"title":"xzMhehe","subtitle":"","description":"后端开发一枚","author":"xzMhehe","url":"http://i.codingce.com.cn","root":"/"},"pages":[{"title":"About Me","date":"2020-07-07T14:24:58.000Z","updated":"2021-01-10T08:18:23.130Z","comments":true,"path":"about/index.html","permalink":"http://i.codingce.com.cn/about/index.html","excerpt":"","text":"123456789101112131415161718192021222324252627&#123; name: 'xzMhehe' age: 23, gender: 'Boy', profession: 'Backend Developer &amp; Geek', address: 'Tianjin', github: 'https://github.com/xzMhehe', blog: 'https://z.codingce.com.cn/', email: 'codingce@gmail.com', description: '后端开发，极客生活', skills: [ ['Java', 'Spring', 'Python', 'Linux', 'SQL'], ['SSH','SSM','Spring Boot'], ['Hadoop','Hive','Hbase','Spark'], ['HyperLedger Fabric','Docker'], ['JavaScript', 'JQuery','HTML+CSS','Bootstrap'], ['Git', 'SVN'] ], devTools: [ ['Eclipse &amp; MyEclipse', 'IDEA'] ['Visual Studio Code', 'Sublime Text','NotePad++'], ['Chrome DevTools'], ['Navicat', 'SQLyog','SQLDeveloper'] ] &#125; 永远相信美好的事情终将发生！ 技术微信公众号"},{"title":"Links","date":"2020-07-07T14:26:21.000Z","updated":"2020-12-13T04:41:40.453Z","comments":true,"path":"links/index.html","permalink":"http://i.codingce.com.cn/links/index.html","excerpt":"","text":"怎么可能有顺序呢，当然是随机的~ pinkpeach Life is sad at times, but it is up to you to make your own life happy.. 独孤伶俜 独孤伶俜 and 一生倥偬 本人站点 我的简历 道阻且长 我的主页 欢迎访问! 我的博客 欢迎访问 folio play 特殊链接 失效友链 失效友链 糟糕的先收起来 keyboard_arrow_down Marti’s Blog 摸鱼天下第一 洋葱落叶的博客 一个 Android 发烧友的博客 小狐妖博客 I'm fine. Raaynk’s Blog Raaynk的个人博客 友链记录册 那些曾经留过痕迹的友链 keyboard_arrow_down 2019-12-01 —— 粉色桃子的博客 2020-08-10 —— 独孤伶俜 .friends{display:flex;flex-wrap:wrap;}.friends .brick{-webkit-transition:all .3s ease;transition:all .3s ease;}.friends .brick{display:flex;margin:10px 10px 0 0;text-decoration:none;font-weight:300;padding:10px;background-color:#fff0;border:solid 1px #659eb929;color:#659eb9;text-align:center;border-radius:4px;overflow:hidden}.friends .brick:hover{background-color:#659eb9;color:#fff;border:solid 1px #659eb9;box-shadow:0 6px 16px 0 rgba(80, 178, 243, 0.35);}.blog-avatar:hover{animation:whirl 0.5s;} @keyframes whirl{0%{transform:rotate(0deg);}100%{transform:rotate(360deg);}}.friends .brick:active{-webkit-transform:scale(0.95);-moz-transform:scale(0.95);-ms-transform:scale(0.95);-o-transform:scale(0.95);transform:scale(0.95);}.friends .brick .blog-avatar{background-color:#fff0;color:#fff;border:solid 1px #dbdbdb;border-radius:50%;width:50px;height:50px;}.friends .brick .container{margin-left:10px;}.friends .brick .container .name{font-size:14px;}.friends .brick .container .motto{font-size:12px;margin-top:5px;-webkit-box-orient:vertical;-webkit-line-clamp:1;} @media(max-width:450px){.friends .brick{width:100%;}.friends .brick .container{margin-left:0;width:100%;}.motto{width: 100% !important;}}.motto.long{width:100px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;}.mdui-panel-item[open] .mdui-panel-item-arrow{transform:rotate(180deg);}.mdui-panel-item-body {height:auto!important;} 本站模板 1234名称：xzMhehe链接：https:&#x2F;&#x2F;i.codingce.com.cn&#x2F;图标：https:&#x2F;&#x2F;www.gravatar.com&#x2F;avatar&#x2F;f91d03fb9bfb4e5eb37249f66f6973f6?s&#x3D;80简介：The depth of thinking determines your altitude. 申请说明 不违反国家法律。 请确保你的站点活着。 在你的友链上添加本站。 格式模板 欢迎评论区留链接。 1234名称：&lt;Name&gt;链接：&lt;Link&gt;图标：&lt;Icon&gt;简介：&lt;Word&gt; 本站微信公众号"}],"posts":[{"title":"Redis缓存穿透和雪崩","slug":"Redis缓存穿透和雪崩","date":"2021-01-12T10:21:33.000Z","updated":"2021-01-12T10:21:33.944Z","comments":true,"path":"2021/01/12/Redis缓存穿透和雪崩/","link":"","permalink":"http://i.codingce.com.cn/2021/01/12/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%92%8C%E9%9B%AA%E5%B4%A9/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"哨兵模式","slug":"哨兵模式","date":"2021-01-12T06:05:24.000Z","updated":"2021-01-12T10:54:43.675Z","comments":true,"path":"2021/01/12/哨兵模式/","link":"","permalink":"http://i.codingce.com.cn/2021/01/12/%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"哨兵模式 主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式 哨兵模式概述 哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。 这里的哨兵有两个作用 通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。 当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机。 然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。 用文字描述一下故障切换（failover）的过程。假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为主观下线。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为客观下线。这样对于客户端而言，一切都是透明的。 Redis配置哨兵模式 配置1个哨兵和1主2从的Redis服务器来演示这个过程。 服务器类型 是否是主服务器 IP地址 端口 Redis 是 127.0.0.1 6379 Redis 否 127.0.0.1 6380 Redis 否 127.0.0.1 6381 测试 测试环境：一主二从、一个哨兵 哨兵配置文件 sentinel.config 12# sentinel monitor myredis 被监控主机名称 host 1 数字 1 代表主机挂了, slave 投票看谁接替成为主机, 就会成为主机sentinel monitor myredis 127.0.0.1 6379 1 启动哨兵 1redis-sentinel myconfig/sentinel.conf 1234567891011121314151617181920212223242526[root@ecs-t6-medium-2-linux-20190910000110 redis-5.0.7]# redis-sentinel myconfig/sentinel.conf10933:X 12 Jan 2021 15:55:07.961 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo10933:X 12 Jan 2021 15:55:07.961 # Redis version=5.0.7, bits=64, commit=00000000, modified=0, pid=10933, just started10933:X 12 Jan 2021 15:55:07.961 # Configuration loaded _._ _.-``__ ''-._ _.-`` `. `_. ''-._ Redis 5.0.7 (00000000/0) 64 bit .-`` .-```. ```\\/ _.,_ ''-._ ( ' , .-` | `, ) Running in sentinel mode |`-._`-...-` __...-.``-._|'` _.-'| Port: 26379 | `-._ `._ / _.-' | PID: 10933 `-._ `-._ `-./ _.-' _.-' |`-._`-._ `-.__.-' _.-'_.-'| | `-._`-._ _.-'_.-' | http://redis.io `-._ `-._`-.__.-'_.-' _.-' |`-._`-._ `-.__.-' _.-'_.-'| | `-._`-._ _.-'_.-' | `-._ `-._`-.__.-'_.-' _.-' `-._ `-.__.-' _.-' `-._ _.-' `-.__.-' 10933:X 12 Jan 2021 15:55:07.962 # Sentinel ID is af64af6020684a2fe79f1cc4e1727c39778263bc10933:X 12 Jan 2021 15:55:07.962 # +monitor master myredis 127.0.0.1 6379 quorum 110933:X 12 Jan 2021 16:04:10.045 * +slave slave 127.0.0.1:6381 127.0.0.1 6381 @ myredis 127.0.0.1 637910933:X 12 Jan 2021 16:04:30.090 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6379 当6379宕机或者关闭后 哨兵日志 1234567891011121314151617181920212223242526272829303132333435363738394041424311726:X 12 Jan 2021 16:05:35.830 # Configuration loaded _._ _.-``__ ''-._ _.-`` `. `_. ''-._ Redis 5.0.7 (00000000/0) 64 bit .-`` .-```. ```\\/ _.,_ ''-._ ( ' , .-` | `, ) Running in sentinel mode |`-._`-...-` __...-.``-._|'` _.-'| Port: 26379 | `-._ `._ / _.-' | PID: 11726 `-._ `-._ `-./ _.-' _.-' |`-._`-._ `-.__.-' _.-'_.-'| | `-._`-._ _.-'_.-' | http://redis.io `-._ `-._`-.__.-'_.-' _.-' |`-._`-._ `-.__.-' _.-'_.-'| | `-._`-._ _.-'_.-' | `-._ `-._`-.__.-'_.-' _.-' `-._ `-.__.-' _.-' `-._ _.-' `-.__.-' 11726:X 12 Jan 2021 16:05:35.831 # Sentinel ID is af64af6020684a2fe79f1cc4e1727c39778263bc11726:X 12 Jan 2021 16:05:35.831 # +monitor master myredis 127.0.0.1 6379 quorum 111726:X 12 Jan 2021 16:07:34.811 # +sdown master myredis 127.0.0.1 637911726:X 12 Jan 2021 16:07:34.811 # +odown master myredis 127.0.0.1 6379 #quorum 1/111726:X 12 Jan 2021 16:07:34.811 # +new-epoch 111726:X 12 Jan 2021 16:07:34.811 # +try-failover master myredis 127.0.0.1 637911726:X 12 Jan 2021 16:07:34.814 # +vote-for-leader af64af6020684a2fe79f1cc4e1727c39778263bc 111726:X 12 Jan 2021 16:07:34.814 # +elected-leader master myredis 127.0.0.1 6379# failove 故障转移11726:X 12 Jan 2021 16:07:34.814 # +failover-state-select-slave master myredis 127.0.0.1 637911726:X 12 Jan 2021 16:07:34.866 # +selected-slave slave 127.0.0.1:6381 127.0.0.1 6381 @ myredis 127.0.0.1 637911726:X 12 Jan 2021 16:07:34.866 * +failover-state-send-slaveof-noone slave 127.0.0.1:6381 127.0.0.1 6381 @ myredis 127.0.0.1 637911726:X 12 Jan 2021 16:07:34.925 * +failover-state-wait-promotion slave 127.0.0.1:6381 127.0.0.1 6381 @ myredis 127.0.0.1 637911726:X 12 Jan 2021 16:07:35.087 # +promoted-slave slave 127.0.0.1:6381 127.0.0.1 6381 @ myredis 127.0.0.1 637911726:X 12 Jan 2021 16:07:35.087 # +failover-state-reconf-slaves master myredis 127.0.0.1 637911726:X 12 Jan 2021 16:07:35.147 * +slave-reconf-sent slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 637911726:X 12 Jan 2021 16:07:36.094 * +slave-reconf-inprog slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 637911726:X 12 Jan 2021 16:07:36.094 * +slave-reconf-done slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 637911726:X 12 Jan 2021 16:07:36.171 # +failover-end master myredis 127.0.0.1 6379# 638111726:X 12 Jan 2021 16:07:36.171 # +switch-master myredis 127.0.0.1 6379 127.0.0.1 638111726:X 12 Jan 2021 16:07:36.171 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 638111726:X 12 Jan 2021 16:07:36.171 * +slave slave 127.0.0.1:6379 127.0.0.1 6379 @ myredis 127.0.0.1 6381 此时6381为老大 1234567891011121314127.0.0.1:6381&gt; info replication# Replicationrole:masterconnected_slaves:1slave0:ip=127.0.0.1,port=6380,state=online,offset=17768,lag=0master_replid:25c55d651308dd9fcd2f9c84867ed1a58f2f4286master_replid2:9d786450a338f30155c623f99d1bd58129712aabmaster_repl_offset:17768second_repl_offset:11402repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:1repl_backlog_histlen:17768127.0.0.1:6381&gt; 如果主机此时回来了, 只能归并到新的主机下, 当作从机, 这就是哨兵模式的规则 123456711726:X 12 Jan 2021 16:07:36.171 * +slave slave 127.0.0.1:6379 127.0.0.1 6379 @ myredis 127.0.0.1 638111726:X 12 Jan 2021 16:08:06.192 # +sdown slave 127.0.0.1:6379 127.0.0.1 6379 @ myredis 127.0.0.1 638111726:X 12 Jan 2021 16:22:59.961 # -sdown slave 127.0.0.1:6379 127.0.0.1 6379 @ myredis 127.0.0.1 638111726:X 12 Jan 2021 16:23:34.353 # +sdown slave 127.0.0.1:6379 127.0.0.1 6379 @ myredis 127.0.0.1 638111726:X 12 Jan 2021 16:23:37.565 * +reboot slave 127.0.0.1:6379 127.0.0.1 6379 @ myredis 127.0.0.1 638111726:X 12 Jan 2021 16:23:37.648 # -sdown slave 127.0.0.1:6379 127.0.0.1 6379 @ myredis 127.0.0.1 638111726:X 12 Jan 2021 16:23:47.568 * +convert-to-slave slave 127.0.0.1:6379 127.0.0.1 6379 @ myredis 127.0.0.1 6381 哨兵模式 优点 哨兵集群, 基于主从复制模式, 所有主从配置优点, 它全有 主从可以切换, 故障可以转移, 系统可用性就会很好 哨兵模式就是主从模式的升级, 手动到自动, 更加健壮 缺点 redis 不好在线扩容, 集群容量一旦到达上限, 在线扩容就十分的麻烦 实现哨兵模式的配置其实是很麻烦的, 里面有很多选择 哨兵模式全部配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251# Example sentinel.conf# *** IMPORTANT ***## By default Sentinel will not be reachable from interfaces different than# localhost, either use the 'bind' directive to bind to a list of network# interfaces, or disable protected mode with \"protected-mode no\" by# adding it to this configuration file.## Before doing that MAKE SURE the instance is protected from the outside# world via firewalling or other means.## For example you may use one of the following:## bind 127.0.0.1 192.168.1.1## protected-mode no# port &lt;sentinel-port&gt;# The port that this sentinel instance will run onport 26379 # 如果有哨兵集群, 我们还需要配置每个哨兵端口# By default Redis Sentinel does not run as a daemon. Use 'yes' if you need it.# Note that Redis will write a pid file in /var/run/redis-sentinel.pid when# daemonized.daemonize no# When running daemonized, Redis Sentinel writes a pid file in# /var/run/redis-sentinel.pid by default. You can specify a custom pid file# location here.pidfile /var/run/redis-sentinel.pid# Specify the log file name. Also the empty string can be used to force# Sentinel to log on the standard output. Note that if you use standard# output for logging but daemonize, logs will be sent to /dev/nulllogfile \"\"# sentinel announce-ip &lt;ip&gt;# sentinel announce-port &lt;port&gt;## The above two configuration directives are useful in environments where,# because of NAT, Sentinel is reachable from outside via a non-local address.## When announce-ip is provided, the Sentinel will claim the specified IP address# in HELLO messages used to gossip its presence, instead of auto-detecting the# local address as it usually does.## Similarly when announce-port is provided and is valid and non-zero, Sentinel# will announce the specified TCP port.## The two options don't need to be used together, if only announce-ip is# provided, the Sentinel will announce the specified IP and the server port# as specified by the \"port\" option. If only announce-port is provided, the# Sentinel will announce the auto-detected local IP and the specified port.## Example:## sentinel announce-ip 1.2.3.4# dir &lt;working-directory&gt;# Every long running process should have a well-defined working directory.# For Redis Sentinel to chdir to /tmp at startup is the simplest thing# for the process to don't interfere with administrative tasks such as# unmounting filesystems.# 哨兵的 sentinel的工作目录dir /tmp # sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;## Tells Sentinel to monitor this master, and to consider it in O_DOWN# (Objectively Down) state only if at least &lt;quorum&gt; sentinels agree.## Note that whatever is the ODOWN quorum, a Sentinel will require to# be elected by the majority of the known Sentinels in order to# start a failover, so no failover can be performed in minority.## Replicas are auto-discovered, so you don't need to specify replicas in# any way. Sentinel itself will rewrite this configuration file adding# the replicas using additional configuration options.# Also note that the configuration file is rewritten when a# replica is promoted to master.## Note: master name should not include special characters or spaces.# The valid charset is A-z 0-9 and the three characters \".-_\".# 哨兵 sentinel 监控的 redis 主节点 ip port# master-name 可以自己命名的主节点名字 只能由字母 A-Z 数字0-9 这三个字符\".-_\" 组成# quorum 配置多少个 sentinel 哨兵统一认为 master主节点失联, 那么这时候客观上认为主节点失联了# sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;sentinel monitor mymaster 127.0.0.1 6379 2# sentinel auth-pass &lt;master-name&gt; &lt;password&gt;## Set the password to use to authenticate with the master and replicas.# Useful if there is a password set in the Redis instances to monitor.## Note that the master password is also used for replicas, so it is not# possible to set a different password in masters and replicas instances# if you want to be able to monitor these instances with Sentinel.## However you can have Redis instances without the authentication enabled# mixed with Redis instances requiring the authentication (as long as the# password set is the same for all the instances requiring the password) as# the AUTH command will have no effect in Redis instances with authentication# switched off.## Example:## 当Redia实例中开启了 requirepass foobared 授权密码 这样所有的连接Redis 实例的客户端都要提供密码# 设置哨兵 sentinel 连接# sentinel auth-pass mymaster MySUPER--secret-0123passw0rd# sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;## Number of milliseconds the master (or any attached replica or sentinel) should# be unreachable (as in, not acceptable reply to PING, continuously, for the# specified period) in order to consider it in S_DOWN state (Subjectively# Down).## Default is 30 seconds.sentinel down-after-milliseconds mymaster 30000# sentinel parallel-syncs &lt;master-name&gt; &lt;numreplicas&gt;## How many replicas we can reconfigure to point to the new replica simultaneously# during the failover. Use a low number if you use the replicas to serve query# to avoid that all the replicas will be unreachable at about the same# time while performing the synchronization with the master.sentinel parallel-syncs mymaster 1# sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;## Specifies the failover timeout in milliseconds. It is used in many ways:## - The time needed to re-start a failover after a previous failover was# already tried against the same master by a given Sentinel, is two# times the failover timeout.## - The time needed for a replica replicating to a wrong master according# to a Sentinel current configuration, to be forced to replicate# with the right master, is exactly the failover timeout (counting since# the moment a Sentinel detected the misconfiguration).## - The time needed to cancel a failover that is already in progress but# did not produced any configuration change (SLAVEOF NO ONE yet not# acknowledged by the promoted replica).## - The maximum time a failover in progress waits for all the replicas to be# reconfigured as replicas of the new master. However even after this time# the replicas will be reconfigured by the Sentinels anyway, but not with# the exact parallel-syncs progression as specified.## Default is 3 minutes.sentinel failover-timeout mymaster 180000# SCRIPTS EXECUTION## sentinel notification-script and sentinel reconfig-script are used in order# to configure scripts that are called to notify the system administrator# or to reconfigure clients after a failover. The scripts are executed# with the following rules for error handling:## If script exits with \"1\" the execution is retried later (up to a maximum# number of times currently set to 10).## If script exits with \"2\" (or an higher value) the script execution is# not retried.## If script terminates because it receives a signal the behavior is the same# as exit code 1.## A script has a maximum running time of 60 seconds. After this limit is# reached the script is terminated with a SIGKILL and the execution retried.# NOTIFICATION SCRIPT## sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;# # Call the specified notification script for any sentinel event that is# generated in the WARNING level (for instance -sdown, -odown, and so forth).# This script should notify the system administrator via email, SMS, or any# other messaging system, that there is something wrong with the monitored# Redis systems.## The script is called with just two arguments: the first is the event type# and the second the event description.## The script must exist and be executable in order for sentinel to start if# this option is provided.## Example:## sentinel notification-script mymaster /var/redis/notify.sh# CLIENTS RECONFIGURATION SCRIPT## sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;## When the master changed because of a failover a script can be called in# order to perform application-specific tasks to notify the clients that the# configuration has changed and the master is at a different address.# # The following arguments are passed to the script:## &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;## &lt;state&gt; is currently always \"failover\"# &lt;role&gt; is either \"leader\" or \"observer\"# # The arguments from-ip, from-port, to-ip, to-port are used to communicate# the old address of the master and the new address of the elected replica# (now a master).## This script should be resistant to multiple invocations.## Example:## sentinel client-reconfig-script mymaster /var/redis/reconfig.sh# SECURITY## By default SENTINEL SET will not be able to change the notification-script# and client-reconfig-script at runtime. This avoids a trivial security issue# where clients can set the script to anything and trigger a failover in order# to get the program executed.sentinel deny-scripts-reconfig yes# REDIS COMMANDS RENAMING## Sometimes the Redis server has certain commands, that are needed for Sentinel# to work correctly, renamed to unguessable strings. This is often the case# of CONFIG and SLAVEOF in the context of providers that provide Redis as# a service, and don't want the customers to reconfigure the instances outside# of the administration console.## In such case it is possible to tell Sentinel to use different command names# instead of the normal ones. For example if the master \"mymaster\", and the# associated replicas, have \"CONFIG\" all renamed to \"GUESSME\", I could use:## SENTINEL rename-command mymaster CONFIG GUESSME## After such configuration is set, every time Sentinel would use CONFIG it will# use GUESSME instead. Note that there is no actual need to respect the command# case, so writing \"config guessme\" is the same in the example above.## SENTINEL SET can also be used in order to perform this configuration at runtime.## In order to set a command back to its original name (undo the renaming), it# is possible to just rename a command to itsef:## SENTINEL rename-command mymaster CONFIG CONFIG 文章已上传gitee https://gitee.com/codingce/hexo-blog 项目地址: https://github.com/xzMhehe/codingce-java","categories":[{"name":"Redis","slug":"Redis","permalink":"http://i.codingce.com.cn/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://i.codingce.com.cn/tags/Redis/"}]},{"title":"Redis主从复制","slug":"Redis主从复制","date":"2021-01-11T07:15:27.000Z","updated":"2021-01-12T06:05:08.689Z","comments":true,"path":"2021/01/11/Redis主从复制/","link":"","permalink":"http://i.codingce.com.cn/2021/01/11/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/","excerpt":"","text":"Redis 主从复制 概念 主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)； 数据的复制是单向的，只能由主节点到从节点。 默认情况下，每台Redis服务器都是主节点；且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。 主从复制的作用 主从复制的作用主要包括： 数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。 故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。 负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。 高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。 一般来说, 要将 Redis 运用于工程中, 只使用一台 Redis 是万万不能的(宕机) 主从结构下, 单个 Redis 服务器会发生单点故障, 并且一台服务器需要处理所有的请求负载, 压力较大 从容量上看, 单个 Redis 服务器内存容量有限, 就算一台Redsi 服务器的内存容量为 256G , 也不能将所有的内存用作 Redis 存储内存, 一般来说， 单台Redis最大使用内存不因该超过20G 电商网站上的2商品, 一般都是一次上传, 无数次浏览, 专业术语 多读少写 主从复制, 读写分离, 80% 的情况下都是在进行读操作, 减缓服务器压力, 架构中经常使用, 一主二从 环境配置 只配置从库, 不用配置主库 查看一些信息 12345678910127.0.0.1:6379&gt; info replication # 查看当前库信息# Replicationrole:master # 角色 masterconnected_slaves:0 # 没有从机master_repl_offset:0repl_backlog_active:0repl_backlog_size:1048576repl_backlog_first_byte_offset:0repl_backlog_histlen:0127.0.0.1:6379&gt; 复制三个配置文件, 然后修改对应的信息 端口 pid名字 日志名字 dump.rdb名字 redis-server redis.windows.conf Linux类同 redis-cli -p 6379 redis-cli -p 6380 redis-cli -p 6381 一主二从 默认情况下, 每台redis 服务器都是主节点; 我们一般情况下只用配置从机就可 1234567891011121314151617181920127.0.0.1:6380&gt; SLAVEOF 127.0.0.1 6379 # 端口 6380 认准 127.0.0.1 6379 为主OK127.0.0.1:6380&gt; info replication# Replicationrole:slavemaster_host:127.0.0.1master_port:6379master_link_status:upmaster_last_io_seconds_ago:7master_sync_in_progress:0slave_repl_offset:15slave_priority:100slave_read_only:1connected_slaves:0master_repl_offset:0repl_backlog_active:0repl_backlog_size:1048576repl_backlog_first_byte_offset:0repl_backlog_histlen:0127.0.0.1:6380&gt; 主机测试 123456789101112127.0.0.1:6379&gt; info replication# Replicationrole:masterconnected_slaves:2slave0:ip=127.0.0.1,port=6380,state=online,offset=169,lag=0slave1:ip=127.0.0.1,port=6381,state=online,offset=169,lag=0master_repl_offset:169repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:2repl_backlog_histlen:168127.0.0.1:6379&gt; 命令行的配置仅仅是暂时的, 需要永久的话可以在redis配置文件中进行修改 细节 主机可以写, 从机不能写, 从机只能读 测试: 主机断开连接, 从机依旧连接到主机, 但是没有写操作, 这时候主机如果回来了, 从机依旧可以获取到主机所写的信息 如果使用命令行, 来配置的主从, 这个时候如果重启了, 那么从机就会变成主机, 只要变成从机, 立马就会从主机中获取值 复制原理 全量同步 Redis全量复制一般发生在Slave初始化阶段，这时Slave需要将Master上的所有数据都复制一份。具体步骤如下： 从服务器连接主服务器，发送SYNC命令； 主服务器接收到SYNC命名后，开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令； 主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令； 从服务器收到快照文件后丢弃所有旧数据，载入收到的快照； 主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令； 从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令； 而slave服务在接受到数据文件后, 将其存到内存中 完成上面几个步骤后就完成了从服务器数据初始化的所有操作，从服务器此时可以接收来自用户的读请求. 增量同步 Redis增量复制是指Slave初始化后开始正常工作时主服务器发生的写操作同步到从服务器的过程. 增量复制的过程主要是主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令. Master继续将新的所有收集到的修改命名依次传给slave, 完成同步 Redis主从同步策略 主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。redis 策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步. 层层链路 上一个master 连接下一个slave 此时也可以完成主从复制, 但是80端口的依旧仅仅可以读（不能写） 如果没有主 这个时候 80 能不能变成老大 手动配置 1SLAVEOF no one # 使自己变成主机 此时80就为老大 文章已上传gitee https://gitee.com/codingce/hexo-blog 项目地址: https://github.com/xzMhehe/codingce-java","categories":[{"name":"Redis","slug":"Redis","permalink":"http://i.codingce.com.cn/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://i.codingce.com.cn/tags/Redis/"}]},{"title":"Redis发布订阅","slug":"Redis发布订阅","date":"2021-01-11T06:08:31.000Z","updated":"2021-01-11T07:13:59.124Z","comments":true,"path":"2021/01/11/Redis发布订阅/","link":"","permalink":"http://i.codingce.com.cn/2021/01/11/Redis%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/","excerpt":"","text":"Redis 发布订阅 Redis 发布订阅(pub/sub) 是一种消息通信模式: 发布者(pub) 发送消息, 订阅者(sub) 就收消息 Redis 客户端可以订阅任意数量的值 订阅/发布消息图 第一个： 消息发送者 第二个： 频道 第三个 消息接收者 下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系： 当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端： 命令 1 PSUBSCRIBE pattern [pattern …] 订阅一个或多个符合给定模式的频道。 2 PUBSUB subcommand [argument [argument …]] 查看订阅与发布系统状态。 3 PUBLISH channel message 将信息发送到指定的频道。 4 PUNSUBSCRIBE [pattern [pattern …]] 退订所有给定模式的频道。 5 SUBSCRIBE channel [channel …] 订阅给定的一个或多个频道的信息。 6 UNSUBSCRIBE [channel [channel …]] 指退订给定的频道。 测试 接收者 12345127.0.0.1:6379&gt; SUBSCRIBE mxz # 订阅一个频道 mxzReading messages... (press Ctrl-C to quit)1) \"subscribe\"2) \"mxz\"3) (integer) 1 接收消息 1231) \"message\"2) \"mxz\"3) \"Test first\" 发送者 123127.0.0.1:6379&gt; PUBLISH mxz \"Test first\"(integer) 1127.0.0.1:6379&gt; 使用场景 实时消息系统 实时聊天 订阅, 关注系统 稍微复杂的场景我们就会使用消息中间件 MQ() 文章已上传gitee https://gitee.com/codingce/hexo-blog 项目地址: https://github.com/xzMhehe/codingce-java","categories":[{"name":"Redis","slug":"Redis","permalink":"http://i.codingce.com.cn/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://i.codingce.com.cn/tags/Redis/"}]},{"title":"Redis持久化","slug":"Redis持久化","date":"2021-01-11T02:55:39.000Z","updated":"2021-01-11T06:00:47.216Z","comments":true,"path":"2021/01/11/Redis持久化/","link":"","permalink":"http://i.codingce.com.cn/2021/01/11/Redis%E6%8C%81%E4%B9%85%E5%8C%96/","excerpt":"","text":"Redis持久化 面试和工作, 持久化都是重点 Redis 是内存数据库, 如果不将内存中的数据存入到磁盘, 那么服务器进程退出, 服务器中的数据库状态也会消失, 所以 Redis 提供了持久化功能. RDB（Redis DataBase） 什么是 RDB 在指定的时间间隔内将内存中的数据集快照写入磁盘, 也就是 Snapshot 快照, 它回复时是将快照文件直接读到内存里. Redis 会单独创建 ( fork ) 一个子进程进行持久化, 会先将数据写入到一个临时文件中, 待持久化过程结束了, 再用这个临时文件替换上次持久化好的文件, 整个过程中, 主进程是不进行任何 IO 操作的. 这就确保了极高的性能. 如果要进行大规模的数据恢复, 且对于数据恢复的完整性不是非常敏感, 那 RDB 方式要比 AOF 方式更加的高效. RDB 的缺点是最后一次持久化的数据可能丢失. 我们默认的就是 RDB , 一般情况下不需要修改这个配置 rdb 保存的文件时 dump.rdb 都是在我们的配置文件中快照中进行配置的. 触发机制 save 的规则满足的情况下, 会触发 rdb 规则 执行了 flushall 命令 也会出发 rdb 规则 退出redis 也会产生 rdb 文件 备份就会自动生成一个 dump.rdb 如何恢复 rdb 文件 只需要将 rdb 文件放在我们的 redis 启动目录就可以, redis 启动的时候自动检查 dump.rdb 文件, 恢复其中的数据 查看需要存在的位置 123config get dir\"dir\"\"/usr/local/bin\" # 如果在这个目录不存在 dump.rdb 文件, 启动就会恢复其中的数据 优点： 适合大规模的数据恢复 对数据完整性不高 缺点： 需要一定的时间间隔进程操作, 入果 redis 意外宕机了这个最后一次修改数据就没有了 fork 进程的时候, 会占用一定的内容空间 AOF(Append Only File) 什么是 AOF AOF 保存的是 appendonly.aof 文件 以日志的形式来记录每个写操作, 将 Redis 执行过的所有指令记录下来(读操作不记录), 只许追加文件但不可以改写文件, redis 启动之初会读取文件重新构建数据, 换言之, redis 重启的话就跟据日志文件的内容从前到后执行一次以完成数据恢复工作. 默认是不开启的, 我们需要手动配置 1appendonly no 如果这个 aof 文件有错误 (做了更改), 这时候 redis 是启动不起来的, 我们需要修复这个 aof 文件 redis 给我们提供了一个工具, redis-check-aof --fix 如果文件正常的话, 重启就可以直接恢复了 12345# appendonly no # 默认是不开启 aof 模式的, 默认使用的是 rdb 方式持久化, 在大部分所有情况下, rdb 完全够用# appendfilename \"appendonly.aof\" # 持久化的文件的名字 # appendfsync everysec # 每秒执行一次 sync 可能会丢失 1s 的数据# appendfsync no # 不执行 sync 这个时候操作系统自己同步数据 速度最快# appendfsync always # 每次修改都会 sync 消耗性能 优点： 每一次修改都同步, 文件完整性会更好 每秒同步一次, 可能会丢失一秒的数据 从不同步, 效率是最高的 缺点 先对于数据文件来说, aof 远远大于 rdb, 修复的速度也比 rdb 慢 aof 运行效率也要比 rdb 慢, 所以我们 redis 默认配置就是 rdb 持久化 持久化总结 如果你只希望你的数据在服务器运行的时候存在，可以不使用任何的持久化方式。 一般建议同时开启两种持久化方式。AOF进行数据的持久化，确保数据不会丢失太多，而RDB更适合用于备份数据库，留着一个做万一的手段。 性能建议： 因为RDB文件只用做后备用途，建议只在slave上持久化RDB文件，而且只要在15分钟备份一次就够了，只保留900 1这条规则。 1.如果Enalbe AOF,好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了。 代价：1、带来了持续的IO；代价2、AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。 只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上。默认超过原大小100%大小时重写可以改到适当的数值。 2.如果不Enable AOF,仅靠Master-Slave Replication 实现高可用性也可以。能省掉一大笔IO也减少了rewrite时带来的系统波动。代价是如果Master/Slave同时宕掉，会丢失10几分钟的数据，启动脚本也要比较两个Master/Slave中的RDB文件，载入较新的那个。新浪微博就选用了这种架构。 文章已上传gitee https://gitee.com/codingce/hexo-blog 项目地址: https://github.com/xzMhehe/codingce-java","categories":[{"name":"Redis","slug":"Redis","permalink":"http://i.codingce.com.cn/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://i.codingce.com.cn/tags/Redis/"}]},{"title":"Redis配置文件","slug":"Redis配置文件","date":"2021-01-10T11:17:32.000Z","updated":"2021-01-11T02:56:00.771Z","comments":true,"path":"2021/01/10/Redis配置文件/","link":"","permalink":"http://i.codingce.com.cn/2021/01/10/Redis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/","excerpt":"","text":"Redis.config详解 启动的时候通过配置文件来启动(windows 10) 行家有没有, 出手就知道 单位 12345678# 1k =&gt; 1000 bytes# 1kb =&gt; 1024 bytes# 1m =&gt; 1000000 bytes# 1mb =&gt; 1024*1024 bytes# 1g =&gt; 1000000000 bytes# 1gb =&gt; 1024*1024*1024 bytes## units are case insensitive so 1GB 1Gb 1gB are all the same. 配置文件 unit 单位对大小写不敏感 可以包含其他配置文件INCLUDES 1234567891011121314151617################################## INCLUDES #################################### Include one or more other config files here. This is useful if you# have a standard template that goes to all Redis servers but also need# to customize a few per-server settings. Include files can include# other files, so use this wisely.## Notice option \"include\" won't be rewritten by command \"CONFIG REWRITE\"# from admin or Redis Sentinel. Since Redis always uses the last processed# line as value of a configuration directive, you'd better put includes# at the beginning of this file to avoid overwriting config change at runtime.## If instead you are interested in using includes to override configuration# options, it is better to use include as the last line.## include .\\path\\to\\local.conf# include c:\\path\\to\\other.conf 就像Spring import include 网络NETWORK 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384################################## NETWORK ###################################### By default, if no \"bind\" configuration directive is specified, Redis listens# for connections from all the network interfaces available on the server.# It is possible to listen to just one or multiple selected interfaces using# the \"bind\" configuration directive, followed by one or more IP addresses.## Examples:## bind 192.168.1.100 10.0.0.1# bind 127.0.0.1 ::1## ~~~ WARNING ~~~ If the computer running Redis is directly exposed to the# internet, binding to all the interfaces is dangerous and will expose the# instance to everybody on the internet. So by default we uncomment the# following bind directive, that will force Redis to listen only into# the IPv4 lookback interface address (this means Redis will be able to# accept connections only from clients running into the same computer it# is running).## IF YOU ARE SURE YOU WANT YOUR INSTANCE TO LISTEN TO ALL THE INTERFACES# JUST COMMENT THE FOLLOWING LINE.# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~bind 127.0.0.1 # 绑定的ip# Protected mode is a layer of security protection, in order to avoid that# Redis instances left open on the internet are accessed and exploited.## When protected mode is on and if:## 1) The server is not binding explicitly to a set of addresses using the# \"bind\" directive.# 2) No password is configured.## The server only accepts connections from clients connecting from the# IPv4 and IPv6 loopback addresses 127.0.0.1 and ::1, and from Unix domain# sockets.## By default protected mode is enabled. You should disable it only if# you are sure you want clients from other hosts to connect to Redis# even if no authentication is configured, nor a specific set of interfaces# are explicitly listed using the \"bind\" directive.protected-mode yes # 受保护模式, 开启, 保证安全性# Accept connections on the specified port, default is 6379 (IANA #815344).# If port 0 is specified Redis will not listen on a TCP socket.port 6379 # 端口设置# TCP listen() backlog.## In high requests-per-second environments you need an high backlog in order# to avoid slow clients connections issues. Note that the Linux kernel# will silently truncate it to the value of /proc/sys/net/core/somaxconn so# make sure to raise both the value of somaxconn and tcp_max_syn_backlog# in order to get the desired effect.tcp-backlog 511# Unix socket.## Specify the path for the Unix socket that will be used to listen for# incoming connections. There is no default, so Redis will not listen# on a unix socket when not specified.## unixsocket /tmp/redis.sock# unixsocketperm 700# Close the connection after a client is idle for N seconds (0 to disable)timeout 0# TCP keepalive.## If non-zero, use SO_KEEPALIVE to send TCP ACKs to clients in absence# of communication. This is useful for two reasons:## 1) Detect dead peers.# 2) Take the connection alive from the point of view of network# equipment in the middle.## On Linux, the specified value (in seconds) is the period used to send ACKs.# Note that to close the connection the double of the time is needed.# On other kernels the period depends on the kernel configuration.## A reasonable value for this option is 60 seconds.tcp-keepalive 0 bind 127.0.0.1 # 绑定的ip protected-mode yes # 受保护模式, 开启, 保证安全性 port 6379 # 端口设置 通用配置GENERAL 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556################################# GENERAL ###################################### By default Redis does not run as a daemon. Use 'yes' if you need it.# Note that Redis will write a pid file in /var/run/redis.pid when daemonized.# NOT SUPPORTED ON WINDOWS daemonize nodaemonize yes# If you run Redis from upstart or systemd, Redis can interact with your# supervision tree. Options:# supervised no - no supervision interaction# supervised upstart - signal upstart by putting Redis into SIGSTOP mode# supervised systemd - signal systemd by writing READY=1 to $NOTIFY_SOCKET# supervised auto - detect upstart or systemd method based on# UPSTART_JOB or NOTIFY_SOCKET environment variables# Note: these supervision methods only signal \"process is ready.\"# They do not enable continuous liveness pings back to your supervisor.# NOT SUPPORTED ON WINDOWS supervised nosupervised no# If a pid file is specified, Redis writes it where specified at startup# and removes it at exit.## When the server runs non daemonized, no pid file is created if none is# specified in the configuration. When the server is daemonized, the pid file# is used even if not specified, defaulting to \"/var/run/redis.pid\".## Creating a pid file is best effort: if Redis is not able to create it# nothing bad happens, the server will start and run normally.# NOT SUPPORTED ON WINDOWS pidfile /var/run/redis.pidpidfile /var/run/redis.pid# Specify the server verbosity level.# This can be one of:# debug (a lot of information, useful for development/testing)# verbose (many rarely useful info, but not a mess like the debug level)# notice (moderately verbose, what you want in production probably)# warning (only very important / critical messages are logged)loglevel notice # 生产环境# Specify the log file name. Also 'stdout' can be used to force# Redis to log on the standard output.logfile \"\" # 生成的文件名# To enable logging to the Windows EventLog, just set 'syslog-enabled' to# yes, and optionally update the other syslog parameters to suit your needs.# If Redis is installed and launched as a Windows Service, this will# automatically be enabled.# syslog-enabled no# Specify the source name of the events in the Windows Application log.# syslog-ident redis# Set the number of databases. The default database is DB 0, you can select# a different one on a per-connection basis using SELECT &lt;dbid&gt; where# dbid is a number between 0 and 'databases'-1databases 16 # 数据库的数量， 默认三是16个 daemonize no # 以守护进程的方式运行, 默认是 no , 我们需要自己开启为 yes pidfile /var/run/redis.pid # 如果以后台的方式运行, 我们就需要指定一个 pid 进行文件 loglevel notice # 日志级别 （debug、 verbose、 notice、 warning） logfile “” # 生成的文件名 always-show-logo yes # 是否总是显示logo 快照SNAPSHOTTING 持久化, 在规定时间内, 执行多少次操作, 则会持久化到文件 .rdb .aof 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768################################ SNAPSHOTTING ################################## Save the DB on disk:## save &lt;seconds&gt; &lt;changes&gt;## Will save the DB if both the given number of seconds and the given# number of write operations against the DB occurred.## In the example below the behaviour will be to save:# after 900 sec (15 min) if at least 1 key changed# after 300 sec (5 min) if at least 10 keys changed# after 60 sec if at least 10000 keys changed## Note: you can disable saving completely by commenting out all \"save\" lines.## It is also possible to remove all the previously configured save# points by adding a save directive with a single empty string argument# like in the following example:## save \"\"save 900 1 # 持久化规则, redis 是内存数据库, 不持久化的话数据就会丢save 300 10save 60 10000# By default Redis will stop accepting writes if RDB snapshots are enabled# (at least one save point) and the latest background save failed.# This will make the user aware (in a hard way) that data is not persisting# on disk properly, otherwise chances are that no one will notice and some# disaster will happen.## If the background saving process will start working again Redis will# automatically allow writes again.## However if you have setup your proper monitoring of the Redis server# and persistence, you may want to disable this feature so that Redis will# continue to work as usual even if there are problems with disk,# permissions, and so forth.stop-writes-on-bgsave-error yes # 持久化出错, 是否仍进行工作# Compress string objects using LZF when dump .rdb databases?# For default that's set to 'yes' as it's almost always a win.# If you want to save some CPU in the saving child set it to 'no' but# the dataset will likely be bigger if you have compressible values or keys.rdbcompression yes # 是否压缩 rdb 文件 (需要消耗 cpu 资源)# Since version 5 of RDB a CRC64 checksum is placed at the end of the file.# This makes the format more resistant to corruption but there is a performance# hit to pay (around 10%) when saving and loading RDB files, so you can disable it# for maximum performances.## RDB files created with checksum disabled have a checksum of zero that will# tell the loading code to skip the check.rdbchecksum yes # 是否校验 rdb 文件 # The filename where to dump the DBdbfilename dump.rdb# The working directory.## The DB will be written inside this directory, with the filename specified# above using the 'dbfilename' configuration directive.# # The Append Only File will also be created inside this directory.# # Note that you must specify a directory here, not a file name.dir ./ 内存数据库, 如果没有持久化, 那么数据断电及失(可自定义设置自己所需要的) save 900 1 # 900秒内如果至少有一个 key 进行修改, 我们就进行持久化操作 save 300 10 # 300秒内如果至少有十个 key 进行修改, 我们就进行持久化操作 save 60 10000 # 60秒内如果至少有一万个 key 进行修改, 我们就进行持久化操作(高并发) stop-writes-on-bgsave-error yes # 持久化出错, 是否仍进行工作 rdbcompression yes # 是否压缩 rdb 文件 (需要消耗 cpu 资源) rdbchecksum yes # 保存 rdb 文件的时候, 进行错误检查校验 dir ./ # rdb 文件保存的目录 复制REPLICATION 主从复制 安全SECURITY 安全, 默认是没有密码的. 123456789101112131415161718192021222324252627282930313233################################## SECURITY #################################### Require clients to issue AUTH &lt;PASSWORD&gt; before processing any other# commands. This might be useful in environments in which you do not trust# others with access to the host running redis-server.## This should stay commented out for backward compatibility and because most# people do not need auth (e.g. they run their own servers).# # Warning: since Redis is pretty fast an outside user can try up to# 150k passwords per second against a good box. This means that you should# use a very strong password otherwise it will be very easy to break.## requirepass foobared # 设置密码requirepass 123456# Command renaming.## It is possible to change the name of dangerous commands in a shared# environment. For instance the CONFIG command may be renamed into something# hard to guess so that it will still be available for internal-use tools# but not available for general clients.## Example:## rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52## It is also possible to completely kill a command by renaming it into# an empty string:## rename-command CONFIG \"\"## Please note that changing the name of commands that are logged into the# AOF file or transmitted to slaves may cause problems. requirepass 123456 # 手动设置 命令行设置 # config set requirepass “123456” 若已设置密码则需要登录 命令 auth 123456 登录成功 获取用户密码 config get requirepass 限制 LIMITS CLIENTS 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293################################### LIMITS ##################################### Set the max number of connected clients at the same time. By default# this limit is set to 10000 clients, however if the Redis server is not# able to configure the process file limit to allow for the specified limit# the max number of allowed clients is set to the current file limit# minus 32 (as Redis reserves a few file descriptors for internal uses).## Once the limit is reached Redis will close all the new connections sending# an error 'max number of clients reached'.## maxclients 10000 # 设置能链接上 redis 最大客户端 数量# If Redis is to be used as an in-memory-only cache without any kind of# persistence, then the fork() mechanism used by the background AOF/RDB# persistence is unnecessary. As an optimization, all persistence can be# turned off in the Windows version of Redis. This will redirect heap# allocations to the system heap allocator, and disable commands that would# otherwise cause fork() operations: BGSAVE and BGREWRITEAOF.# This flag may not be combined with any of the other flags that configure# AOF and RDB operations.# persistence-available [(yes)|no]# Don't use more memory than the specified amount of bytes.# When the memory limit is reached Redis will try to remove keys# according to the eviction policy selected (see maxmemory-policy).## If Redis can't remove keys according to the policy, or if the policy is# set to 'noeviction', Redis will start to reply with errors to commands# that would use more memory, like SET, LPUSH, and so on, and will continue# to reply to read-only commands like GET.## This option is usually useful when using Redis as an LRU cache, or to set# a hard memory limit for an instance (using the 'noeviction' policy).## WARNING: If you have slaves attached to an instance with maxmemory on,# the size of the output buffers needed to feed the slaves are subtracted# from the used memory count, so that network problems / resyncs will# not trigger a loop where keys are evicted, and in turn the output# buffer of slaves is full with DELs of keys evicted triggering the deletion# of more keys, and so forth until the database is completely emptied.## In short... if you have slaves attached it is suggested that you set a lower# limit for maxmemory so that there is some free RAM on the system for slave# output buffers (but this is not needed if the policy is 'noeviction').## WARNING: not setting maxmemory will cause Redis to terminate with an# out-of-memory exception if the heap limit is reached.## NOTE: since Redis uses the system paging file to allocate the heap memory,# the Working Set memory usage showed by the Windows Task Manager or by other# tools such as ProcessExplorer will not always be accurate. For example, right# after a background save of the RDB or the AOF files, the working set value# may drop significantly. In order to check the correct amount of memory used# by the redis-server to store the data, use the INFO client command. The INFO# command shows only the memory used to store the redis data, not the extra# memory used by the Windows process for its own requirements. Th3 extra amount# of memory not reported by the INFO command can be calculated subtracting the# Peak Working Set reported by the Windows Task Manager and the used_memory_peak# reported by the INFO command.## maxmemory &lt;bytes&gt; # redis 配置最大内存容量# MAXMEMORY POLICY: how Redis will select what to remove when maxmemory# is reached. You can select among five behaviors:# # volatile-lru -&gt; remove the key with an expire set using an LRU algorithm# allkeys-lru -&gt; remove any key according to the LRU algorithm# volatile-random -&gt; remove a random key with an expire set# allkeys-random -&gt; remove a random key, any key# volatile-ttl -&gt; remove the key with the nearest expire time (minor TTL)# noeviction -&gt; don't expire at all, just return an error on write operations# # Note: with any of the above policies, Redis will return an error on write# operations, when there are no suitable keys for eviction.## At the date of writing these commands are: set setnx setex append# incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd# sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby# zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby# getset mset msetnx exec sort## The default is:## maxmemory-policy noeviction# LRU and minimal TTL algorithms are not precise algorithms but approximated# algorithms (in order to save memory), so you can select as well the sample# size to check. For instance for default Redis will check three keys and# pick the one that was used less recently, you can change the sample size# using the following configuration directive.## maxmemory-samples 3 maxclients 10000 # 设置能链接上 redis 最大客户端 数量 maxmemory # redis 配置最大内存容量 maxmemory-policy noeviction # 内存达到上限处理策略 （移除一些过期的 key; 报错） 1、volatile-lru：只对设置了过期时间的key进行LRU（默认值） 2、allkeys-lru ： 删除lru算法的key 3、volatile-random：随机删除即将过期key 4、allkeys-random：随机删除 5、volatile-ttl ： 删除即将过期的 6、noeviction ： 永不过期，返回错误 APPEND ONLY 模式 AOF 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115############################## APPEND ONLY MODE ################################ By default Redis asynchronously dumps the dataset on disk. This mode is# good enough in many applications, but an issue with the Redis process or# a power outage may result into a few minutes of writes lost (depending on# the configured save points).## The Append Only File is an alternative persistence mode that provides# much better durability. For instance using the default data fsync policy# (see later in the config file) Redis can lose just one second of writes in a# dramatic event like a server power outage, or a single write if something# wrong with the Redis process itself happens, but the operating system is# still running correctly.## AOF and RDB persistence can be enabled at the same time without problems.# If the AOF is enabled on startup Redis will load the AOF, that is the file# with the better durability guarantees.## Please check http://redis.io/topics/persistence for more information.appendonly no # 默认是不开启# The name of the append only file (default: \"appendonly.aof\")appendfilename \"appendonly.aof\" # 持久化的文件的名字# The fsync() call tells the Operating System to actually write data on disk# instead of waiting for more data in the output buffer. Some OS will really flush# data on disk, some other OS will just try to do it ASAP.## Redis supports three different modes:## no: don't fsync, just let the OS flush the data when it wants. Faster.# always: fsync after every write to the append only log . Slow, Safest.# everysec: fsync only one time every second. Compromise.## The default is \"everysec\", as that's usually the right compromise between# speed and data safety. It's up to you to understand if you can relax this to# \"no\" that will let the operating system flush the output buffer when# it wants, for better performances (but if you can live with the idea of# some data loss consider the default persistence mode that's snapshotting),# or on the contrary, use \"always\" that's very slow but a bit safer than# everysec.## More details please check the following article:# http://antirez.com/post/redis-persistence-demystified.html## If unsure, use \"everysec\".# appendfsync alwaysappendfsync everysec # appendfsync no# When the AOF fsync policy is set to always or everysec, and a background# saving process (a background save or AOF log background rewriting) is# performing a lot of I/O against the disk, in some Linux configurations# Redis may block too long on the fsync() call. Note that there is no fix for# this currently, as even performing fsync in a different thread will block# our synchronous write(2) call.## In order to mitigate this problem it's possible to use the following option# that will prevent fsync() from being called in the main process while a# BGSAVE or BGREWRITEAOF is in progress.## This means that while another child is saving, the durability of Redis is# the same as \"appendfsync none\". In practical terms, this means that it is# possible to lose up to 30 seconds of log in the worst scenario (with the# default Linux settings).# # If you have latency problems turn this to \"yes\". Otherwise leave it as# \"no\" that is the safest pick from the point of view of durability.no-appendfsync-on-rewrite no# Automatic rewrite of the append only file.# Redis is able to automatically rewrite the log file implicitly calling# BGREWRITEAOF when the AOF log size grows by the specified percentage.# # This is how it works: Redis remembers the size of the AOF file after the# latest rewrite (if no rewrite has happened since the restart, the size of# the AOF at startup is used).## This base size is compared to the current size. If the current size is# bigger than the specified percentage, the rewrite is triggered. Also# you need to specify a minimal size for the AOF file to be rewritten, this# is useful to avoid rewriting the AOF file even if the percentage increase# is reached but it is still pretty small.## Specify a percentage of zero in order to disable the automatic AOF# rewrite feature.auto-aof-rewrite-percentage 100auto-aof-rewrite-min-size 64mb# An AOF file may be found to be truncated at the end during the Redis# startup process, when the AOF data gets loaded back into memory.# This may happen when the system where Redis is running# crashes, especially when an ext4 filesystem is mounted without the# data=ordered option (however this can't happen when Redis itself# crashes or aborts but the operating system still works correctly).## Redis can either exit with an error when this happens, or load as much# data as possible (the default now) and start if the AOF file is found# to be truncated at the end. The following option controls this behavior.## If aof-load-truncated is set to yes, a truncated AOF file is loaded and# the Redis server starts emitting a log to inform the user of the event.# Otherwise if the option is set to no, the server aborts with an error# and refuses to start. When the option is set to no, the user requires# to fix the AOF file using the \"redis-check-aof\" utility before to restart# the server.## Note that if the AOF file will be found to be corrupted in the middle# the server will still exit with an error. This option only applies when# Redis will try to read more data from the AOF file but not enough bytes# will be found.aof-load-truncated yes appendonly no # 默认是不开启 aof 模式的, 默认使用的是 rdb 方式持久化, 在大部分所有情况下, rdb 完全够用 appendfilename “appendonly.aof” # 持久化的文件的名字 appendfsync everysec # 每秒执行一次 sync 可能会丢失 1s 的数据 appendfsync no # 不执行 sync 这个时候操作系统自己同步数据 速度最快 appendfsync always # 每次修改都会 sync 消耗性能 文章已上传gitee https://gitee.com/codingce/hexo-blog 项目地址: https://github.com/xzMhehe/codingce-java","categories":[{"name":"Redis","slug":"Redis","permalink":"http://i.codingce.com.cn/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://i.codingce.com.cn/tags/Redis/"}]},{"title":"SpringBoot整合Redis","slug":"SpringBoot整合Redis","date":"2021-01-10T01:57:33.000Z","updated":"2021-01-11T01:41:38.714Z","comments":true,"path":"2021/01/10/SpringBoot整合Redis/","link":"","permalink":"http://i.codingce.com.cn/2021/01/10/SpringBoot%E6%95%B4%E5%90%88Redis/","excerpt":"","text":"SpringBoot整合Redis SpringBoot 操作数据:spring-data jpa jdbc mongodb redis SpringData 也是和 SpringBoot 齐名的项目 源码分析 12345678910111213141516171819@Bean@ConditionalOnMissingBean( name = &#123;\"redisTemplate\"&#125; // 我们自己可以自定义一个 redisTemplate 来替换这个默认的)public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException &#123; // 默认 redisTemplate 没有过多的设置, redis 对象都是需要序列化的 // 两个泛型都是 Object 类型 我们使用的时候需要强制转换 &lt;String, Object&gt; RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate(); template.setConnectionFactory(redisConnectionFactory); return template;&#125;@Bean@ConditionalOnMissingBeanpublic StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException &#123; StringRedisTemplate template = new StringRedisTemplate(); template.setConnectionFactory(redisConnectionFactory); return template;&#125; 整合 说明: 在 SpringBoot2.x 之后, 原来使用的 Jedis 被替换成了 lettuce jedis: 采用直连, 多个线程操作的话, 是不安全的, 如果想要避免不安全, 使用 jedis pool 连接池 更像BIO lettuce: 采用netty 实例可以多个线程中进行共享, 不存在线程不安全的情况, 可以减少线程数据 更像NIO 导入依赖 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;dependencies&gt; &lt;!-- 操作Redis 只需引入spring-boot-starter-data-redis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 配置链接 12345# SpringBoot 所有的配置类, 都有一个自动配置类 RedisAutoConfiguration# 自动配置类都会绑定一个 peoperties 配置文件 RedisPropertiesspring.redis.host=127.0.0.1spring.redis.port=6379 测试 12345678910111213141516171819202122 @Test void contextLoads() &#123; // redisTemplate // opsForValue() 操作字符串 类似 String // opsForList() 操作List 类似 List // opsForSet() // opsForHash() // opsForZSet() // opsForGeo() // opsForHyperLogLog() // 除了基本操作, 常用的方法都可以直接 redisTemplate 操作 例如事务的CRUD // 获取 redis 连接对象// RedisConnection connection = redisTemplate.getConnectionFactory().getConnection();// connection.flushDb();// connection.flushAll(); redisTemplate.opsForValue().set(\"mykey\", \"xz\"); System.out.println(redisTemplate.opsForValue().get(\"mykey\")); &#125; 序列化 实体类 12345678@Component@AllArgsConstructor@NoArgsConstructor@Datapublic class User &#123; private String name; private int age;&#125; 测试 12345678@Testvoid test() throws JsonProcessingException &#123; // 真实开发都是使用 json 来传递对象 User user = new User(\"全栈自学社区\", 2); String jsonUser = new ObjectMapper().writeValueAsString(user); redisTemplate.opsForValue().set(\"user\", user); //set(\"user\", jsonUser) System.out.println(redisTemplate.opsForValue().get(\"user\"));&#125; 这种写法会报 org.springframework.data.redis.serializer.SerializationException: Cannot serialize; 错误 所有对象都需要序列化. 使用json传递对象 set(&quot;user&quot;, jsonUser) User 类实现 Serializable 接口 编写自定义的 RedisTemplate 123456789101112131415161718192021222324252627282930@Bean@SuppressWarnings(\"all\")public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException &#123; // 自定义 String Object RedisTemplate&lt;String, Object&gt; template = new RedisTemplate(); template.setConnectionFactory(redisConnectionFactory); // Json 序列化配置 Jackson2JsonRedisSerializer&lt;Object&gt; objectJackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;Object&gt;(Object.class); // ObjectMapper 转译 ObjectMapper objectMapper = new ObjectMapper(); objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); objectJackson2JsonRedisSerializer.setObjectMapper(objectMapper); // String 的序列化 StringRedisSerializer stringRedisSerializer = new StringRedisSerializer(); // key 采用String的序列化方式 template.setKeySerializer(stringRedisSerializer); // hash 的key也采用 String 的序列化方式 template.setHashKeySerializer(stringRedisSerializer); // value 序列化方式采用 jackson template.setValueSerializer(objectJackson2JsonRedisSerializer); // hash 的 value 采用 jackson template.setHashValueSerializer(objectJackson2JsonRedisSerializer); template.afterPropertiesSet(); return template;&#125; RedisUtils 在企业开发中, 我们80%的情况下, 都不会使用原生方式去编写代码 RedisUtils 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604package cn.com.codingce.utils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.stereotype.Component;import org.springframework.util.CollectionUtils;import java.util.List;import java.util.Map;import java.util.Set;import java.util.concurrent.TimeUnit;/** * @author mxz */@Componentpublic final class RedisUtils &#123; @Autowired private RedisTemplate&lt;String, Object&gt; redisTemplate; /** * 指定缓存失效时间 * * @param key 键 * @param time 时间(秒) * @return */ public boolean expire(String key, long time) &#123; try &#123; if (time &gt; 0) &#123; redisTemplate.expire(key, time, TimeUnit.SECONDS); &#125; return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 根据 key 获取过期时间 * * @param key 键(不能为 Null) * @return 时间(秒) 返回0代表永久有效 */ public long getExpire(String key) &#123; return redisTemplate.getExpire(key, TimeUnit.SECONDS); &#125; /** * 判断 key 是否存在 * * @param key 键(不能为 Null) * @return true 存在 false 不存在 */ public boolean hashKey(String key) &#123; try &#123; return redisTemplate.hasKey(key); &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 删除缓存 * * @param key 可以传一个值 或多个 */ public void del(String... key) &#123; if (key != null &amp;&amp; key.length &gt; 0) &#123; redisTemplate.delete(key[0]); &#125; else &#123; redisTemplate.delete(CollectionUtils.arrayToList(key)); &#125; &#125; //==================================String==================================== /** * 普通缓存获取 * * @param key 键 * @return 值 */ public Object get(String key) &#123; return key == null ? null : redisTemplate.opsForValue().get(key); &#125; /** * 普通缓存放入 * * @param key 键 * @param value 值 * @return true 成功 false 失败 */ public boolean set(String key, Object value) &#123; try &#123; redisTemplate.opsForValue().set(key, value); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 普通缓存放入并设置时间 * * @param key 键 * @param value 值 * @param time 时间(秒) time &gt; 0 若 time &lt;= 0 将设置无限期 * @return true 成功 false 失败 */ public boolean set(String key, Object value, long time) &#123; try &#123; if (time &gt; 0) &#123; redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS); &#125; else &#123; set(key, value); &#125; return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 递增 * * @param key 键 * @param delta 要增加几(大于0) * @return */ public long incr(String key, long delta) &#123; if (delta &lt; 0) &#123; throw new RuntimeException(\"递增因子必须大于0\"); &#125; return redisTemplate.opsForValue().increment(key, delta); &#125; /** * 递减 * * @param key 键 * @param delta 要减少几(小于0) * @return */ public long decr(String key, long delta) &#123; if (delta &lt; 0) &#123; throw new RuntimeException(\"递减因子必须大于0\"); &#125; return redisTemplate.opsForValue().decrement(key, delta); &#125; // ================================Map================================= /** * HashGet * * @param key 键 不能为null * @param item 项 不能为null */ public Object hget(String key, String item) &#123; return redisTemplate.opsForHash().get(key, item); &#125; /** * 获取hashKey对应的所有键值 * * @param key 键 * @return 对应的多个键值 */ public Map&lt;Object, Object&gt; hmget(String key) &#123; return redisTemplate.opsForHash().entries(key); &#125; /** * HashSet * * @param key 键 * @param map 对应多个键值 */ public boolean hmset(String key, Map&lt;String, Object&gt; map) &#123; try &#123; redisTemplate.opsForHash().putAll(key, map); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * HashSet 并设置时间 * * @param key 键 * @param map 对应多个键值 * @param time 时间(秒) * @return true成功 false失败 */ public boolean hmset(String key, Map&lt;String, Object&gt; map, long time) &#123; try &#123; redisTemplate.opsForHash().putAll(key, map); if (time &gt; 0) &#123; expire(key, time); &#125; return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 向一张hash表中放入数据,如果不存在将创建 * * @param key 键 * @param item 项 * @param value 值 * @return true 成功 false失败 */ public boolean hset(String key, String item, Object value) &#123; try &#123; redisTemplate.opsForHash().put(key, item, value); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 向一张hash表中放入数据,如果不存在将创建 * * @param key 键 * @param item 项 * @param value 值 * @param time 时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间 * @return true 成功 false失败 */ public boolean hset(String key, String item, Object value, long time) &#123; try &#123; redisTemplate.opsForHash().put(key, item, value); if (time &gt; 0) &#123; expire(key, time); &#125; return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 删除hash表中的值 * * @param key 键 不能为null * @param item 项 可以使多个 不能为null */ public void hdel(String key, Object... item) &#123; redisTemplate.opsForHash().delete(key, item); &#125; /** * 判断hash表中是否有该项的值 * * @param key 键 不能为null * @param item 项 不能为null * @return true 存在 false不存在 */ public boolean hHasKey(String key, String item) &#123; return redisTemplate.opsForHash().hasKey(key, item); &#125; /** * hash递增 如果不存在,就会创建一个 并把新增后的值返回 * * @param key 键 * @param item 项 * @param by 要增加几(大于0) */ public double hincr(String key, String item, double by) &#123; return redisTemplate.opsForHash().increment(key, item, by); &#125; /** * hash递减 * * @param key 键 * @param item 项 * @param by 要减少记(小于0) */ public double hdecr(String key, String item, double by) &#123; return redisTemplate.opsForHash().increment(key, item, -by); &#125; // ============================set============================= /** * 根据key获取Set中的所有值 * * @param key 键 */ public Set&lt;Object&gt; sGet(String key) &#123; try &#123; return redisTemplate.opsForSet().members(key); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125; /** * 根据value从一个set中查询,是否存在 * * @param key 键 * @param value 值 * @return true 存在 false不存在 */ public boolean sHasKey(String key, Object value) &#123; try &#123; return redisTemplate.opsForSet().isMember(key, value); &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 将数据放入set缓存 * * @param key 键 * @param values 值 可以是多个 * @return 成功个数 */ public long sSet(String key, Object... values) &#123; try &#123; return redisTemplate.opsForSet().add(key, values); &#125; catch (Exception e) &#123; e.printStackTrace(); return 0; &#125; &#125; /** * 将set数据放入缓存 * * @param key 键 * @param time 时间(秒) * @param values 值 可以是多个 * @return 成功个数 */ public long sSetAndTime(String key, long time, Object... values) &#123; try &#123; Long count = redisTemplate.opsForSet().add(key, values); if (time &gt; 0) &#123; expire(key, time); &#125; return count; &#125; catch (Exception e) &#123; e.printStackTrace(); return 0; &#125; &#125; /** * 获取set缓存的长度 * * @param key 键 */ public long sGetSetSize(String key) &#123; try &#123; return redisTemplate.opsForSet().size(key); &#125; catch (Exception e) &#123; e.printStackTrace(); return 0; &#125; &#125; /** * 移除值为value的 * * @param key 键 * @param values 值 可以是多个 * @return 移除的个数 */ public long setRemove(String key, Object... values) &#123; try &#123; Long count = redisTemplate.opsForSet().remove(key, values); return count; &#125; catch (Exception e) &#123; e.printStackTrace(); return 0; &#125; &#125; // ===============================list================================= /** * 获取list缓存的内容 * * @param key 键 * @param start 开始 * @param end 结束 0 到 -1代表所有值 */ public List&lt;Object&gt; lGet(String key, long start, long end) &#123; try &#123; return redisTemplate.opsForList().range(key, start, end); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125; /** * 获取list缓存的长度 * * @param key 键 */ public long lGetListSize(String key) &#123; try &#123; return redisTemplate.opsForList().size(key); &#125; catch (Exception e) &#123; e.printStackTrace(); return 0; &#125; &#125; /** * 通过索引 获取list中的值 * * @param key 键 * @param index 索引 index&gt;=0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推 */ public Object lGetIndex(String key, long index) &#123; try &#123; return redisTemplate.opsForList().index(key, index); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125; /** * 将list放入缓存 * * @param key 键 * @param value 值 */ public boolean lSet(String key, Object value) &#123; try &#123; redisTemplate.opsForList().rightPush(key, value); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 将list放入缓存 * * @param key 键 * @param value 值 * @param time 时间(秒) */ public boolean lSet(String key, Object value, long time) &#123; try &#123; redisTemplate.opsForList().rightPush(key, value); if (time &gt; 0) &#123; expire(key, time); &#125; return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 将list放入缓存 * * @param key 键 * @param value 值 * @return */ public boolean lSet(String key, List&lt;Object&gt; value) &#123; try &#123; redisTemplate.opsForList().rightPushAll(key, value); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 将list放入缓存 * * @param key 键 * @param value 值 * @param time 时间(秒) * @return */ public boolean lSet(String key, List&lt;Object&gt; value, long time) &#123; try &#123; redisTemplate.opsForList().rightPushAll(key, value); if (time &gt; 0) &#123; expire(key, time); &#125; return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 根据索引修改list中的某条数据 * * @param key 键 * @param index 索引 * @param value 值 * @return */ public boolean lUpdateIndex(String key, long index, Object value) &#123; try &#123; redisTemplate.opsForList().set(key, index, value); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 移除N个值为value * * @param key 键 * @param count 移除多少个 * @param value 值 * @return 移除的个数 */ public long lRemove(String key, long count, Object value) &#123; try &#123; Long remove = redisTemplate.opsForList().remove(key, count, value); return remove; &#125; catch (Exception e) &#123; e.printStackTrace(); return 0; &#125; &#125; // ===============================HyperLogLog================================= public long pfadd(String key, String value) &#123; return redisTemplate.opsForHyperLogLog().add(key, value); &#125; public long pfcount(String key) &#123; return redisTemplate.opsForHyperLogLog().size(key); &#125; public void pfremove(String key) &#123; redisTemplate.opsForHyperLogLog().delete(key); &#125; public void pfmerge(String key1, String key2) &#123; redisTemplate.opsForHyperLogLog().union(key1, key2); &#125;&#125; 测试 12345@Testvoid testUtil() &#123; redisUtils.set(\"name\", \"全栈自学社区\"); System.out.println(redisUtils.get(\"name\"));&#125; 输出 1234567891011121314151617 . ____ _ __ _ _ /\\\\ / ___'_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.3.7.RELEASE)2021-01-10 14:48:52.184 INFO 17168 --- [ main] c.c.c.Redis02SpringbootApplicationTests : Starting Redis02SpringbootApplicationTests on DESKTOP-GMI8GKQ with PID 17168 (started by mxz in D:\\mxz_code\\codingce-java\\codingce-redis\\redis-02-springboot)2021-01-10 14:48:52.188 INFO 17168 --- [ main] c.c.c.Redis02SpringbootApplicationTests : No active profile set, falling back to default profiles: default2021-01-10 14:48:53.835 INFO 17168 --- [ main] .s.d.r.c.RepositoryConfigurationDelegate : Multiple Spring Data modules found, entering strict repository configuration mode!2021-01-10 14:48:53.846 INFO 17168 --- [ main] .s.d.r.c.RepositoryConfigurationDelegate : Bootstrapping Spring Data Redis repositories in DEFAULT mode.2021-01-10 14:48:53.935 INFO 17168 --- [ main] .s.d.r.c.RepositoryConfigurationDelegate : Finished Spring Data repository scanning in 29ms. Found 0 Redis repository interfaces.2021-01-10 14:48:56.930 INFO 17168 --- [ main] o.s.s.concurrent.ThreadPoolTaskExecutor : Initializing ExecutorService 'applicationTaskExecutor'2021-01-10 14:48:57.441 INFO 17168 --- [ main] c.c.c.Redis02SpringbootApplicationTests : Started Redis02SpringbootApplicationTests in 5.815 seconds (JVM running for 8.492)全栈自学社区 更重要的是理解 Redis 的思想和每一种数据结构的用处以及作用场景. 文章已上传gitee https://gitee.com/codingce/hexo-blog 项目地址: https://github.com/xzMhehe/codingce-java","categories":[{"name":"Redis","slug":"Redis","permalink":"http://i.codingce.com.cn/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://i.codingce.com.cn/tags/Redis/"}]},{"title":"Jedis","slug":"Jedis","date":"2021-01-08T02:58:52.000Z","updated":"2021-01-09T11:57:08.443Z","comments":true,"path":"2021/01/08/Jedis/","link":"","permalink":"http://i.codingce.com.cn/2021/01/08/Jedis/","excerpt":"","text":"Jedis 使用Java来操作Redis 什么是Jedis 是Redis官方推荐的Java操作Redis中间件, 如果你要使用Java操作Redis, 那么就该对jedis熟悉 测试 导入对应的依赖 12345678910111213&lt;!-- 导入jedisd的包 --&gt;&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- fastjson --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.62&lt;/version&gt;&lt;/dependency&gt; 编码测试 连接数据库 操作命令 断开连接 1234567@Testvoid TestPing() &#123; //1 new Jedis 对象即可 Jedis jedis = new Jedis(\"127.0.0.1\", 6379); //jedis 所有的命令就是他的基本命令, 就是对象的方法 System.out.println(jedis.ping());;&#125; 输出 PONG 常用API String List Set Hash Zset Redis-key 123456789101112131415161718192021@Testvoid TestKey() &#123; Jedis jedis = new Jedis(\"127.0.0.1\", 6379); System.out.println(\"清空数据\" + jedis.flushDB()); System.out.println(\"判断某个键是否存在: \" + jedis.exists(\"username\")); System.out.println(\"新增'&lt;username, mxz&gt;的键值对'\" + jedis.set(\"username\", \"mxz\")); System.out.println(\"新增'&lt;password, mxz&gt;的键值对'\" + jedis.set(\"password\", \"mxz\")); System.out.println(\"系统中所有的键值对如下: \"); Set&lt;String&gt; keys = jedis.keys(\"*\"); System.out.println(keys); System.out.println(\"删除键password: \" + jedis.del(\"password\")); System.out.println(\"判断键password是否存在: \" + jedis.exists(\"password\")); System.out.println(\"查看键username所存储值的类型: \" + jedis.type(\"username\")); System.out.println(\"随机返回key空间的一个: \" + jedis.randomKey()); System.out.println(\"重命名key: \" + jedis.rename(\"username\", \"name\")); System.out.println(\"按索引查询: \" + jedis.select(0)); System.out.println(\"删除当前选择数据库的所有的key: \" + jedis.flushDB()); System.out.println(\"返回当前数据库中key的数目: \" + jedis.dbSize()); System.out.println(\"删除所有数据库中的所有的key: \" + jedis.flushAll());&#125; 输出 123456789101112131415161718192021222324252627 . ____ _ __ _ _ /\\\\ / ___'_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.4.1)2021-01-08 19:28:31.602 INFO 7492 --- [ main] cn.com.codincge.RedisApplicationTests : Starting RedisApplicationTests using Java 1.8.0_181 on DESKTOP-GMI8GKQ with PID 7492 (started by mxz in D:\\mxz_code\\codingce-java\\codingce-redis\\redis-01-jedis)2021-01-08 19:28:31.608 INFO 7492 --- [ main] cn.com.codincge.RedisApplicationTests : No active profile set, falling back to default profiles: default2021-01-08 19:28:32.290 INFO 7492 --- [ main] cn.com.codincge.RedisApplicationTests : Started RedisApplicationTests in 1.133 seconds (JVM running for 3.804)清空数据OK判断某个键是否存在: false新增'&lt;username, mxz&gt;的键值对'OK新增'&lt;password, mxz&gt;的键值对'OK系统中所有的键值对如下: [password, username]删除键password: 1判断键password是否存在: false查看键username所存储值的类型: string随机返回key空间的一个: username重命名key: OK按索引查询: OK删除当前选择数据库的所有的key: OK返回当前数据库中key的数目: 0删除所有数据库中的所有的key: OK String(字符串) 1234567891011121314151617181920212223242526272829303132333435363738394041424344@Testvoid TestString() &#123; Jedis jedis = new Jedis(\"127.0.0.1\", 6379); System.out.println(\"=====增加数据=====\"); System.out.println(jedis.set(\"key1\", \"value1\")); System.out.println(jedis.set(\"key2\", \"value2\")); System.out.println(jedis.set(\"key3\", \"value3\")); System.out.println(\"删除键key2\" + jedis.del(\"key2\")); System.out.println(\"获取键key2\" + jedis.get(\"key2\")); System.out.println(\"修改key1\" + jedis.set(\"key1\", \"valueChanged\")); System.out.println(\"获取key1的值\" + jedis.get(\"key1\")); System.out.println(\"在key3后面加入值\" + jedis.append(\"key3\", \"end\")); System.out.println(\"key3的值\" + jedis.get(\"key3\")); System.out.println(\"增加多个键值对: \" + jedis.mset(\"key01\", \"value01\", \"key02\", \"value02\")); System.out.println(\"获取多个键值对: \" + jedis.mget(\"key01\", \"key02\", \"key03\")); System.out.println(\"获取多个键值对: \" + jedis.mget(\"key01\", \"key02\", \"key03\", \"key04\")); System.out.println(\"删除多个键值对: \" + jedis.del(\"key01\", \"key02\")); System.out.println(\"获取多个键值对: \" + jedis.mget(\"key01\", \"key02\", \"key03\")); jedis.flushDB(); System.out.println(\"=====新增键值对防止覆盖原先值=====\"); System.out.println(jedis.setnx(\"key1\", \"value1\")); System.out.println(jedis.setnx(\"key2\", \"value2\")); System.out.println(jedis.setnx(\"key2\", \"value2-new\")); System.out.println(jedis.get(\"key1\")); System.out.println(jedis.get(\"key2\")); System.out.println(\"=====新增键值对并设置有效时间=====\"); System.out.println(jedis.setex(\"key3\", 2, \"value3\")); System.out.println(jedis.get(\"key3\")); try &#123; TimeUnit.SECONDS.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(jedis.get(\"key3\")); System.out.println(\"=====获取原值, 更新为新值=====\"); System.out.println(jedis.getSet(\"key2\", \"key2GetSet\")); System.out.println(jedis.get(\"key2\")); System.out.println(\"获得key2的值字符串: \" + jedis.getrange(\"key2\", 2, 4));&#125; 输出 123456789101112131415161718192021222324252627282930313233343536373839404142 . ____ _ __ _ _ /\\\\ / ___'_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.4.1)2021-01-09 09:56:23.763 INFO 9088 --- [ main] cn.com.codincge.RedisApplicationTests : Starting RedisApplicationTests using Java 1.8.0_181 on DESKTOP-GMI8GKQ with PID 9088 (started by mxz in D:\\mxz_code\\codingce-java\\codingce-redis\\redis-01-jedis)2021-01-09 09:56:23.825 INFO 9088 --- [ main] cn.com.codincge.RedisApplicationTests : No active profile set, falling back to default profiles: default2021-01-09 09:56:25.462 INFO 9088 --- [ main] cn.com.codincge.RedisApplicationTests : Started RedisApplicationTests in 2.349 seconds (JVM running for 5.252)=====增加数据=====OKOKOK删除键key21获取键key2null修改key1OK获取key1的值valueChanged在key3后面加入值9key3的值value3end增加多个键值对: OK获取多个键值对: [value01, value02, null]获取多个键值对: [value01, value02, null, null]删除多个键值对: 2获取多个键值对: [null, null, null]=====新增键值对防止覆盖原先值=====110value1value2=====新增键值对并设置有效时间=====OKvalue3null=====获取原值, 更新为新值=====value2key2GetSet获得key2的值字符串: y2G List(列表) 12345678910111213141516171819202122232425262728293031323334353637@Testvoid TestList() &#123; Jedis jedis = new Jedis(\"127.0.0.1\", 6379); jedis.flushDB(); System.out.println(\"=====添加一个List=====\"); jedis.lpush(\"collections\", \"ArrayList\", \"Vector\", \"Stack\", \"HashMap\", \"WeakHashMap\", \"LinkedHashMap\"); jedis.lpush(\"collections\", \"HashSet\"); jedis.lpush(\"collections\", \"TreeSet\"); jedis.lpush(\"collections\", \"TreeMap\"); System.out.println(\"collections的内容\" + jedis.lrange(\"collections\", 0, -1));// -1代表倒数 System.out.println(\"collections区间 0-3 的元素: \" + jedis.lrange(\"collections\", 2, 3)); System.out.println(\"===========================================\"); // 删除列表指定的值, 第二个参数为删除的个数(有重复时), 后add进去的值先被删, 类似于出栈 System.out.println(\"删除指定元素个数: \" + jedis.lrem(\"collectionws\", 2, \"HashMap\")); System.out.println(\"collections的内容: \" + jedis.lrange(\"collections\", 0, -1)); System.out.println(\"删除下表0-3区间之外的元素: \" + jedis.ltrim(\"collections\", 0, 3)); System.out.println(\"collections内容: \" + jedis.lrange(\"collections\", 0, -1)); System.out.println(\"collections列表出栈(左端): \" + jedis.lpop(\"collections\")); System.out.println(\"collections的内容: \" + jedis.lrange(\"collections\", 0, -1)); System.out.println(\"collections添加元素, 从列表右端, 与lpush相对应: \" + jedis.rpush(\"collections\", \"test\")); System.out.println(\"collections的内容: \" + jedis.lrange(\"collections\", 0, -1)); System.out.println(\"collections列表出栈(右端): \" + jedis.rpop(\"collections\")); System.out.println(\"collections的内容: \" + jedis.lrange(\"collections\", 0, -1)); System.out.println(\"collections指定下标 1 的内容: \" + jedis.lset(\"collections\", 1, \"FLinkedHashMap\")); System.out.println(\"collections的内容: \" + jedis.lrange(\"collections\", 0, -1)); System.out.println(\"===========================================\"); System.out.println(\"collections的长度: \" + jedis.llen(\"collections\")); System.out.println(\"获取collections下标为 2 的元素\" + jedis.lindex(\"collections\", 2)); System.out.println(\"===========================================\"); jedis.lpush(\"sortedList\", \"3\", \"6\", \"2\", \"4\", \"5\", \"7\", \"9\"); System.out.println(\"sortedList排序前: \" + jedis.lrange(\"sortedList\", 0, -1)); System.out.println(jedis.sort(\"sortedList\")); System.out.println(\"sortedList排序后：\" + jedis.lrange(\"sortedList\", 0, -1));&#125; 输出 1234567891011121314151617181920212223242526272829303132333435 . ____ _ __ _ _ /\\\\ / ___'_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.4.1)2021-01-09 10:43:37.900 INFO 12624 --- [ main] cn.com.codincge.RedisApplicationTests : Starting RedisApplicationTests using Java 1.8.0_181 on DESKTOP-GMI8GKQ with PID 12624 (started by mxz in D:\\mxz_code\\codingce-java\\codingce-redis\\redis-01-jedis)2021-01-09 10:43:37.900 INFO 12624 --- [ main] cn.com.codincge.RedisApplicationTests : No active profile set, falling back to default profiles: default2021-01-09 10:43:38.572 INFO 12624 --- [ main] cn.com.codincge.RedisApplicationTests : Started RedisApplicationTests in 0.997 seconds (JVM running for 2.26)=====添加一个List=====collections的内容[TreeMap, TreeSet, HashSet, LinkedHashMap, WeakHashMap, HashMap, Stack, Vector, ArrayList]collections区间 0-3 的元素: [HashSet, LinkedHashMap]===========================================删除指定元素个数: 0collections的内容: [TreeMap, TreeSet, HashSet, LinkedHashMap, WeakHashMap, HashMap, Stack, Vector, ArrayList]删除下表0-3区间之外的元素: OKcollections内容: [TreeMap, TreeSet, HashSet, LinkedHashMap]collections列表出栈(左端): TreeMapcollections的内容: [TreeSet, HashSet, LinkedHashMap]collections添加元素, 从列表右端, 与lpush相对应: 4collections的内容: [TreeSet, HashSet, LinkedHashMap, test]collections列表出栈(右端): testcollections的内容: [TreeSet, HashSet, LinkedHashMap]collections指定下标 1 的内容: OKcollections的内容: [TreeSet, FLinkedHashMap, LinkedHashMap]===========================================collections的长度: 3获取collections下标为 2 的元素LinkedHashMap===========================================sortedList排序前: [9, 7, 5, 4, 2, 6, 3][2, 3, 4, 5, 6, 7, 9]sortedList排序后：[9, 7, 5, 4, 2, 6, 3] Set(集合) 1234567891011121314151617181920212223242526272829303132333435@Testvoid TestSet() &#123; Jedis jedis = new Jedis(\"127.0.0.1\", 6379); jedis.flushDB(); System.out.println(\"======向集合中添加元素(不重复)======\"); System.out.println(jedis.sadd(\"eleSet\", \"e0\", \"e1\", \"e2\", \"e3\", \"e4\", \"e5\")); System.out.println(jedis.sadd(\"eleSet\", \"e6\")); System.out.println(jedis.sadd(\"eleSet\", \"e6\")); System.out.println(\"eleSet的所有元素为: \" + jedis.smembers(\"eleSet\")); System.out.println(\"删除一个元素e0\" + jedis.srem(\"eleSet\", \"e0\")); System.out.println(\"删除两个元素e6 e7\" + jedis.srem(\"eleSet\", \"e7\", \"e6\")); System.out.println(\"eleSet的所有元素为: \" + jedis.smembers(\"eleSet\")); System.out.println(\"随机移除集合中的一个元素: \" + jedis.spop(\"eleSet\")); System.out.println(\"随机移除集合中的一个元素: \" + jedis.spop(\"eleSet\")); System.out.println(\"eleSet的所有元素为: \" + jedis.smembers(\"eleSet\")); System.out.println(\"eleSet中包含元素的个数: \" + jedis.scard(\"eleSet\")); System.out.println(\"e3是否在eleSet中: \" + jedis.sismember(\"eleSet\", \"e3\")); System.out.println(\"e1是否在eleSet中: \" + jedis.sismember(\"eleSet\", \"e1\")); System.out.println(\"e5是否在eleSet中: \" + jedis.sismember(\"eleSet\", \"e5\")); System.out.println(\"========================================\"); System.out.println(jedis.sadd(\"eleSet1\", \"e0\", \"e1\", \"e2\", \"e3\", \"e4\", \"e5\")); System.out.println(jedis.sadd(\"eleSet2\", \"e0\", \"e1\", \"e2\", \"e3\", \"e4\", \"e5\", \"e6\", \"e7\", \"e8\")); System.out.println(\"将eleSet1中删除e1并存入eleSet3中: \" + jedis.smove(\"eleSet1\", \"eleSet3\", \"e1\")); System.out.println(\"将eleSet2中删除e2并存入eleSet3中: \" + jedis.smove(\"eleSet2\", \"eleSet3\", \"e2\")); System.out.println(\"eleSet1中的元素: \" + jedis.smembers(\"eleSet1\")); System.out.println(\"eleSet2中的元素: \" + jedis.smembers(\"eleSet2\")); System.out.println(\"=====集合运算=====\"); System.out.println(\"eleSet1中的元素: \" + jedis.smembers(\"eleSet1\")); System.out.println(\"eleSet2中的元素: \" + jedis.smembers(\"eleSet2\")); System.out.println(\"eleSet1和eleSet2的交集\" + jedis.sinter(\"eleSet1\", \"eleSet2\")); System.out.println(\"eleSet1和eleSet2的并集\" + jedis.sunion(\"eleSet1\", \"eleSet2\")); System.out.println(\"eleSet1和eleSet2的差集\" + jedis.sdiff(\"eleSet1\", \"eleSet2\")); //eleSet1中有, EleSet2中没有 jedis.sinterstore(\"eleSet4\", \"eleSet1\", \"eleSet2\"); //求交集并将交集保存到 dstkey的集合 System.out.println(\"eleSet4中的元素: \" + jedis.smembers(\"eleSet4\"));&#125; 输出 1234567891011121314151617181920212223242526272829303132333435363738394041 . ____ _ __ _ _ /\\\\ / ___'_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.4.1)2021-01-09 11:25:15.843 INFO 6516 --- [ main] cn.com.codincge.RedisApplicationTests : Starting RedisApplicationTests using Java 1.8.0_181 on DESKTOP-GMI8GKQ with PID 6516 (started by mxz in D:\\mxz_code\\codingce-java\\codingce-redis\\redis-01-jedis)2021-01-09 11:25:15.843 INFO 6516 --- [ main] cn.com.codincge.RedisApplicationTests : No active profile set, falling back to default profiles: default2021-01-09 11:25:16.718 INFO 6516 --- [ main] cn.com.codincge.RedisApplicationTests : Started RedisApplicationTests in 1.207 seconds (JVM running for 2.739)======向集合中添加元素(不重复)======610eleSet的所有元素为: [e5, e1, e0, e2, e3, e6, e4]删除一个元素e01删除两个元素e6 e71eleSet的所有元素为: [e5, e1, e2, e3, e4]随机移除集合中的一个元素: e5随机移除集合中的一个元素: e2eleSet的所有元素为: [e1, e3, e4]eleSet中包含元素的个数: 3e3是否在eleSet中: truee1是否在eleSet中: truee5是否在eleSet中: false========================================69将eleSet1中删除e1并存入eleSet3中: 1将eleSet2中删除e2并存入eleSet3中: 1eleSet1中的元素: [e3, e5, e0, e2, e4]eleSet2中的元素: [e1, e0, e3, e6, e4, e8, e5, e7]=====集合运算=====eleSet1中的元素: [e3, e5, e0, e2, e4]eleSet2中的元素: [e1, e0, e3, e6, e4, e8, e5, e7]eleSet1和eleSet2的交集[e3, e5, e0, e4]eleSet1和eleSet2的并集[e7, e5, e1, e0, e8, e2, e3, e4, e6]eleSet1和eleSet2的差集[e2]eleSet4中的元素: [e0, e5, e4, e3] Hash(哈希) 12345678910111213141516171819202122232425262728@Testvoid TestHash() &#123; Jedis jedis = new Jedis(\"127.0.0.1\", 6379); jedis.flushDB(); Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(\"key1\", \"value1\"); map.put(\"key2\", \"value2\"); map.put(\"key3\", \"value3\"); map.put(\"key4\", \"value4\"); //添加名称为hash(key) 的hash元素 jedis.hmset(\"hash\", map); //向名称为hash的hash中添加key为key5, value为value5的元素 jedis.hset(\"hash\", \"key5\", \"value5\"); System.out.println(\"散列hash的所有键值对为: \" + jedis.hgetAll(\"hash\")); System.out.println(\"散列hash的所有的键为: \" + jedis.hkeys(\"hash\")); //return Set&lt;String&gt; System.out.println(\"散列hash的所有的值为: \" + jedis.hvals(\"hash\")); //return List&lt;String&gt; System.out.println(\"将key6保存的值加上一个整数, 如果key6不存在则添加key6: \" + jedis.hincrBy(\"hash\", \"key6\", 1)); System.out.println(\"散列hash的所有键值对为: \" + jedis.hgetAll(\"hash\")); System.out.println(\"将key6保存的值加上一个整数, 如果key6不存在则添加key6: \" + jedis.hincrByFloat(\"hash\", \"key6\", 1.0)); System.out.println(\"散列hash的所有键值对为: \" + jedis.hgetAll(\"hash\")); System.out.println(\"删除一个或多个键值对: \" + jedis.hdel(\"hash\", \"key2\")); System.out.println(\"散列hash的所有键值对为: \" + jedis.hgetAll(\"hash\")); System.out.println(\"散列hash的所有键值对个数: \" + jedis.hlen(\"hash\")); System.out.println(\"判断散列hash中是否存在key2: \" + jedis.hexists(\"hash\", \"key2\")); System.out.println(\"判断散列hash中是否存在key3: \" + jedis.hexists(\"hash\", \"key3\")); System.out.println(\"获取hash中的值: \" + jedis.hmget(\"hash\", \"key3\")); System.out.println(\"获取hash中的值: \" + jedis.hmget(\"hash\", \"key3\", \"key4\"));&#125; 输出 1234567891011121314151617181920212223242526272829 . ____ _ __ _ _ /\\\\ / ___'_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.4.1)2021-01-09 13:27:34.237 INFO 11788 --- [ main] cn.com.codincge.RedisApplicationTests : Starting RedisApplicationTests using Java 1.8.0_181 on DESKTOP-GMI8GKQ with PID 11788 (started by mxz in D:\\mxz_code\\codingce-java\\codingce-redis\\redis-01-jedis)2021-01-09 13:27:34.242 INFO 11788 --- [ main] cn.com.codincge.RedisApplicationTests : No active profile set, falling back to default profiles: default2021-01-09 13:27:35.059 INFO 11788 --- [ main] cn.com.codincge.RedisApplicationTests : Started RedisApplicationTests in 1.276 seconds (JVM running for 3.17)散列hash的所有键值对为: &#123;key1=value1, key2=value2, key5=value5, key3=value3, key4=value4&#125;散列hash的所有的键为: [key1, key2, key5, key3, key4]散列hash的所有的值为: [value1, value3, value4, value2, value5]将key6保存的值加上一个整数, 如果key6不存在则添加key6: 1散列hash的所有键值对为: &#123;key1=value1, key2=value2, key5=value5, key6=1, key3=value3, key4=value4&#125;将key6保存的值加上一个整数, 如果key6不存在则添加key6: 2.0散列hash的所有键值对为: &#123;key1=value1, key2=value2, key5=value5, key6=2, key3=value3, key4=value4&#125;删除一个或多个键值对: 1散列hash的所有键值对为: &#123;key1=value1, key5=value5, key6=2, key3=value3, key4=value4&#125;散列hash的所有键值对个数: 5判断散列hash中是否存在key2: false判断散列hash中是否存在key3: true获取hash中的值: [value3]获取hash中的值: [value3, value4]Process finished with exit code 0 项目地址 https://github.com/xzMhehe/codingce-java","categories":[{"name":"Redis","slug":"Redis","permalink":"http://i.codingce.com.cn/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://i.codingce.com.cn/tags/Redis/"}]},{"title":"Redis事务与监控","slug":"Redis事务与监控","date":"2021-01-07T11:42:09.000Z","updated":"2021-01-08T02:54:23.631Z","comments":true,"path":"2021/01/07/Redis事务与监控/","link":"","permalink":"http://i.codingce.com.cn/2021/01/07/Redis%E4%BA%8B%E5%8A%A1%E4%B8%8E%E7%9B%91%E6%8E%A7/","excerpt":"","text":"事务 Redis单条命令是保证原子性的,但是事务不保证原子性的 Redis事务没有隔离级别的概念 所有的命命令在事务中, 并没有直接被执行, 只有发起执行命令的时候才会被执行 Redis 事务的本质： 一组命令的集合 一个事务中的所有命令都会被序列化, 在事务执行过程中, 会按照顺序执行 一次性 顺序性 排他性 执行一系列的命令 1----- 队列set set set 执行----- Redis的事务: 开启事务(multi) 命令入队(…) 执行事务(exec) 正常执行事务 123456789101112131415161718127.0.0.1:6379&gt; multi # 开启事务OK# 命令入队127.0.0.1:6379&gt; set k1 v1QUEUED127.0.0.1:6379&gt; set k2 v2QUEUED127.0.0.1:6379&gt; get k2QUEUED127.0.0.1:6379&gt; set k3 v3QUEUED# 执行事务127.0.0.1:6379&gt; exec1) OK2) OK3) \"v2\"4) OK127.0.0.1:6379&gt; 放弃事务 12345678127.0.0.1:6379&gt; multi # 开启事务OK127.0.0.1:6379&gt; set k4 v4QUEUED127.0.0.1:6379&gt; discard # 取消事务OK127.0.0.1:6379&gt; get k4 # 事务队列中的命令都不会执行(nil) 编译型异常 (代码有错误 命令有错误) 事务中的所有命令都不会被执行 12345678910111213141516171819127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; set k1 v1QUEUED127.0.0.1:6379&gt; set k2 v2QUEUED127.0.0.1:6379&gt; set k3 v3QUEUED127.0.0.1:6379&gt; getset k3 # 错误的命令(error) ERR wrong number of arguments for 'getset' command127.0.0.1:6379&gt; set k4 v4QUEUED127.0.0.1:6379&gt; set k5 v5QUEUED127.0.0.1:6379&gt; exec # 执行的时候报错(error) EXECABORT Transaction discarded because of previous errors.127.0.0.1:6379&gt; get k5 # 所有的命令都不会被执行(nil)127.0.0.1:6379&gt; 运行时异常 如果事务队列中存在语法性错误, 那么执行命令的时候, 其他命令是可以正常执行的, 错误命令抛出异常 123456789101112131415161718127.0.0.1:6379&gt; set k1 \"v1\"OK127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; incr k1 # 会在执行的时候失败QUEUED127.0.0.1:6379&gt; set k2 v2QUEUED127.0.0.1:6379&gt; set k3 v3QUEUED127.0.0.1:6379&gt; get k3QUEUED127.0.0.1:6379&gt; exec # 虽然第一条命令报错了, 但是依旧正常执行成功了1) (error) ERR value is not an integer or out of range2) OK3) OK4) \"v3\"127.0.0.1:6379&gt; 监控 Watch 悲观锁 很悲观, 认为什么时候都会出现问题, 无论做什么都会加锁. 乐观锁 很乐观, 认为什么时候都不会出现问题, 所以不会加锁. 更新数据的时候去判断一下, 在此期间是否有人修改过这个数据 获取version 更新时比较version Watch本省就是个乐观锁 Redis监视测试 正常执行成功 12345678910111213141516127.0.0.1:6379&gt; set money 100OK127.0.0.1:6379&gt; set out 0OK127.0.0.1:6379&gt; watch money # 监视money对象OK127.0.0.1:6379&gt; multi # 事务正常结束, 数据期间没有发生变动, 这个时候就正常执行成功OK127.0.0.1:6379&gt; decrby money 20QUEUED127.0.0.1:6379&gt; incrby out 20QUEUED127.0.0.1:6379&gt; exec1) (integer) 802) (integer) 20127.0.0.1:6379&gt; 测试多线程修改值, 监视失败, 使用watch可以当作redis乐观锁操作 线程一 1234567891011127.0.0.1:6379&gt; watch money # 监视moneyOK127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; decrby money 10QUEUED127.0.0.1:6379&gt; incrby out 10QUEUED127.0.0.1:6379&gt; exec # 执行事务之前在, 另外一个线程, 修改了我们的值, 就会导致事务执行失败. (nil)127.0.0.1:6379&gt; 线程二 12345127.0.0.1:6379&gt; get money\"80\"127.0.0.1:6379&gt; set money 1000OK127.0.0.1:6379&gt; 解决方案 1234567891011121314127.0.0.1:6379&gt; unwatch # 如果发现事务执行失败, 就先解锁OK127.0.0.1:6379&gt; watch money # 获取新的值, 再次监视, select versionOK127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; decrby money 1QUEUED127.0.0.1:6379&gt; incrby money 1QUEUED127.0.0.1:6379&gt; exec # 比对监视的值是否发生变化, 如果没有变化, 执行成功, 如果执行失败, 那么就继续 先解锁 -》 获取新值再次监视......1) (integer) 9992) (integer) 1000127.0.0.1:6379&gt;","categories":[{"name":"Redis","slug":"Redis","permalink":"http://i.codingce.com.cn/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://i.codingce.com.cn/tags/Redis/"}]},{"title":"Redis三种特殊类型","slug":"Redis三种特殊类型","date":"2021-01-06T01:48:18.000Z","updated":"2021-01-07T02:59:19.063Z","comments":true,"path":"2021/01/06/Redis三种特殊类型/","link":"","permalink":"http://i.codingce.com.cn/2021/01/06/Redis%E4%B8%89%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"Redis三种特殊类型 三种特殊数据类型 geospatial 地理位置 朋友的定位, 附近的人, 打车的距离计算 Redis的Geo在Redis3.2版本就推出了.这个功能可以推算地理位置信息, 两地之间的距离, 方圆几里的人 首先需要一个城市经度纬度查询工具 自行百度搜索 只有六个命令 相关命令 GEOADD GEODIST GEOHASH GEOPOS GEORADIUS GEORADIUSBYMEMBER getadd 添加地理位置 规则:两级无法添加, 我们一般会下载城市数据, 直接通过java程序一次性导入 参数key 值(纬度、经度、名称) 具体的限制，由EPSG:900913 / EPSG:3785 / OSGEO:41001 规定如下： 有效的经度从-180度到180度。 有效的纬度从-85.05112878度到85.05112878度。 当坐标位置超出上述指定范围时，该命令将会返回一个错误。 (error) ERR invalid longitude,latitude pair 39.900000,116.400000 GEOADD 1234567891011127.0.0.1:6379&gt; GEOADD china:city 116.40 39.90 beijing(integer) 1127.0.0.1:6379&gt; geoadd china:city 121.47 31.23 shanghai(integer) 1127.0.0.1:6379&gt; geoadd china:city 106.50 29.53 chongqing(integer) 1127.0.0.1:6379&gt; geoadd china:city 114.05 22.52 shenzhen(integer) 1127.0.0.1:6379&gt; geoadd china:city 120.16 30.24 hangzhou 108.96 34.26 xian(integer) 2127.0.0.1:6379&gt; GEOPOS 获取当前位置定位: 一定是一个坐标值! 123456789127.0.0.1:6379&gt; geopos china:city beijing # 获取指定城市的经度纬度1) 1) \"116.39999896287918\" 2) \"39.900000091670925\"127.0.0.1:6379&gt; geopos china:city beijing chongqing # 获取指定城市的经度纬度1) 1) \"116.39999896287918\" 2) \"39.900000091670925\"2) 1) \"106.49999767541885\" 2) \"29.529999579006592\"127.0.0.1:6379&gt; GEODIST 获取当前位置定位: 一定是一个坐标值! 123456789127.0.0.1:6379&gt; geopos china:city beijing # 获取指定城市的经度纬度1) 1) \"116.39999896287918\" 2) \"39.900000091670925\"127.0.0.1:6379&gt; geopos china:city beijing chongqing # 获取指定城市的经度纬度1) 1) \"116.39999896287918\" 2) \"39.900000091670925\"2) 1) \"106.49999767541885\" 2) \"29.529999579006592\"127.0.0.1:6379&gt; GEODIST 两人之间的距离 返回两个给定位置之间的距离。 如果两个位置之间的其中一个不存在， 那么命令返回空值。 指定单位的参数 unit 必须是以下单位的其中一个： m 表示单位为米。 km 表示单位为千米。 mi 表示单位为英里。 ft 表示单位为英尺。 1234567127.0.0.1:6379&gt; GEODIST china:city beijing shanghai\"1067378.7564\"127.0.0.1:6379&gt; GEODIST china:city beijing shanghai km\"1067.3788\"127.0.0.1:6379&gt; GEODIST china:city beijing chongqing\"1464070.8051\"127.0.0.1:6379&gt; GEORADIUS 附近的人(获取所有附近的人的地址, 定位! )通过半径来查询 以给定的经纬度为中心， 返回键包含的位置元素当中， 与中心的距离不超过给定最大距离的所有位置元素。 范围可以使用以下其中一个单位： m 表示单位为米。 km 表示单位为千米。 mi 表示单位为英里。 ft 表示单位为英尺。 所有数据都应该录入: china:city 才会让结果更加的准确 123456789101112127.0.0.1:6379&gt; georadius china:city 110 30 1500 km # 获取 110 30 这个经纬度为中心 寻找方圆1000km 内的城市1) \"chongqing\"2) \"xian\"3) \"shenzhen\"4) \"hangzhou\"5) \"shanghai\"6) \"beijing\"127.0.0.1:6379&gt;georadius china:city 110 30 150 km withdist # 显示到中间距离的位置127.0.0.1:6379&gt; georadius china:city 110 30 150 km withcoord # 显示他人的定位信息 127.0.0.1:6379&gt; georadius china:city 110 30 150 km withdist withcoord count 2 # 筛选指定的结果(empty list or set)127.0.0.1:6379&gt; GEORADIUSBYMEMBER 找出位于指定元素周围元素的其他元素. 1234127.0.0.1:6379&gt; georadiusbymember china:city beijing 1000 km1) \"beijing\"2) \"xian\"127.0.0.1:6379&gt; GEOHASH 命令返回一个或多个位置的geohash表示 该命令将返回11个字符的Geohash字符串 12345# 将二维经纬度转换为一维的字符串, 如果两个字符串越接近, 那么则距离越近127.0.0.1:6379&gt; geohash china:city beijing chongqing1) \"wx4fbxxfke0\"2) \"wm5xzrybty0\"127.0.0.1:6379&gt; GEO底层实现原理 其实就是Zset 我们可以使用Zset命令来操作geo 12345678127.0.0.1:6379&gt; zrange china:city 0 -11) \"chongqing\"2) \"xian\"3) \"shenzhen\"4) \"hangzhou\"5) \"shanghai\"6) \"beijing\"127.0.0.1:6379&gt; HyperLogLogs 什么是基数 基数（cardinality，也译作势），是指一个集合（这里的集合允许存在重复元素，与集合论对集合严格的定义略有不同，如不做特殊说明，本文中提到的集合均允许存在重复元素）中不同元素的个数。例如看下面的集合： A{1, 2, 3, 4, 5, 2, 3, 9, 7} 这个集合有9个元素，但是2和3各出现了两次，因此不重复的元素为1,2,3,4,5,9,7，所以这个集合的基数是7。 如果两个集合具有相同的基数，我们说这两个集合等势。基数和等势的概念在有限集范畴内比较直观，但是如果扩展到无限集则会比较复杂，一个无限集可能会与其真子集等势（例如整数集和偶数集是等势的）。 简介 Redis 2.8.9 版本就更新了 HyperLogLogs 数据结构 优点: 占用内存是固定的 2^64 不同的元素的技术 只需要12kb 的内存 若从内存角度比较的话 HyperLogLogs 首选 Redis HyperLogLogs 基数统计算法 网页UV(一个人访问网站多次, 但是还是算作一个人) 传统方式 set保存用户的id 然后就可以统计set元素数量就可以作为标准判断 这种方式保存大量的用户id就会比较麻烦 我们的目的是为了计数 而不是保存用户id 0.81%错误率 统计UV任务 可以忽略不记的 12345678910111213127.0.0.1:6379&gt; PFadd mykey a b c d e f g h i j # 创建第一个元素 mykey(integer) 1127.0.0.1:6379&gt; pfcount mykey # 统计 mykey 元素的基数数量(integer) 10127.0.0.1:6379&gt; PFadd mykey2 i j k l m n o p # 创建第二个元素 mykey2(integer) 1127.0.0.1:6379&gt; pfcount mykey2(integer) 8127.0.0.1:6379&gt; pfmerge mykey3 mykey mykey2 # 合并两组 mykey mykey2 =&gt; mykey3 并集OK127.0.0.1:6379&gt; pfcount mykey3(integer) 16127.0.0.1:6379&gt; 如果允许容错 那么一定可以使用 HyperLogLogs 如果不允许容错 就使用set或者自己的数据类型即可 Bitmaps 位存储 统计用户信息(活跃 不活跃) 登录 未登录 打卡（365打卡） 两个状态 都可以使用Bitmaps Bitmaps 位图 数据结构 都是操作二进制位 来进行记录 就只有 0 和1 两个状态 测试 使用bitmap来记录周一到周日的打卡 周一 1 周二 0 周三 1 周四 0 周五 1 周六 1 周日 0 123456789101112131415127.0.0.1:6379&gt; setbit sign 0 1(integer) 0127.0.0.1:6379&gt; setbit sign 1 0(integer) 0127.0.0.1:6379&gt; setbit sign 2 1(integer) 0127.0.0.1:6379&gt; setbit sign 3 0(integer) 0127.0.0.1:6379&gt; setbit sign 4 1(integer) 0127.0.0.1:6379&gt; setbit sign 5 1(integer) 0127.0.0.1:6379&gt; setbit sign 6 0(integer) 0127.0.0.1:6379&gt; 查看某一天是否打卡 12345127.0.0.1:6379&gt; getbit sign 5(integer) 1127.0.0.1:6379&gt; getbit sign 3(integer) 0127.0.0.1:6379&gt; 统计操作 统计打卡的天数 123127.0.0.1:6379&gt; bitcount sign(integer) 4127.0.0.1:6379&gt; 参考文献来源 http://blog.codinglabs.org","categories":[{"name":"Redis","slug":"Redis","permalink":"http://i.codingce.com.cn/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://i.codingce.com.cn/tags/Redis/"}]},{"title":"Redis入门","slug":"Redis入门","date":"2020-10-24T13:42:06.000Z","updated":"2021-01-07T01:48:22.486Z","comments":true,"path":"2020/10/24/Redis入门/","link":"","permalink":"http://i.codingce.com.cn/2020/10/24/Redis%E5%85%A5%E9%97%A8/","excerpt":"","text":"Redis是什么 Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由Pivotal赞助。 Redis能干嘛 内存存储、持久化、内存中是断电即失、所以说持久化很重要(rdb aof) 效率高、可以用于告诉缓存 发布订阅系统 地图信息分析 计时器、计数器（浏览量） … 特性 多样化数据 持久化数据 集群 事务 … 学习中需要的东西 全栈自学社区公众号 官网：https://redis.io 中文网：http:www.redis.cn/ 安装 Windows安装 下载安装包：github 开启Redis 双击运行即可 默认端口6379 使用Redis连接Redis ping 测试连接 set 基本值 set基本值 key value get key get name Windows 下使用虽然简单 但是Redis 推荐我们使用Linux去开发使用 Linux安装 基本环境安装 yum install gcc-c++ Redis默认安装路径 usr local bin 将redis 配置文件 cp /usr/redis/redis-5.0.7/redis.confg mconfig redis默认不是后台启动的 修改配置文件 启动redis服务 redis-server /usr/local/bin/mconfig/redis.conf 通过指定的配置文件启动 使用redis-cli -p 6379 连接测试 如何关闭服务呢 shutdown 测试性能 redis-benchmark 是一个压力测试工具！ 官方自带工具 redis-benchmark命令参数 https://www.runoob.com/redis/redis-benchmarks.html 我们来简单测试下： 测试：100并发 100000个请求 redis-benchmark -h localhost -p 6379 -c 100 -n 100000 如何查看这个分析呢 其他类似 基础知识 redis默认有16个数据库 DBSIZE 1234567891011121314151617181920212223242526272829303132333435363738394041424344127.0.0.1:6379&gt; DBSIZE(integer) 5127.0.0.1:6379&gt; select 3 # 切换数据库OK127.0.0.1:6379[3]&gt; DBSIZE # 查看大小(integer) 0127.0.0.1:6379[3]&gt; 127.0.0.1:6379&gt; keys * # 查看所有的*1) \"myset:__rand_int__\"2) \"mylist\"3) \"name\"4) \"counter:__rand_int__\"5) \"key:__rand_int__\"127.0.0.1:6379&gt; 127.0.0.1:6379[5]&gt; set name mxzOK127.0.0.1:6379[5]&gt; keys *1) \"name\"127.0.0.1:6379[5]&gt; flushdb # 清除当前数据库数据OK127.0.0.1:6379[5]&gt; keys *(empty list or set)127.0.0.1:6379[5]&gt; EXISTS name1 # 判断当前key是否存在127.0.0.1:6379[5]&gt; move name 1 # 移除当前的key127.0.0.1:6379[5]&gt; FLUSHALL # 清除全部数据127.0.0.1:6379&gt; EXPIRE name 10(integer) 1127.0.0.1:6379&gt; ttl name127.0.0.1:6379&gt; get name(nil)127.0.0.1:6379&gt; type name # 查看当前类型string127.0.0.1:6379&gt; 127.0.0.1:6379[5]&gt; EXPIRE name # 设置key的过期时间, 单位是秒 http://www.redis.cn/commands.html 命令 为什么redis 的端口号是 6379？ 6379在是手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字。MERZ长期以来被antirez及其朋友当作愚蠢的代名词。Redis作者antirez同学在twitter上说将在下一篇博文中向大家解释为什么他选择6379作为默认端口号。而现在这篇博文出炉，在解释了Redis的LRU机制之后，向大家解释了采用6379作为默认端口的原因. Redis是单线程的 基于内存操作, CPU不是Redis性能瓶颈, Redis 的瓶颈根据机器的内存和网络带宽, 既然可以使用单线程来实现, 就使用单线程了. 所以就是用了单线程 Redis是c语言写的, 官方提供的数据为 100000 + 的QPS 完全不比同样key-value的Memecache差 Redis为什么单线程还这么快？ 误区1：高性能的服务器一定是多线程的？ 误区2：多线程（CPU）一定比单线程的 效率高？ 核心：Redis是将所有的数据全部放在内存中, 所以说使用单线程去操作的效率就是最高的,多线程（CPU上下文会切换：耗时的操作） 对于内存系统来说, 如果没有上下文切换效率就是最高的！多次读写在同一个CPU上的, 在内存情况下, 这个就是最佳的方案！ 五大数据类型 官方文档 Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。 EXISTS name 判断这个key是否存在 Redis-Key String List Set Hash Zset 三种特殊数据类型 geospatial hyperloglog bitmaps String（字符串） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154127.0.0.1:6379&gt; select 1OK127.0.0.1:6379[1]&gt; DBSIZE(integer) 0127.0.0.1:6379[1]&gt; set key1 value1OK127.0.0.1:6379[1]&gt; get key1\"value1\"127.0.0.1:6379[1]&gt; EXISTS key1(integer) 1127.0.0.1:6379[1]&gt; APPEND key1 \"hello\" # 追加字符串, 如果当前key不存在, 就相当于set key(integer) 11127.0.0.1:6379[1]&gt; get key1\"value1hello\"127.0.0.1:6379[1]&gt; STRLEN key1 # 获取字符串长度(integer) 11127.0.0.1:6379[1]&gt; APPEND key1 \"hello\"(integer) 16127.0.0.1:6379[1]&gt; STRLEN key1(integer) 16127.0.0.1:6379[1]&gt; ########################################################################## i++# 步长 i+=127.0.0.1:6379[1]&gt; set views 0 # 初始浏览量为0OK127.0.0.1:6379[1]&gt; get views\"0\"127.0.0.1:6379[1]&gt; incr views # 自加1(integer) 1127.0.0.1:6379[1]&gt; incr views(integer) 2127.0.0.1:6379[1]&gt; incr views(integer) 3127.0.0.1:6379[1]&gt; incr views(integer) 4127.0.0.1:6379[1]&gt; incr views(integer) 5127.0.0.1:6379[1]&gt; get views\"5\"127.0.0.1:6379[1]&gt; decr views # 自减1(integer) 4127.0.0.1:6379[1]&gt; get views\"4\"127.0.0.1:6379[1]&gt; INCRBY views 10 # 自加 系数(integer) 14127.0.0.1:6379[1]&gt; INCRBY views 10(integer) 24127.0.0.1:6379[1]&gt; DECRBY views 10 # 自减 系数(integer) 14127.0.0.1:6379[1]&gt; ###########################################################################127.0.0.1:6379&gt; GETRANGE key1 0 3 # 获取字符串[0, 3]\"hell\"127.0.0.1:6379&gt; GETRANGE key1 0 -1 # 获取全部字符串 和get key 是一样的\"hello.xzm\"127.0.0.1:6379&gt; ############################################################################ 替换指定位置开始的字符串127.0.0.1:6379&gt; set key3 hahahahhahaOK127.0.0.1:6379&gt; get key3\"hahahahhaha\"127.0.0.1:6379&gt; SETRANGE key3 1 heheheh(integer) 11127.0.0.1:6379&gt; get key3\"hhehehehaha\"127.0.0.1:6379&gt; ############################################################################ setex(set with expire) # 设置过期时间# setnx(set if not exist) # 不存在设置 （分布式锁中会常常使用）127.0.0.1:6379&gt; setex key4 30 \"hello\" # 设置key4 的值为hello 30秒后过期127.0.0.1:6379&gt; get key4\"hello\"127.0.0.1:6379&gt; setnx mykey \"redis\" # 如果mykey不存在, 创建mykey(integer) 1127.0.0.1:6379&gt; keys *1) \"key1\"2) \"key2\"3) \"mykey\"4) \"name\"5) \"key3\"127.0.0.1:6379&gt; ttl key4(integer) -2127.0.0.1:6379&gt; setnx mykey \"MongoDB\" # 如果mykey存在, 则创建失败(integer) 0127.0.0.1:6379&gt; get mykey\"redis\"127.0.0.1:6379&gt; ###########################################################################mset k1 v1 k2 v2 k3 v3 # 同时设置多个值mget k1 k2 k3 # 同时获取多个值127.0.0.1:6379&gt; flushdbOK127.0.0.1:6379&gt; keys *(empty list or set)127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3OK127.0.0.1:6379&gt; keys *1) \"k3\"2) \"k1\"3) \"k2\"127.0.0.1:6379&gt; mget k1 k2 k31) \"v1\"2) \"v2\"3) \"v3\"127.0.0.1:6379&gt; msetnx k1 v1 k2 v2 k4 v4 # msetnx 是一个原子性操作 要么一起成功 要么一起失败(integer) 0127.0.0.1:6379&gt; get k3 \"v3\"127.0.0.1:6379&gt; get k4(nil)127.0.0.1:6379&gt; ###########################################################################对象set user:1&#123;name: zhangsan, age: 13&#125; # 设置一个user:1 对象 值为json字符串来保存一个对象# 这里的key是一个巧妙地设计: user:&#123;id&#125;:&#123;filed&#125;, 如此设计是完全正确的127.0.0.1:6379&gt; mset user:1:name zhangsan user:1:age 2 127.0.0.1:6379&gt; mget user:1:name user:1:age1) \"zhangsan\"2) \"2\"###########################################################################getset # 先get在set127.0.0.1:6379&gt; getset db redis # 如果不存在值 返回 nil(nil)127.0.0.1:6379&gt; get db\"redis\"127.0.0.1:6379&gt; getset db mongodb # 如果存在值 获取原来的值\"redis\"127.0.0.1:6379&gt; get db\"mongodb\" 数据结构是相同的 String类似使用的场景：value除了字符串还可以是数字 计数器 统计多单位的数量 粉丝数 对象缓存存储 List 基本的数据类型, 列表 不能重复 在redis里面 可以把list玩成 栈 队列 1234567891011121314151617181920212223242526272829303132127.0.0.1:6379&gt; sadd myset \"hello\" # 集合中添加一个元素(integer) 1127.0.0.1:6379&gt; keys *1) \"myset\"127.0.0.1:6379&gt; SMEMBERS myset # 查看指定set的所有值1) \"hello\"127.0.0.1:6379&gt; sadd myset \"codingce\"(integer) 1127.0.0.1:6379&gt; sadd myset \"love coding\"(integer) 1127.0.0.1:6379&gt; SMEMBERS myset # 查看指定set的所有值1) \"codingce\"2) \"love coding\"3) \"hello\"127.0.0.1:6379&gt; SISMEMBER myset hello # 判断指定元素是否在set中(integer) 1127.0.0.1:6379&gt; SISMEMBER myset hell(integer) 0127.0.0.1:6379&gt; scard myset # 获取set集合中的内容元素个数(integer) 3127.0.0.1:6379&gt; 127.0.0.1:6379&gt; scard myset(integer) 3127.0.0.1:6379&gt; srem myset hello # 移除set集合中的指定元素(integer) 1127.0.0.1:6379&gt; scard myset(integer) 2127.0.0.1:6379&gt; set 无序不重复集合, 抽取随机 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107127.0.0.1:6379&gt; SRANDMEMBER myset # 随机抽取一个元素\"love coding\"127.0.0.1:6379&gt; SRANDMEMBER myset 2 # 随机抽取二个元素1) \"codingce\"2) \"love coding\"127.0.0.1:6379&gt; SRANDMEMBER myset 3 # 随机抽取三个元素1) \"codingce\"2) \"love coding\"127.0.0.1:6379&gt; sadd keyset \"haha\"(integer) 1127.0.0.1:6379&gt; sadd keyset \"hehe\"(integer) 1127.0.0.1:6379&gt; SRANDMEMBER myset 31) \"codingce\"2) \"love coding\"127.0.0.1:6379&gt; SRANDMEMBER myset 31) \"codingce\"2) \"love coding\"127.0.0.1:6379&gt; SRANDMEMBER myset 31) \"codingce\"2) \"love coding\"127.0.0.1:6379&gt; sadd myset \"haha\"(integer) 1127.0.0.1:6379&gt; sadd myset \"hehe\"(integer) 1127.0.0.1:6379&gt; SRANDMEMBER myset 31) \"codingce\"2) \"love coding\"3) \"hehe\"127.0.0.1:6379&gt; SRANDMEMBER myset 21) \"love coding\"2) \"hehe\"127.0.0.1:6379&gt; 127.0.0.1:6379&gt; SMEMBERS myset1) \"codingce\"2) \"hehe\"3) \"love coding\"4) \"haha\"127.0.0.1:6379&gt; spop myset # 随机移除元素\"haha\"127.0.0.1:6379&gt; SMEMBERS myset1) \"codingce\"2) \"hehe\"3) \"love coding\"127.0.0.1:6379&gt; #######################################################将一个指定的值, 移动到另一个set集合中127.0.0.1:6379&gt; sadd myset \"hello\"(integer) 1127.0.0.1:6379&gt; sadd myset \"world\"(integer) 1127.0.0.1:6379&gt; sadd myset \"xzM\"(integer) 1127.0.0.1:6379&gt; sadd myset2 \"set2\"(integer) 1127.0.0.1:6379&gt; smove myset myset2 \"xzM\" # 将元素移动到指定set中(integer) 1127.0.0.1:6379&gt; SMEMBERS myset1) \"hello\"2) \"world\"127.0.0.1:6379&gt; SMEMBERS myset21) \"xzM\"2) \"set2\"127.0.0.1:6379&gt; #######################################################微博、B站、共同关注（并集）数字集合类- 差集- 交集- 并集127.0.0.1:6379&gt; sadd key1 a(integer) 1127.0.0.1:6379&gt; sadd key1 b(integer) 1127.0.0.1:6379&gt; sadd key1 c(integer) 1127.0.0.1:6379&gt; sadd key2 d(integer) 1127.0.0.1:6379&gt; sadd key2 e(integer) 1127.0.0.1:6379&gt; SDIFF key1 key2 # 差集1) \"a\"2) \"b\"3) \"c\"127.0.0.1:6379&gt; sadd key2 c(integer) 1127.0.0.1:6379&gt; SINTER key1 key2 # 交集 共同好友就能这样实现1) \"c\"127.0.0.1:6379&gt; 127.0.0.1:6379&gt; SUNION key1 key2 # 并集1) \"a\"2) \"b\"3) \"d\"4) \"c\"5) \"e\" 微博、A用户将所有关注的人放在一个Set集合中！ 将它的粉丝也放在一个集合中！ 共同关注, 共同爱好, 二度好友（六度分割理论）推荐好友就是这么来的 Hash(哈希) Map集合 key-map 时候这个值就是一个map集合 本质和String类型没有太大区别, 还是一个简单的 key-value set myhash field xzm 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586127.0.0.1:6379&gt; hset myhash field1 xzm # set一个具体 key-value (integer) 1127.0.0.1:6379&gt; hget myhash field1 # 获取一个字段值\"xzm\"127.0.0.1:6379&gt; 127.0.0.1:6379&gt; hmset myhash field1 hello field2 world # set多个 key-valueOK 127.0.0.1:6379&gt; hget myhash # 获取多个字段的值1) \"hello\"2) \"world\"127.0.0.1:6379&gt; hgetall myhash # 获取全部的数据 key-value1) \"field1\"2) \"hello\"3) \"field2\"4) \"world\"127.0.0.1:6379&gt; 127.0.0.1:6379&gt; hdel myhash field1 # 删除hash 指定key字段 对应的 value值也就消失了(integer) 1127.0.0.1:6379&gt; hgetall myhash1) \"field2\"2) \"world\"127.0.0.1:6379&gt; #######################################################127.0.0.1:6379&gt; hdel myhash field1 (integer) 1127.0.0.1:6379&gt; hgetall myhash1) \"field2\"2) \"world\"127.0.0.1:6379&gt; hlen myhash(integer) 1127.0.0.1:6379&gt; hmset myhash field1 hello field2 world OK127.0.0.1:6379&gt; hgetall myhash1) \"field2\"2) \"world\"3) \"field1\"4) \"hello\"127.0.0.1:6379&gt; hlen myhash # 获取hash表的字段的数量(integer) 2127.0.0.1:6379&gt; 127.0.0.1:6379&gt; hlen myhash(integer) 2127.0.0.1:6379&gt; HEXISTS myhash field1 # 判断hash 中指定字段是否存在(integer) 1127.0.0.1:6379&gt; HEXISTS myhash field3(integer) 0127.0.0.1:6379&gt; ######################################################## 只获取所有的field# 只获取所有的value127.0.0.1:6379&gt; hkeys myhash 1) \"field2\"2) \"field1\"127.0.0.1:6379&gt; hvals myhash1) \"world\"2) \"hello\"127.0.0.1:6379&gt; #######################################################incr decr 127.0.0.1:6379&gt; hset myhash field4 hello(integer) 1127.0.0.1:6379&gt; hset myhash field4 hello(integer) 0127.0.0.1:6379&gt; hset myhash field5 5 # 指定增量(integer) 1127.0.0.1:6379&gt; HINCRBY myhash field5 1(integer) 6127.0.0.1:6379&gt; HINCRBY myhash field5 -1(integer) 5127.0.0.1:6379&gt; hsetnx myhash field6 hello # 如果不存在则可以设置(integer) 1127.0.0.1:6379&gt; hsetnx myhash field6 hello # 如果存在则不能设置(integer) 0 127.0.0.1:6379&gt; hash变更的数据 usr name age 12345127.0.0.1:6379&gt; hset user:1 name xzm(integer) 1127.0.0.1:6379&gt; hget user:1 name\"xzm\"127.0.0.1:6379&gt; Zset（有序集合） 在Set的基础上, 增加了一个值 set k1 v1 zset k1 score1 v1 123456789101112D:\\redis-64.3.0.503&gt;redis-cli -p 6379127.0.0.1:6379&gt; pingPONG127.0.0.1:6379&gt; zadd myset 1 one(integer) 1127.0.0.1:6379&gt; zadd myset 2 two 3 three(integer) 2127.0.0.1:6379&gt; ZRANGE myset 0 -11) \"one\"2) \"two\"3) \"three\"127.0.0.1:6379&gt; 排序如何实现 123456789101112131415161718192021222324252627282930313233127.0.0.1:6379&gt; zadd salary 2500 xiaohong(integer) 1127.0.0.1:6379&gt; zadd salary 5000 zhangsan(integer) 1127.0.0.1:6379&gt; zadd salary 200 xz(integer) 1127.0.0.1:6379&gt; ZRANGE myset 0 -11) \"one\"2) \"two\"3) \"three\"127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf +inf1) \"xz\"2) \"xiaohong\"3) \"zhangsan\"127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf +inf withscores # 显示全部的用户并且附带成绩1) \"xz\"2) \"200\"3) \"xiaohong\"4) \"2500\"5) \"zhangsan\"6) \"5000\"127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf 2500 withscores # 显示小于2500 员工的降序排列1) \"xz\"2) \"200\"3) \"xiaohong\"4) \"2500\"127.0.0.1:6379&gt;127.0.0.1:6379&gt; zrevrange salary 0 -1 # 从大到小排序1) \"zhangsan\"2) \"xz\"127.0.0.1:6379&gt; 移除rem中的元素 1234567891011121314127.0.0.1:6379&gt; zrange salary 0 -11) \"xz\"2) \"xiaohong\"3) \"zhangsan\"127.0.0.1:6379&gt; zrem salary xiaohong # 移除有序集合中的指定元素(integer) 1127.0.0.1:6379&gt; zrange salary 0 -11) \"xz\"2) \"zhangsan\"127.0.0.1:6379&gt; 127.0.0.1:6379&gt; zcard salary # 获取有序集合中的个数(integer) 2127.0.0.1:6379&gt; 获取指定区间的成员数量 1234567127.0.0.1:6379&gt; zcount myset 1 4(integer) 4127.0.0.1:6379&gt; zcount myset 1 3(integer) 3127.0.0.1:6379&gt; zcount myset 1 2(integer) 2127.0.0.1:6379&gt; 案例思路： set排序 存储班级成绩表 工资表牌序 普通消息 1 重要消息 2 带权重进行怕排序 排行榜的应用实现","categories":[{"name":"Redis","slug":"Redis","permalink":"http://i.codingce.com.cn/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://i.codingce.com.cn/tags/Redis/"}]},{"title":"NoSQL概述","slug":"NoSQL概述","date":"2020-10-21T10:29:50.000Z","updated":"2020-12-13T04:41:40.422Z","comments":true,"path":"2020/10/21/NoSQL概述/","link":"","permalink":"http://i.codingce.com.cn/2020/10/21/NoSQL%E6%A6%82%E8%BF%B0/","excerpt":"","text":"NoSQL概述 为什么要使用Nosql 我们现在处理什么年代 2020年 大数据时代 压力一定会越来越大， 适者生存， 一定要逼着自己学习， 才是在这个社会生存的唯一法则。 1.单机MySQL的年代 90年代, 一个基本网站访问量一般不会太大, 单个数据库完全足够！ 那个时候更多的使用静态网页 HTML 服务器根本没有压力 思考下：整个网站的瓶颈是什么？ 数据量太大, 一个机器放不下 数据索引 （300万条数据就一定建立索引! B+树), 一个机器内存也放不下 访问量(读写混合), 一台服务器承受不了 只要你开始出现以上三种情况之一， 那么就必须晋级！ 2.Memcached（缓存） + MySQL + 垂直拆分 网站80%的情况都是在读数据, 每次都要查询数据就很麻烦， 所以说我们希望减轻数据压力, 我们可以使用缓存来保证效率! 发展过程：优化数据结构–&gt;文件缓存(IO)–&gt;Memcached（缓存 当时最热门的技术！） 3.分库分表+水平拆分+MySQL集群 技术和业务发展的同时, 对人的要求也越来越高 本质:数据库(读 写) 早些年MyISAM:表锁, 十分影响效率!高并发下就会出现严重的问题, 转到Innodb：行锁 慢慢的就开始使用分库分表来解决写的压力! MySQL在那个年代推出了表分区 这个并没有多少公司使用 MySQL集群 4.如今年代 技术爆炸 2010-2020 十年之间, 世界发生翻天覆地的变化 MySQl关系型数据库就不够用了, 数量巨多, 变化很快 MySQL有的使用它来存储一些比较大的文件, 博客 图片 数据库表很大, 效率就低了！ 如果有一种数据库专门来处理这种数据 MySQL的压力就会十分小(研究如何处理这些问题) 大数据IO压力下, 表几乎没办法更大！ 5.目前一个基本互联网项目！ 6.为什么要用NoSQL 用户的个人信息, 社交网络, 地理位置. 用户自己产生的数据, 用户日志等等爆发式的增长 这时候我们就应该使用NoSQL数据库, NoSQL可以很好的处理以上的情况. 什么是NoSQL NoSQL NoSQL = Not Only SQL(不仅仅是SQL) 泛指非关系型数据库，随着 Web2.0 互联网的诞生， 传统关系型数据库很难对付web2.0时代！ 尤其是超大规模的高并发的社区 暴露出很多难以克服的问题, NoSQL在当今大数据环境下发展的十分迅速，Redis是发展最快的，而且当下必须掌握一个技术 很多数据类型用户的个人信息，社交网络，地理位置。这些数据类型的存储要有一个固定的格式！ 不需要多余的格式就可以横向扩展的！ Map&lt;String, Object&gt; 使用键值对 NoSQL特点 解耦 方便拓展(数据之间没有关系, 很好扩展) 大数据量 高性能(Redis一秒些8万次 读取11万 NoSQL的缓存记录， 是一种细粒度的缓存, 性能会比较高) 数据类型是多样的!(不需要事先设计数据库! 随取随用 如果是十分大的表, 很多人就无法设计了) 传统的RDBMS和NoSQL 传统的RDBMS：结构化组织、SQL、数据和关系都存在单独的表中row col、操作数据、数据定义语言、严格的一致性、基础事务… NoSQL: 不仅仅是数据、没有固定的查询语言、键值对存储、列存储、文档存储（社交关系）、最终一致性、CAP原理 和 BASE （异地多活）、高性能、高可用、高可扩、… 了解3V + 3高 大数据时代的3V：主要描述问题 海量Volume 多样Variety 实时Velocity 大数据时代的3高：主要是对程序的要求 高并发 高可扩（随时水平拆分，机器不够用了，可以扩展机器） 高性能（保证我们的用户体验） 真正在公司中的实践：NoSQL + RDBMS 一起使用才是最强大的, 阿里巴巴的架构引进. 阿里巴巴演进分析 思考问题 这么多的数据难道都是在一个数据库中的么? 敏捷开发、极限编程 开源才是技术的王道 任何一家互联网公司，都不可能简简单单让用户能用就好了 大量公司做的都是相同的业务;(竞品协议) 如果未来相当一个架构师：没有什么是加一层解决不了的！ 商品的基本信息 名称 价格 商家信息 关系型数据库就能就解决 MySQL/oracle (淘宝早就去IOE了 王坚：推荐文章 ： 阿里云的这群疯子) 淘宝内部的MySQL 不是大家用的MySQL 商品描述 评论（文字比较多） 文档型数据库中 MongDB 图片 分布式文件存储系统 FastDFS - 淘宝自己的 TFS - Google GFS - Hadoop HDFS - 阿里云的 oss 商品关键字（搜索） - 搜索引擎：solr elasticsearch - ISerach： 多隆（多关注技术大佬） 商品热门的波段信息 - 内存数据库‘ - Reids Tair Memache 商品的交易 外部的支付接口 - 第三方应用 要知道， 一个简单的网页背后的技术一定不是大家所想象的那么简单 大型互联网应用问题 数据类型太多了 数据源多， 经常重构（敏捷开发）！ 数据要改造, 大面积改造 解决问题： NoSQL的四大分类 KV键值对 新浪：Redis 美团：Redis + Tair 阿里、百度：Redis + memecache 文档型数据库(bson格式 和json一样) MongoDB(一般必须要掌握) MongoDB是一个基于分布式文件存储的数据库, C++编写, 主要用来处理大量的文档 MongoDB是一个介于关系型数据库和非关系型数据库中中间产品 MongoDB是非关系型数据库中功能最丰富, 最像关系型数据库. ConthDB 列存储 HBase 分布式文件系统 图关系数据库 他不是存储图形, 放的是关系, 比如：朋友圈社交网络 广告推荐 Neo4j InfoGrid 四者对比 Web1.0：以静态、单向阅读为主，网站内信息可以直接和其他网站信息进行交互，能通过第三方信息平台同时对多家网站信息进行整合使用。 Web2.0：以分享为特征的实时网络，用户在互联网上拥有自己的数据，并能在不同的网站上使用。 Web3.0：将以网络化和个性化为特征，提供更多人工智能服务，完全基于Web，用浏览器即可实现复杂的系统程序才具有的功能。 Web3.0的特征分析： 1、微内容(Widget)的自由整合与有效聚合 2、适合多种终端平台，实现信息服务的普适性 3、良好的人性化用户体验，以及基础性的个性化配置 4、有效和有序的数字新技术","categories":[{"name":"Redis","slug":"Redis","permalink":"http://i.codingce.com.cn/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://i.codingce.com.cn/tags/Redis/"}]},{"title":"二维数组中的查找","slug":"二维数组中的查找","date":"2020-10-10T00:09:53.000Z","updated":"2020-12-13T04:41:40.438Z","comments":true,"path":"2020/10/10/二维数组中的查找/","link":"","permalink":"http://i.codingce.com.cn/2020/10/10/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/","excerpt":"","text":"时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 32M，其他语言64M 热度指数：1946753 本题知识点： 查找 数组 来源：牛客网 题目描述 在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 C++ 123456789101112131415161718192021static const auto io_sync_off=[]()&#123; ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); return nullptr;&#125;();class Solution &#123;public: bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) &#123; int row=array.size(); int col=array[0].size(); if(!row||!col) return false; int i=row-1,j=0; while(i&gt;=0&amp;&amp;j&lt;col)&#123; if(array[i][j]&gt;target) i--; else if(array[i][j]&lt;target) j++; else return true; &#125; return false; &#125;&#125;; Java 123456789101112public class Solution &#123; public boolean Find(int target, int [][] array) &#123; for(int i=0;i&lt;array.length;i++)&#123; for(int j=0;j&lt;array[0].length;j++)&#123; if(array[i][j] == target)&#123; return true; &#125; &#125; &#125; return false; &#125;&#125;","categories":[],"tags":[]},{"title":"MyBatis-Plus","slug":"MyBatisPlus","date":"2020-10-05T02:15:23.000Z","updated":"2020-12-13T04:41:40.422Z","comments":true,"path":"2020/10/05/MyBatisPlus/","link":"","permalink":"http://i.codingce.com.cn/2020/10/05/MyBatisPlus/","excerpt":"","text":"MyBatis-Plus 是什么？ https://baomidou.com/#/ Mybatis-Plus（简称MP）是一个 Mybatis 的增强工具，在 Mybatis 的基础上只做增强不做改变，为简化开发、提高效率而生。这是官方给的定义，关于mybatis-plus的更多介绍及特性，可以参考mybatis-plus官网。那么它是怎么增强的呢？其实就是它已经封装好了一些crud方法，我们不需要再写xml了，直接调用这些方法就行，就类似于JPA。 特性 无侵入 ：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑 损耗小 ：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作, BaseMapper 强大的 CRUD 操作 ：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求, 以后的简单的增删改查, 它不用自己写了! 支持 Lambda 形式调用 ：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错 支持主键自动生成 ：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题 支持 ActiveRecord 模式 ：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作 支持自定义全局通用操作 ：支持全局通用方法注入（ Write once, use anywhere ） 内置代码生成器 ：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用,可插拔的方式（自动帮你生成代码） 内置分页插件 ：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询 分页插件支持多种数据库 ：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库 内置性能分析插件 ：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询 内置全局拦截插件 ：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作 快速入门 地址: https://baomidou.com/guide/quick-start.html 使用第三方组件 导入对应依赖 研究如何让编写配置 代码如何编写 提高拓展 步骤 创建数据库 mybatis_plus 创建 user表 123456789101112DROP TABLE IF EXISTS user;CREATE TABLE user( id BIGINT(20) NOT NULL COMMENT '主键ID', name VARCHAR(30) NULL DEFAULT NULL COMMENT '姓名', age INT(11) NULL DEFAULT NULL COMMENT '年龄', email VARCHAR(50) NULL DEFAULT NULL COMMENT '邮箱', PRIMARY KEY (id));真实开发过程中, version（乐观锁）、delete（逻辑删除）、gmt_create、gm_modified 其对应的数据库 Data 脚本如下： 12345678DELETE FROM user;INSERT INTO user (id, name, age, email) VALUES(1, 'Jone', 18, 'test1@baomidou.com'),(2, 'Jack', 20, 'test2@baomidou.com'),(3, 'Tom', 28, 'test3@baomidou.com'),(4, 'Sandy', 21, 'test4@baomidou.com'),(5, 'Billie', 24, 'test5@baomidou.com'); 创建SpringBoot项目 mybatis_plus 导入依赖 123456789101112131415161718&lt;!--数据库驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--lombok--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--mybatis-plus-boot-starter是自己开发的, 并非官方--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.5&lt;/version&gt; &lt;/dependency&gt; 说明: 我们使用mybatis-plus可以节省我们大量代码, 尽量不要导入mybtis和mybatis-plus! 版本差异 连接数据库 12345spring.datasource.username=rootspring.datasource.data-password=123456spring.datasource.url=jdbc:mysql://cdb-q9atzwrq.bj.tencentcdb.com:10167/mybatis_plus?useSSL=false&amp;amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=GMT%2B8spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver# serverTimezone=GMT 时区 8.0以上版本需要添加否则会报错 传统项目结构对比使用mybatis-plus之后 pojo-dao(连接mybatis, 配置mapper.xml文件)service-controller 使用mybatis-plus之后 pojo mapper接口 12345678910111213141516package cn.com.codingce.mapper;import cn.com.codingce.pojo.User;import com.baomidou.mybatisplus.core.mapper.BaseMapper;import org.apache.ibatis.annotations.Mapper;import org.springframework.stereotype.Repository;/** * 在对应的Mapper上实现基本接口BaseMapper * @author xzMa */@Mapper@Repositorypublic interface UserMapper extends BaseMapper&lt;User&gt; &#123; //所有的CRUD操作都已经编写完成&#125; 使用 123456789101112131415161718192021222324252627package cn.com.codingce;import cn.com.codingce.mapper.UserMapper;import cn.com.codingce.pojo.User;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import java.util.List;@SpringBootTestclass MybatisPlusApplicationTests &#123; @Autowired private UserMapper userMapper; /* wrapper条件构造器, 这里我们先不用 null //查询全部用户 */ @Test void contextLoads() &#123; List&lt;User&gt; users = userMapper.selectList(null); users.forEach(System.out::println); &#125;&#125; 思考问题 SQL谁帮我们写好了? MyBatis-Plus都写好了 方法哪里来? MyBatis-Plus都写好了 配置日志 我们所有的SQL是不可见的, 我们希望知道它是怎么执行的, 所以我们必须要看日志 (真正上线, 在下) 12# 配置日志mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl CRUD拓展 Insert 12345678@Testvoid testInsert() &#123; User user = new User(); user.setName(\"掌上编程\"); user.setAge(19); user.setEmail(\"2460798168@qq.com\"); userMapper.insert(user);&#125; 数据库插入的id的默认值为：全局的唯一id 主键的策略 分布式系统唯一id生成： 123默认 @TableId(type = IdType.ID_WORKER) private Long id; 雪花算法：snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。具体实现的代码可以参看https://github.com/twitter/snowflake。 主键自增 我们需要配置主键自增 实体类字段上 @TableId(type = IdType.AUTO) 数据库字段一定要自增! 再次测试插入即可 其他源码检测 123456789101112131415161718public enum IdType &#123; AUTO(0), //数据库id自增 NONE(1), //未设置主键 INPUT(2), //手动输入 ID_WORKER(3),//默认的全局id UUID(4), //全局唯一id uuid ID_WORKER_STR(5); //ID_WORKER 字符串表示法 private int key; private IdType(int key) &#123; this.key = key; &#125; public int getKey() &#123; return this.key; &#125;&#125; 更新操作 123456789@Testvoid testUpdate() &#123; User user = new User(); //通过条件自动拼接动态sql user.setId(1L); user.setEmail(\"21211@qq.com\"); int i = userMapper.updateById(user); System.out.println(i);&#125; 自动填充 创建时间、更改时间! 这些操作一遍都是自动化完成的, 我们不希望手动更新！ 阿里巴巴开发手册：所有的数据表:gm_create、 gmt_modified 几乎所有的表都需要配置上！而且需要自动化! 方式一 数据库级别 在表中新增字段create_time、 update_time 123456789101112131415161718192021222324252627package cn.com.codingce.pojo;import com.baomidou.mybatisplus.annotation.IdType;import com.baomidou.mybatisplus.annotation.TableId;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import java.util.Date;/** * @author xzMa */@Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123; @TableId(type = IdType.AUTO) private Long id; private String name; private Integer age; private String email; private Date createTime; private Date updateTime;&#125; 方式二：代码级别 数据库的时间默认值去掉 直接在实体类中 1234567891011121314151617181920212223242526272829303132package cn.com.codingce.pojo;import com.baomidou.mybatisplus.annotation.FieldFill;import com.baomidou.mybatisplus.annotation.IdType;import com.baomidou.mybatisplus.annotation.TableField;import com.baomidou.mybatisplus.annotation.TableId;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import java.util.Date;/** * @author xzMa */@Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123; @TableId(type = IdType.AUTO) private Long id; private String name; private Integer age; private String email; @TableField(fill = FieldFill.INSERT) private Date createTime; @TableField(fill = FieldFill.INSERT_UPDATE) private Date updateTime;&#125; MyMetaObjectHandler 1234567891011121314151617181920212223242526272829303132package cn.com.codingce.handler;import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;import lombok.extern.slf4j.Slf4j;import org.apache.ibatis.reflection.MetaObject;import org.springframework.stereotype.Component;import java.util.Date;/** * 自己写的处理器 * @author xzMa */@Slf4j@Component //一定不要把我们的处理器加到IOC中public class MyMetaObjectHandler implements MetaObjectHandler &#123; //插入时的填充策略 @Override public void insertFill(MetaObject metaObject) &#123; log.info(\"Start insert fill ...\"); //String fieldName, Object fieldVal, MetaObject metaObject this.setFieldValByName(\"createTime\", new Date(), metaObject); this.setFieldValByName(\"updateTime\", new Date(), metaObject); &#125; //更新时的填充策略 @Override public void updateFill(MetaObject metaObject) &#123; log.info(\"Start update fill ...\"); this.setFieldValByName(\"updateTime\", new Date(), metaObject); &#125;&#125; 乐观锁 在面试过程中, 我们经常会被问到的乐观锁, 悲观锁! 这个其实非常简单! 乐观锁：乐观锁（ Optimistic Locking ） 相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。 故名思意十分乐观, 它总是认为不会出现问题, 无论干什么都不去上锁! 如果出现问题, 再次更新新值测试(version new version) 悲观锁:故名思意十分悲观, 它总认为总是出现问题, 无论干什么都会上锁! 再去操作! 乐观锁机制: 取出记录记录, 获取当前version 更新时, 带上这个version 执行更新时, set version = new Version where version = oldVersion 如果version不对, 就更新失败 1234567---Aupdate user set name = \"zhangshangbiancheng\", version = version + 1where id = 2 and version = 1---B 线程抢先完成, 这个时候 version = 2 会导致A修改失败!update user set name = \"zhangshangbiancheng\", version = version + 1where id = 2 and version = 1 测试MP乐观锁插件 给数据库中添加version字段 我们对实体类添加对应的字段 12@Version //乐观锁Version注解private Integer version; 注册组件 1234567891011121314151617181920package cn.com.codingce.config;import com.baomidou.mybatisplus.extension.plugins.OptimisticLockerInterceptor;import org.mybatis.spring.annotation.MapperScan;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.transaction.annotation.EnableTransactionManagement;@EnableTransactionManagement //扫描我们的mapper文件夹@MapperScan(\"cn.com.codingce.mapper\")@Configuration //配置类public class MyBatisPlusConfig &#123; //注册乐观锁插件 @Bean public OptimisticLockerInterceptor optimisticLockerInterceptor() &#123; return new OptimisticLockerInterceptor(); &#125;&#125; 测试 123456789101112131415161718192021222324252627282930@Testvoid testOptimisticLocker() &#123; //查询用户信息 User user = userMapper.selectById(1L); //修改用户信息 user.setName(\"xzMhehe\"); user.setEmail(\"codingce@ce.com\"); //执行更新操作 userMapper.updateById(user);&#125;/** * 测试乐观锁失败 多线程下 */@Testvoid testOptimisticLocker2() &#123; //线程1 User user = userMapper.selectById(1L); user.setName(\"xzMhehe111\"); user.setEmail(\"codingce@ce.com\"); //模拟另外一个线程执行了插队操作 User user2 = userMapper.selectById(1L); user2.setName(\"xzMhehe222\"); user2.setEmail(\"codingce@ce.com\"); userMapper.updateById(user2); //自旋锁来多次尝试提交 userMapper.updateById(user); //如果没有乐观锁就会覆盖插队线程的值！&#125; 查询操作 1234567891011121314151617181920212223@Testpublic void select() &#123; User user = userMapper.selectById(1L); System.out.println(user);&#125;@Testpublic void selectBatchIds() &#123; List&lt;User&gt; users = userMapper.selectBatchIds(Arrays.asList(1L, 2L, 3L)); users.forEach(System.out::println);&#125;//条件查询 map@Testpublic void testSelectByBathIds() &#123; HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); //自定义要查询 map.put(\"name\", \"xzMhehe222\"); map.put(\"age\", 12); List&lt;User&gt; userList = userMapper.selectByMap(map); userList.forEach(System.out::println);&#125; 分页查询 分页在网站使用的十分之多 原始的limit进行分页 pageHelper第三方插件 MP其实也内置了分页插件 如何使用 配置拦截器组件 12345678910//Spring boot方式@Configuration@MapperScan(\"com.baomidou.cloud.service.*.mapper*\")public class MybatisPlusConfig &#123; @Bean public PaginationInterceptor paginationInterceptor() &#123; return new PaginationInterceptor(); &#125;&#125; 直接使用Page插件即可 123456789101112/** * 测试分页 */@Testpublic void testPage() &#123; //current参数一：当前页 //参数二：页面大小 Page&lt;User&gt; page = new Page&lt;&gt;(1, 5); IPage&lt;User&gt; userIPage = userMapper.selectPage(page, null); page.getRecords().forEach(System.out::println);&#125; 基本删除操作 1234567891011121314151617181920//真删@Testpublic void testDelete() &#123; userMapper.deleteById(1L);&#125;//批量删除@Testpublic void testDeleteBatchId() &#123; userMapper.deleteBatchIds(Arrays.asList(1L, 2L, 3L));&#125;//通过map删除@Testpublic void testDeleteMap() &#123; HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"name\", \"xzMhehe\"); userMapper.deleteByMap(map);&#125; 我们在工作中会遇到一些问题：逻辑删除 逻辑删除 物理删除：从数据库中直接删除 逻辑删除：在数据库中没有移除，而是通过一个变量让他失效！ deleted = 0 =&gt;deleted = 1 管理员可以查看删除记录！防止数据丢失，类似于回收站 在数据库中添加deleted字段 在实体类中添加属性 12@TableField //逻辑删除private Integer deleted; 配置 12345//逻辑删除组件@Beanpublic ISqlInjector sqlInjector() &#123; return new LogicSqlInjector();&#125; 12mybatis-plus.global-config.db-config.logic-delete-value=1mybatis-plus.global-config.db-config.logic-not-delete-value=0 性能分析插件 在平时开发中, 会遇到一些慢sql. 测试！druid MP也提供性能分析插件, 如果超过这个时间停止运行！ 导入插件 123456789@Bean@Profile(&#123;\"dev\", \"test\"&#125;) //设置 dev text 环境开启, 保障我们的效率public PerformanceInterceptor performanceInterceptor() &#123; PerformanceInterceptor performanceInterceptor = new PerformanceInterceptor(); // 在工作中, 不允许用户等待 performanceInterceptor.setMaxTime(500); //ms 设置sql执行的最大时间, 如果超过了则不执行 performanceInterceptor.setFormat(true); //开启格式化输出 return performanceInterceptor;&#125; 测试使用 条件构造器 十分重要 Wrapper 测试1 123456789@Testvoid contextLoads() &#123; //查询条件name和邮箱不为空的用户, 年龄大于等于12的用户 QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.isNotNull(\"name\") .isNotNull(\"email\") .ge(\"age\", 12); userMapper.selectList(wrapper).forEach(System.out::println); //对比Map&#125; 测试2 1234567@Test public void Test() &#123; //查询名字 全栈自学社区 QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.eq(\"name\", \"全栈自学社区\"); userMapper.selectList(wrapper).forEach(System.out::println); &#125; 12345678910111213141516171819202122232425262728293031323334353637@Testpublic void Test3() &#123; //年龄在20~30岁之间的人 QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.between(\"age\", 20, 30); Integer count = userMapper.selectCount(wrapper); System.out.println(count); userMapper.selectList(wrapper).forEach(System.out::println);&#125;@Testpublic void Test4() &#123; //名字中不包含 QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.notLike(\"name\", \"e\") .likeRight(\"email\", \"t\"); //左和右 %t% likeRight(\"email\", \"t\") t% List&lt;Map&lt;String, Object&gt;&gt; maps = userMapper.selectMaps(wrapper); maps.forEach(System.out::println);&#125;@Testpublic void Test5() &#123; //id在子查询查出来 QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.inSql(\"id\", \"select id from user where id &lt; 3\"); List&lt;Map&lt;String, Object&gt;&gt; maps = userMapper.selectMaps(wrapper); maps.forEach(System.out::println);&#125;@Testpublic void Test6() &#123; //排序 QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.orderByDesc(\"id\"); List&lt;Map&lt;String, Object&gt;&gt; maps = userMapper.selectMaps(wrapper); maps.forEach(System.out::println);&#125; 代码自动生成器 dao pojo service controller 都是自动生成 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package cn.com.codingce.generator;import com.baomidou.mybatisplus.annotation.DbType;import com.baomidou.mybatisplus.annotation.FieldFill;import com.baomidou.mybatisplus.annotation.IdType;import com.baomidou.mybatisplus.generator.AutoGenerator;import com.baomidou.mybatisplus.generator.config.DataSourceConfig;import com.baomidou.mybatisplus.generator.config.GlobalConfig;import com.baomidou.mybatisplus.generator.config.PackageConfig;import com.baomidou.mybatisplus.generator.config.StrategyConfig;import com.baomidou.mybatisplus.generator.config.po.TableFill;import com.baomidou.mybatisplus.generator.config.rules.DateType;import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;import java.util.ArrayList;public class CodeGenerator &#123; public static void main(String[] args) &#123; // 1、创建代码生成器 AutoGenerator mpg = new AutoGenerator(); // 2、全局配置 GlobalConfig gc = new GlobalConfig(); //当前的项目路径 String projectPath = System.getProperty(\"user.dir\"); //所有代码都会生成到 /src/main/java 路径下 gc.setOutputDir(projectPath + \"/src/main/java\"); gc.setAuthor(\"小马Coding\"); gc.setOpen(false); //生成后是否打开资源管理器 gc.setFileOverride(false); //重新生成时文件是否覆盖 gc.setServiceName(\"%sService\"); //去掉Service接口的首字母I gc.setIdType(IdType.ID_WORKER_STR); //主键策略 gc.setDateType(DateType.ONLY_DATE);//定义生成的实体类中日期类型 gc.setSwagger2(true);//开启Swagger2模式 mpg.setGlobalConfig(gc); // 3、数据源配置 DataSourceConfig dsc = new DataSourceConfig(); dsc.setUrl(\"jdbc:mysql://cdb-q9atzwrq.bj.tencentcdb.com:10167/codingstudy?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false\"); dsc.setDriverName(\"com.mysql.jdbc.Driver\"); dsc.setUsername(\"root\"); dsc.setPassword(\"123456\"); dsc.setDbType(DbType.MYSQL); mpg.setDataSource(dsc); // 4、包配置 PackageConfig pc = new PackageConfig(); pc.setModuleName(\"blog\"); pc.setParent(\"cn.com.codingce\"); pc.setController(\"controller\"); pc.setEntity(\"pojo\"); pc.setService(\"service\"); pc.setMapper(\"mapper\"); mpg.setPackageInfo(pc); // 5、策略配置 StrategyConfig strategy = new StrategyConfig(); //strategy.setInclude(\"ze_user\");//设置要映射的表名 //strategy.setInclude(\"ze_user\", \"ze_course\");//可设置多个 strategy.setInclude(\"ze_user\");//设置要映射的表名 strategy.setNaming(NamingStrategy.underline_to_camel);//数据库表映射到实体的命名策略 strategy.setTablePrefix(\"ze_\");//设置表前缀不生成 strategy.setColumnNaming(NamingStrategy.underline_to_camel);//数据库表字段映射到实体的命名策略 strategy.setEntityLombokModel(true); // lombok 模型 @Accessors(chain = true) setter链式操作 strategy.setRestControllerStyle(true); //restful api风格控制器 strategy.setControllerMappingHyphenStyle(true); //url中驼峰转连字符 //strategy.setLogicDeleteFieldName(\"deleted\"); //逻辑删除字段 //自动填充配置 //TableFill gmtCreate = new TableFill(\"gmt_create\", FieldFill.INSERT); //TableFill gmtModified = new TableFill(\"gmt_modified\", FieldFill.INSERT_UPDATE); //ArrayList&lt;TableFill&gt; tableFills = new ArrayList&lt;&gt;(); //tableFills.add(gmtCreate); //tableFills.add(gmtModified); //strategy.setTableFillList(tableFills); mpg.setStrategy(strategy); // 6、执行 mpg.execute(); &#125;&#125;","categories":[],"tags":[]},{"title":"分析开源项目","slug":"分析开源项目","date":"2020-09-27T09:35:51.000Z","updated":"2020-12-13T04:41:40.438Z","comments":true,"path":"2020/09/27/分析开源项目/","link":"","permalink":"http://i.codingce.com.cn/2020/09/27/%E5%88%86%E6%9E%90%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"解压项目 先不要着急运行 观察 运用了哪些技术(SpringBoot、Vue、Redi、MQ…) 是否有数据库(mysql) 你的环境是否匹配(Maven、 Java、npm、nodes.js、redis…) 通过了, 然后再想办法运行 跑起来是第一步 安装数据库, 执行SQL 前端需要跑起来 后端项目导入跑起来 启动后端项目 只要发现了Swagger, 那么跑起来第一步就是先进入Swagger-ui界面！ 因为这里面都是接口！ 前后端分离项目固定套路 从前端开始分析. 打开控制台, 点一个接口, 分析一波调用关系 前后端接口调用不一致 8013 — 8000 , 怎么操作 封装了接口请求: ajax axios request 找到配置 前后端分离项目重点, 找到调用关系 前端项目固定套路 Controler-Service-Dao 如何渲染的呢? Vue标准套路: 1234567891011121314&lt;template&gt;视图层&lt;&#x2F;template&gt;&lt;script&gt;js操作export default &#123;&#125;&lt;&#x2F;script&gt;&lt;style&gt;页面的样式&lt;&#x2F;style&gt;","categories":[{"name":"随记","slug":"随记","permalink":"http://i.codingce.com.cn/categories/%E9%9A%8F%E8%AE%B0/"}],"tags":[{"name":"随记","slug":"随记","permalink":"http://i.codingce.com.cn/tags/%E9%9A%8F%E8%AE%B0/"}]},{"title":"SpringCloud Config 分布式配置","slug":"SpringCloud-Config-分布式配置","date":"2020-09-27T05:36:26.000Z","updated":"2020-12-13T04:41:40.422Z","comments":true,"path":"2020/09/27/SpringCloud-Config-分布式配置/","link":"","permalink":"http://i.codingce.com.cn/2020/09/27/SpringCloud-Config-%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE/","excerpt":"","text":"配置文件与代码解耦 简介 在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件。市面上开源的配置中心有很多，BAT每家都出过，360的QConf、淘宝的diamond、百度的disconf都是解决这类问题。国外也有很多开源的配置中心Apache的Apache Commons Configuration、owner、cfg4j等等。在Spring Cloud中，有分布式配置中心组件spring cloud config ，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程Git仓库中。在spring cloud config 组件中，分两个角色，一是config server，二是config client。 一个配置中心提供的核心功能 提供服务端和客户端支持 集中管理各环境的配置文件 配置文件修改之后，可以快速的生效 可以进行版本管理 支持大的并发查询 支持各种语言 Spring Cloud Config可以完美的支持以上所有的需求。 Spring Cloud Config项目是一个解决分布式系统的配置管理方案。它包含了Client和Server两个部分，server提供配置文件的存储、以接口的形式将配置文件的内容提供出去，client通过接口获取数据、并依据此数据初始化自己的应用。Spring cloud使用git或svn存放配置文件，默认情况下使用git，我们先以git为例做一套示例。 实现 服务端 项目截图 pom 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;springcloud&lt;/artifactId&gt; &lt;groupId&gt;cn.com.codingce&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;springcloud-config-server-3344&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-config-server --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt; &lt;version&gt;2.1.1.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring-boot-starter-web--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--actuator完善监控信息--&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-actuator --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--eureka--&gt;&lt;!-- &lt;dependency&gt;--&gt;&lt;!-- &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;--&gt;&lt;!-- &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;--&gt;&lt;!-- &lt;version&gt;1.4.6.RELEASE&lt;/version&gt;--&gt;&lt;!-- &lt;/dependency&gt;--&gt; &lt;/dependencies&gt;&lt;/project&gt; gitee创建仓库 application 12345678910111213141516# 开发步骤 导入配置, 编写依赖server: port: 3344spring: application: name: springcloud-config-server # 连接远程仓库 cloud: config: server: git: uri: https://gitee.com/codingce/springcloud-config.git # 是https的, 不是git# 通过config-server 可以连接到git 访问其中的资源以及配置 http://localhost:3344/application-dev.yml http://localhost:3344/application/dev/master# config-server服务端 gitee地址：https://gitee.com/codingce/springcloud-config.git 启动项Config_Server_3344 12345678910111213package cn.com.codingce.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.config.server.EnableConfigServer;@SpringBootApplication@EnableConfigServer 开启注解public class Config_Server_3344 &#123; public static void main(String[] args) &#123; SpringApplication.run(Config_Server_3344.class, args); &#125;&#125; 客户端 pom 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;springcloud&lt;/artifactId&gt; &lt;groupId&gt;cn.com.codingce&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;springcloud-config-client-3355&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!--spring-boot-starter-web--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--actuator完善监控信息--&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-actuator --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-config --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;version&gt;2.1.1.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; application.yml 1234# 用户级别的配置spring: application: name: springcloud-config-client-3355 bootstrap.yml 12345678# 项目系统级别的配置spring: cloud: config: uri: http://localhost:3344 # 注意： 必须先启动 3344项目 本地项目 导包 spring-cloud-starter-eureka-server 不然会走 8080 name: config-client # 需要从git上读取的资源名称, 不需要后缀 profile: test label: master ConfigClientController 1234567891011121314151617181920212223242526package cn.com.codingce.springcloud.controller;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class ConfigClientController &#123; @Value(\"$&#123;spring.application.name&#125;\") private String applicationName; @Value(\"$&#123;eureka.client.service-url.defaultZone&#125;\") private String eurekaServer; @Value(\"$&#123;server.port&#125;\") private String port; @RequestMapping() public String getConfig() &#123; return \"applicationName:\" + applicationName + \"eurekaServer\" + eurekaServer + \"port\" + port; &#125;&#125; 项目地址: https://github.com/xzMhehe/codingce-java","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://i.codingce.com.cn/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://i.codingce.com.cn/tags/SpringCloud/"}]},{"title":"Zuul路由网关","slug":"Zuul路由网关","date":"2020-09-25T00:39:07.000Z","updated":"2020-12-13T04:41:40.438Z","comments":true,"path":"2020/09/25/Zuul路由网关/","link":"","permalink":"http://i.codingce.com.cn/2020/09/25/Zuul%E8%B7%AF%E7%94%B1%E7%BD%91%E5%85%B3/","excerpt":"","text":"zuul是什么 zuul 是netflix开源的一个API Gateway 服务器, 本质上是一个web servlet应用。 Zuul 在云平台上提供动态路由，监控，弹性，安全等边缘服务的框架。Zuul 相当于是设备和 Netflix 流应用的 Web 网站后端所有请求的前门。 zuul的例子可以参考 netflix 在github上的 simple webapp，可以按照netflix 在github wiki 上文档说明来进行使用。 https://github.com/Netflix/zuul/wiki 注意: Zuul服务最终还是会注册到Eureka 提供: 代理 + 路由 + 过滤 三大功能! zuul的核心是一系列的filters, 其作用类比Servlet框架的Filter，或者AOP。zuul把请求路由到用户处理逻辑的过程中，这些filter参与一些过滤处理，比如Authentication，Load Shedding等 zuul 能做什么 Zuul可以通过加载动态过滤机制，从而实现以下各项功能(路由、过滤)： 验证与安全保障: 识别面向各类资源的验证要求并拒绝那些与要求不符的请求。 审查与监控: 在边缘位置追踪有意义数据及统计结果，从而为我们带来准确的生产状态结论。 动态路由: 以动态方式根据需要将请求路由至不同后端集群处。 压力测试: 逐渐增加指向集群的负载流量，从而计算性能水平。 负载分配: 为每一种负载类型分配对应容量，并弃用超出限定值的请求。 静态响应处理: 在边缘位置直接建立部分响应，从而避免其流入内部集群。 多区域弹性: 跨越AWS区域进行请求路由，旨在实现ELB使用多样化并保证边缘位置与使用者尽可能接近。 过滤器的生命周期 zuul组件 zuul-core–zuul核心库，包含编译和执行过滤器的核心功能。 zuul-simple-webapp–zuul Web应用程序示例，展示了如何使用zuul-core构建应用程序。 zuul-netflix–lib包，将其他NetflixOSS组件添加到Zuul中，例如使用功能区进去路由请求处理。 zuul-netflix-webapp–webapp，它将zuul-core和zuul-netflix封装成一个简易的webapp工程包。 搭建一个注册Eureka中心的Web服务 项目截图 pom 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;springcloud&lt;/artifactId&gt; &lt;groupId&gt;cn.com.codingce&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;springcloud-zuul-9527&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!--Zuul--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--Hystrix依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--Hystrix监控--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix-dashboard&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--我们需要拿到实体类, 所以要配置api -module--&gt; &lt;dependency&gt; &lt;groupId&gt;cn.com.codingce&lt;/groupId&gt; &lt;artifactId&gt;springcloud-api&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;!--热部署工具--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--Ribbon--&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-ribbon --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--Eureka 客户端--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; application.yml配置 12345678910111213141516171819202122232425262728server: port: 9527spring: application: name: springcloud-zuuleureka: client: service-url: defaultZone: http://eureka7002.com:7002/eureka/, http://eureka7003.com:7003/eureka/, http://eureka7001.com:7001/eureka/ # 这里必须与服务端一致 instance: instance-id: zuul9527.com prefer-ip-address: true# info 配置info: app.name: codingce-springcloud cpmany.name: i.codingce.com.cn author: xzMhehe# 路由网关配置 我们需要设置原路径不能访问, 仅可使用Zuul路由网关配置的 路径 (已在 win10 hosts 里面配置 127.0.0.1 www.codingce.com)zuul: routes: mydept.serviceId: springcloud-provider-dept mydept.path: /mydept/** ignored-services: springcloud-provider-dept # 不能在使用这个路径访问了 ignored-services: \"*\" 隐藏全部的真实的项目 prefix: /mxz # 设置公共的前缀 可有可无 原 http://www.codingce.com:9527/mydept/dept/list 加了之后 http://www.codingce.com:9527/mxz/mydept/dept/list 启动项ZuulApplication_9527 12345678910111213package cn.com.codingce.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.zuul.EnableZuulProxy;@SpringBootApplication@EnableZuulProxy //一般用代理 @EnableZuulProxypublic class ZuulApplication_9527 &#123; public static void main(String[] args) &#123; SpringApplication.run(ZuulApplication_9527.class, args); &#125;&#125; 运行界面 服务端 Eureka界面 配置Zuul路由网关后 项目地址: https://github.com/xzMhehe/codingce-java","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://i.codingce.com.cn/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://i.codingce.com.cn/tags/SpringCloud/"}]},{"title":"互联网三高架构：高并发、高性能、高可用","slug":"互联网三高架构：高并发、高性能、高可用","date":"2020-09-13T10:26:09.000Z","updated":"2020-12-13T04:41:40.438Z","comments":true,"path":"2020/09/13/互联网三高架构：高并发、高性能、高可用/","link":"","permalink":"http://i.codingce.com.cn/2020/09/13/%E4%BA%92%E8%81%94%E7%BD%91%E4%B8%89%E9%AB%98%E6%9E%B6%E6%9E%84%EF%BC%9A%E9%AB%98%E5%B9%B6%E5%8F%91%E3%80%81%E9%AB%98%E6%80%A7%E8%83%BD%E3%80%81%E9%AB%98%E5%8F%AF%E7%94%A8/","excerpt":"","text":"面向互联网的三高系统，最关注的软件质量属性是：性能、可用性、伸缩性、扩展性、安全性。 而构建此类系统，最常见的架构模式有：横向分层、纵向分割、分布式化、集群化、使用缓存、使用异步模式、使用冗余、自动化（发布、部署、监控）。 具体来说，可以在不同层次常用的技术有： 前端架构 浏览器优化技术：合理布局，页面缓存，减少http请求数，页面压缩，减少 cookie 传输。 1）CDN CDN的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求。 2）DNS负载均衡 3）动静分离，静态资源独立部署，动态图片独立提供服务 应用层架构 1）业务拆分 2）负载均衡 3）虚拟化服务器、容器化 4）无状态（以及分布式 Session） 分布式Session有如下几种实现方式。 1.Session复制机制 在支持Session复制的Web服务器上，通过修改Web服务器的配置，可以实现将Session同步到其它Web服务器上，达到每个Web服务器上都保存一致的Session。 优点：代码上不需要做支持和修改。 缺点：需要依赖支持的Web服务器，一旦更换成不支持的Web服务器就不能使用了，在数据量很大的情况下不仅占用网络资源，而且会导致延迟。 适用场景：只适用于Web服务器比较少且Session数据量少的情况。 可用方案：开源方案tomcat-redis-session-manager，暂不支持Tomcat8。 2.Session粘滞机制 将用户的每次请求都通过某种方法强制分发到某一个Web服务器上，只要这个Web服务器上存储了对应Session数据，就可以实现会话跟踪。 优点：使用简单，没有额外开销。 缺点：一旦某个Web服务器重启或宕机，相对应的Session数据将会丢失，而且需要依赖负载均衡机制。 适用场景：对稳定性要求不是很高的业务情景。 3.Session集中管理机制 在单独的服务器或服务器集群上使用缓存技术，如Redis存储Session数据，集中管理所有的Session，所有的Web服务器都从这个存储介质中存取对应的Session，实现Session共享。 优点：可靠性高，减少Web服务器的资源开销。 缺点：实现上有些复杂，配置较多。 适用场景：Web服务器较多、要求高可用性的情况。 可用方案：开源方案Spring Session，也可以自己实现，主要是重写HttpServletRequestWrapper中的getSession方法，博主也动手写了一个，github搜索joincat用户，然后自取。 4.基于Cookie管理机制 这种方式每次发起请求的时候都需要将Session数据放到Cookie中传递给服务端。 优点：不需要依赖额外外部存储，不需要额外配置。 缺点：不安全，易被盗取或篡改；Cookie数量和长度有限制，需要消耗更多网络带宽。 适用场景：数据不重要、不敏感且数据量小的情况。 最后的总结 以上四种方式，相对来说，Session集中管理更加可靠，使用也是最多的。 5）分布式缓存 分布式缓存的典型应用场景可分为以下几类: 页面缓存.用来缓存Web 页面的内容片段,包括HTML、CSS 和图片等,多应用于社交网站等; 应用对象缓存.缓存系统作为ORM 框架的二级缓存对外提供服务,目的是减轻数据库的负载压力,加速应用访问; 状态缓存.缓存包括Session 会话状态及应用横向扩展时的状态数据等,这类数据一般是难以恢复的,对可用性要求较高,多应用于高可用集群; 并行处理.通常涉及大量中间计算结果需要共享; 事件处理.分布式缓存提供了针对事件流的连续查询(continuous query)处理技术,满足实时性需求; 极限事务处理.分布式缓存为事务型应用提供高吞吐率、低延时的解决方案,支持高并发事务请求处理,多应用于铁路、金融服务和电信等领域. 异步、事件驱动架构、消息队列 EDA是一种以事件为媒介，实现组件或服务之间最大松耦合的方式。传统面向接口编程是以接口为媒介，实现调用接口者和接口实现者之间的解耦，但是这种解耦程度不是很高，如果接口发生变化，双方代码都需要变动，而事件驱动则是调用者和被调用者互相不知道对方，两者只和中间消息队列耦合。 多线程 动态页面静态化 我们只需要编写这么一个HttpModule就可以了，当用户第一次请求asp处理时，我们可以在ihttpmodule中拦截到这个请求，然后获取到这次请求应该返回的html代码，然后我们返回这些html给用户，并保存刚才我们获取到的html到文件内，当用户下次请求时，我们只需要直接返回我们已经保存的html文件即可。 服务层架构 1）分布式微服务（分级管理，超时设置，异步调用，服务降级，幂等性设计。） 同应用层架构 存储层架构 1）DFS（分布式文件存储） 2）路由数据库 3）No SQL 数据库 4）数据同步 5）数据冗余 安全架构 1）Web攻击（XSS、Sql Injection） 2）数据加密 3）密钥管理 4）发布、运维 自动化测试与发布 1）灰度发布 2）浏览器数据采集 3）服务器业务数据采集 4）服务器性能数据采集 5）系统监控 6）系统报警 7）机房（散热、省电、定制服务器） 作者：pigness 链接：https://www.jianshu.com/p/fd8ff58ba5d2","categories":[],"tags":[{"name":"随记","slug":"随记","permalink":"http://i.codingce.com.cn/tags/%E9%9A%8F%E8%AE%B0/"}]},{"title":"hystrix","slug":"hystrix","date":"2020-09-13T06:50:42.000Z","updated":"2020-12-13T04:41:40.438Z","comments":true,"path":"2020/09/13/hystrix/","link":"","permalink":"http://i.codingce.com.cn/2020/09/13/hystrix/","excerpt":"","text":"hystrix[hɪst’rɪks] 分布式系统面临的问题 复杂分布式系统结构中的应用程序有数十个依赖关系, 每个依赖关系在某些时候将不可避免的失败 服务雪崩 多个服务之间调用的时候, 微服务A调用微服务B和微服务C, 微服务B和微服务C有调用其它的微服务, 这就是所谓的“扇出”, 如果扇出的链路上某个微服务的调用响应时间过长或者不可用, 对微服务A的调用就会占用越来越多的系统资源, 进而引起系统崩溃, 所谓的&quot;雪崩效应&quot; 对于高流量的应用来说, 单一的后端依赖可能会导致所有服务器上的资源都在几秒之内饱和. 比失败更糟糕的是, 这些程序还可能导致服务间的延迟增加, 备份队列, 线程和其系统资源紧张, 导致整个系统发生更多的级联故障, 这些都表示需要对故障和延迟进行隔离和管理, 以便单个依赖关系的失败, 不能取消整个应用程序或系统. 我们需要 ‘弃车保帅’ 什么是Hystrix 在分布式系统，我们一定会依赖各种服务，那么这些个服务一定会出现失败的情况，Hystrix就是这样的一个工具，它通过提供了逻辑上延时和错误容忍的解决力来协助我们完成分布式系统的交互。Hystrix 通过分离服务的调用点，阻止错误在各个系统的传播，并且提供了错误回调机制，这一系列的措施提高了系统的整体服务弹性。 官网原话 Netflix has created a library called Hystrix that implements the circuit breaker pattern. In a microservice architecture it is common to have multiple layers of service calls. &quot;断路器&quot;本身就是一种开关装置, 当某个服务单元发生故障后, 通过断路器的故障监控(类似熔断保险丝), 向调用方法返回一个服务预期的, 可处理的备选响应(FallBack), 而不是长时间等待或者调用方法无法处理的异常, 这样就可以保障了服务调用方法的线程不会被长时间 , 不必要的占用, 从而避免了故障在分布式系统中的蔓延, 乃至雪崩. Hystrix能干嘛 服务降级 服务熔断 服务限流 接近实时监控 … 在微服务架构中，我们将业务拆分成一个个的服务，服务与服务之间可以相互调用（RPC百科: RPC是远程过程调用（Remote Procedure Call）的缩写形式。）。为了保证其高可用，单个服务又必须集群部署。由于网络原因或者自身的原因，服务并不能保证服务的100%可用，如果单个服务出现问题，调用这个服务就会出现网络延迟，此时若有大量的网络涌入，会形成任务累计，导致服务瘫痪，甚至导致服务“雪崩”。为了解决这个问题，就出现断路器模型。 Hystrix服务熔断 熔断机制是对应雪崩效应的一种微服务链路保护机制 当扇出的链路的某个微服务不可用或者响应时间太长时, 会进行服务的降级, 进而熔断该节点微服务的调用, 快速返回错误信息. 当检测到该节点微服务调用相应正常后恢复调用链路. 在SpringCloud框架里熔断机制通过Hystrix实现. Hystrix会监控微服务间调用的状况. 当失败的调用到一定阈值, 缺省是5秒内20次调用失败就会启用熔断机制. 熔断机制的注解是 @HystixCommand 服务熔断在服务端进行编辑。 服务熔断简单实现 pom 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;springcloud&lt;/artifactId&gt; &lt;groupId&gt;cn.com.codingce&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;springcloud-provider-dept-hystrix-8001&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!--主要是增加这个注解hystrix--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--EUREKA--&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-eureka --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--完善监控信息--&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-actuator --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--我们需要拿到实体类, 所以要配置api -module--&gt; &lt;dependency&gt; &lt;groupId&gt;cn.com.codingce&lt;/groupId&gt; &lt;artifactId&gt;springcloud-api&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/ch.qos.logback/logback-core --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- &amp;lt;!&amp;ndash;jetty&amp;ndash;&amp;gt;--&gt; &lt;!-- &amp;lt;!&amp;ndash; https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-jetty &amp;ndash;&amp;gt;--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--热部署工具--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; DeptController 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package cn.com.codingce.springcloud.controller;import cn.com.codingce.springcloud.pojo.Dept;import cn.com.codingce.springcloud.service.DeptClientService;import org.springframework.cloud.client.ServiceInstance;import org.springframework.cloud.client.discovery.DiscoveryClient;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;import java.util.List;/** * @author xzMa * * 提供RestFul服务 */@RestControllerpublic class DeptController &#123; @Resource private DeptClientService deptService; //获取一些配置的信息 @Resource private DiscoveryClient client; @PostMapping(\"/dept/add\") public boolean addDept(Dept dept) &#123; return deptService.addDept(dept); &#125; @GetMapping(\"/dept/get/&#123;id&#125;\") public Dept queryBuId(@PathVariable(\"id\") Long id) &#123; return deptService.queryById(id); &#125; @GetMapping(\"/dept/list\") public List&lt;Dept&gt; queryAll() &#123; return deptService.queryAll(); &#125; //注册进来的微服务, 获取一些消息 @GetMapping(\"/dept/discovery\") public Object discovery() &#123; //获取微服务列表的清单 List&lt;String&gt; services = client.getServices(); System.out.println(\"discovery=&gt;\" + services); //得到一个具体的服务信息, 通过微服务id, applicationName List&lt;ServiceInstance&gt; instances = client.getInstances(\"SPRINGCLOUD-PROVIDER-DEPT\"); for (ServiceInstance instance : instances) &#123; System.out.println(instance.getHost() + \"\\t\" + instance.getPort() + \"\\t\" + instance.getUri() + \"\\t\" + instance.getServiceId()); &#125; return this.client; &#125;&#125; 启动项 1234567891011121314151617181920212223package cn.com.codingce.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;/** * @author xzMa * 启动类 * * Eureka客户端 */@SpringBootApplication@EnableEurekaClient //开启Eureka 在服务启动后, 自动注册到Eureka中@EnableDiscoveryClient //服务发现@EnableCircuitBreakerpublic class DeptProvider_Hystrix_8001 &#123; public static void main(String[] args) &#123; SpringApplication.run(DeptProvider_Hystrix_8001.class, args); &#125;&#125; Hystrix服务降级 什么是服务降级？ 当服务器压力剧增的情况下，根据实际业务情况及流量，对一些服务和页面有策略的不处理或换种简单的方式处理，从而释放服务器资源以保证核心交易正常运作或高效运作。 如果还是不理解，那么可以举个例子：假如目前有很多人想要给我付钱，但我的服务器除了正在运行支付的服务之外，还有一些其它的服务在运行，比如搜索、定时任务和详情等等。然而这些不重要的服务就占用了JVM的不少内存与CPU资源，为了能把钱都收下来（钱才是目标），我设计了一个动态开关，把这些不重要的服务直接在最外层拒掉，这样处理后的后端处理收钱的服务就有更多的资源来收钱了（收钱速度更快了），这就是一个简单的服务降级的使用场景。 服务降级是在客户端进行编辑。 使用场景 服务降级主要用于什么场景呢？当整个微服务架构整体的负载超出了预设的上限阈值或即将到来的流量预计将会超过预设的阈值时，为了保证重要或基本的服务能正常运行，我们可以将一些 不重要 或 不紧急 的服务或任务进行服务的 延迟使用 或 暂停使用。 简单实现 创建工厂DeptClientServiceFallbackFactory 客户端 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package cn.com.codingce.springcloud.service;import cn.com.codingce.springcloud.pojo.Dept;import feign.hystrix.FallbackFactory;import org.springframework.stereotype.Component;import java.util.ArrayList;import java.util.List;/** * 服务降级 * @author xzMa */@Componentpublic class DeptClientServiceFallbackFactory implements FallbackFactory &#123; @Override public DeptClientService create(Throwable throwable) &#123; return new DeptClientService()&#123; @Override public Dept queryById(Long id) &#123; Dept dept = new Dept(); dept.setDeptno(id); dept.setDname(\"id\" + \"=&gt;\" + \"没有对应的信息, 客户端提供了降级信息, 这个服务现在已关闭\"); dept.setDb_source(\"没有数据源\"); return dept; &#125; @Override public List&lt;Dept&gt; queryAll() &#123; Dept dept = new Dept(); dept.setDeptno((long) 10); dept.setDname(\"id\" + \"=&gt;\" + \"没有对应的信息, 客户端提供了降级信息, 这个服务现在已关闭\"); dept.setDb_source(\"没有数据源\"); List&lt;Dept&gt; deptList = new ArrayList&lt;&gt;(); deptList.add(dept); return deptList; &#125; @Override public boolean addDept(Dept dept) &#123; return false; &#125; &#125;; &#125;&#125; DeptClientService接口 @FeignClient(value = “SPRINGCLOUD-PROVIDER-DEPT”, fallbackFactory = DeptClientServiceFallbackFactory.class) 1234567891011121314151617181920212223242526272829303132333435363738394041package cn.com.codingce.springcloud.service;import cn.com.codingce.springcloud.pojo.Dept;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.stereotype.Component;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.PostMapping;import java.util.List;/** * @author xzMa * * feign（面向接口编程） 练习 在实体类项目 创建service包 并创建 DeptClientService接口 * * * 调用微服务两种方式 1 微服务名字 ribbon 2 接口和注解 feign * * * 只需要 接口和注解 * * 注解 */@Component//@FeignClient(value = \"SPRINGCLOUD-PROVIDER-DEPT\") 原 下面配合服务降级写法@FeignClient(value = \"SPRINGCLOUD-PROVIDER-DEPT\", fallbackFactory = DeptClientServiceFallbackFactory.class)public interface DeptClientService &#123; //接口 @GetMapping(\"/dept/get/&#123;id&#125;\") public Dept queryById(@PathVariable(\"id\") Long id); @GetMapping(\"/dept/list\") public List&lt;Dept&gt; queryAll(); @PostMapping(\"/dept/add\") public boolean addDept(Dept dept);&#125; 总结： 服务熔断: 服务端~ 某个服务超时或者异常, 引起熔断~ 保险丝 服务降级： 客户端~ 从整体网站请求负载考虑~ 当某个服务熔断或者关闭后, 服务将不再调用, 此时在客户但我们可以准备 一个FallbackFactory, 返回一个默认的值(缺省值), 整体的服务水平下降了~ , 好歹能够使用","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://i.codingce.com.cn/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://i.codingce.com.cn/tags/SpringCloud/"}]},{"title":"Feign","slug":"Feign","date":"2020-09-12T02:19:52.000Z","updated":"2020-12-13T04:41:40.422Z","comments":true,"path":"2020/09/12/Feign/","link":"","permalink":"http://i.codingce.com.cn/2020/09/12/Feign/","excerpt":"","text":"Feign[feɪn] 什么是Feign？ Feign 的英文表意为“假装，伪装，变形”， 是一个http请求调用的轻量级框架，可以以Java接口注解的方式调用Http请求，而不用像Java中通过封装HTTP请求报文的方式直接调用。Feign通过处理注解，将请求模板化，当实际调用的时候，传入参数，根据参数再应用到请求上，进而转化成真正的请求，这种请求相对而言比较直观。 Feign被广泛应用在Spring Cloud 的解决方案中，是学习基于Spring Cloud 微服务架构不可或缺的重要组件。 它让微服务之间调用变得更简单了, 类似controller调用service. SpringCloud集成了Ribbon Eureka, 可以在使用Feign时提供 负载均衡 的客户端 只需要一个接口, 然后添加注解即可 feign主要是社区, 大家都习惯面向接口编程. 这是很多开发人员的规范. 调用微服务有两种方法 微服务名字(ribbon) 接口和注解(feign) Feign能干什么 Feign旨在编写Java Http客户端变得更容易 前面使用Ribbon + RestTemplate时, 利用RestTemplate对Http请求的封装处理, 形成了一套模块化用法. 但是实际开发中, 由于服务的依赖的调用可能不止一处, 往往一个接口会被多处调用, 所以都会针对每一个服务自行封装一些客户端类来包装这些依赖服务的调用. 所以Feign在此基础上做了进一步封装, 由他来帮助我们定义和实现依赖服务接口的定义, **在Feign的实现下, 我们只需要创建一个接口并使用注解的方式来配置它(类似于以前Dao接口上标注@Mapper注解, 现在是一个微服务接口上面标注一个Feign注解即可.) 即可完成对服务同提供方的接口绑定, 简化了使用SpringCloud Ribbon时, 自动封装服务调用客户端的开发量 使用feign 就是代替 RestTemplate 具体实现 实体类项目 加入 接口(和注解) 项目结构 pom 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;springcloud&lt;/artifactId&gt; &lt;groupId&gt;cn.com.codingce&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;springcloud-api&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!--当前module自己需要的依赖, 如果父依赖中已经配置了版本--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--junit--&gt;&lt;!-- &lt;dependency&gt;--&gt;&lt;!-- &lt;groupId&gt;junit&lt;/groupId&gt;--&gt;&lt;!-- &lt;artifactId&gt;junit&lt;/artifactId&gt;--&gt;&lt;!-- &lt;/dependency&gt;--&gt; &lt;!--feign--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; DeptClientService 12345678910111213141516171819202122232425262728293031323334353637383940package cn.com.codingce.service;import cn.com.codingce.pojo.Dept;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.stereotype.Component;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.PostMapping;import java.util.List;/** * @author xzMa * * feign（面向接口编程） 练习 在实体类项目 创建service包 并创建 DeptClientService接口 * * * 调用微服务两种方式 1 微服务名字 ribbon 2 接口和注解 feign * * * 只需要 接口和注解 * * 注解 */@Component@FeignClient(value = \"SPRINGCLOUD-PROVIDER-DEPT\")public interface DeptClientService &#123; //接口 @GetMapping(\"/dept/get/&#123;id&#125;\") public Dept queryById(@PathVariable(\"id\") Long id); @GetMapping(\"/dept/list\") public List&lt;Dept&gt; queryAll(); @PostMapping(\"/dept/add\") public boolean addDept(Dept dept);&#125; 新建客户端项目(springcloud-cusumer-dept-feign) 项目结构 pom 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;springcloud&lt;/artifactId&gt; &lt;groupId&gt;cn.com.codingce&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;description&gt;也是用来做客户端的&lt;/description&gt; &lt;artifactId&gt;springcloud-cusumer-dept-feign&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!--feign--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--我们需要拿到实体类, 所以要配置api -module--&gt; &lt;dependency&gt; &lt;groupId&gt;cn.com.codingce&lt;/groupId&gt; &lt;artifactId&gt;springcloud-api&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;!--热部署工具--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--Ribbon--&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-ribbon --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--Eureka 客户端--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; DeptConsumerController 123456789101112131415161718192021222324252627282930313233package cn.com.codingce.springcloud.controller;import cn.com.codingce.pojo.Dept;import cn.com.codingce.service.DeptClientService;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;import java.util.List;@RestControllerpublic class DeptConsumerController &#123; @Resource private DeptClientService deptClientService = null; @RequestMapping(\"/consumer/dept/add\") public boolean add(Dept dept) &#123; return this.deptClientService.addDept(dept); &#125; @RequestMapping(\"/consumer/dept/get/&#123;id&#125;\") public Dept get(@PathVariable(\"id\") Long id) &#123; return this.deptClientService.queryById(id); &#125; @RequestMapping(\"/consumer/dept/list\") public List&lt;Dept&gt; list() &#123; return this.deptClientService.queryAll(); &#125;&#125; ConfigBean(配置Ribbon) 12345678910111213141516171819202122232425262728293031package cn.com.codingce.springcloud.config;import com.netflix.loadbalancer.IRule;import com.netflix.loadbalancer.RandomRule;import org.springframework.cloud.client.loadbalancer.LoadBalanced;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.client.RestTemplate;@Configurationpublic class ConfigBean &#123; //configuration -- spring applicationContext.xml //配置负载均衡实现RestTemplate @LoadBalanced //IRule //AvailabilityFilteringRule: 先会过滤掉, 跳闸, 访问故障服务器 //RoundRobinRule 轮询 //RandomRule 随机 //RetryRule： 会按照轮询获取服务~ 如果服务获取失败, 则会在指定的时间内进行, 重试 @Bean @LoadBalanced public RestTemplate getRestTemplate() &#123; return new RestTemplate(); &#125; @Bean public IRule myRule() &#123; return new RandomRule(); &#125;&#125; 启动类FeginDeptConsumer_80 123456789101112131415161718192021package cn.com.codingce.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;import org.springframework.cloud.openfeign.EnableFeignClients;import org.springframework.context.annotation.ComponentScan;/** * @author xzMa * 在微服务启动的时候就能加载我们自定义的Ribbon类 */@SpringBootApplication@EnableEurekaClient //Eureka 客户端@EnableFeignClients(basePackages = &#123;\"cn.com.codingce\"&#125;)@ComponentScan(\"cn.com.codingce\")public class FeginDeptConsumer_80 &#123; public static void main(String[] args) &#123; SpringApplication.run(FeginDeptConsumer_80.class, args); &#125;&#125; 操作截图 本项目地址: https://github.com/xzMhehe/codingce-java 开源项目地址： https://github.com/OpenFeign/feign","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://i.codingce.com.cn/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://i.codingce.com.cn/tags/SpringCloud/"}]},{"title":"Ribbon","slug":"ribbon","date":"2020-09-11T08:42:45.000Z","updated":"2020-12-13T04:41:40.438Z","comments":true,"path":"2020/09/11/ribbon/","link":"","permalink":"http://i.codingce.com.cn/2020/09/11/ribbon/","excerpt":"","text":"Ribbon [ˈrɪbən] Ribbon是什么 Spring Cloud Ribbon是一个基于HTTP和TCP的 客户端 负载均衡 工具 简单的说，Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法，将Netflix的中间层服务连接在一起。Ribbon客户端组件提供一系列完善的配置项如连接超时，重试等。简单的说，就是在配置文件中列出Load Balancer（简称LB）后面所有的机器，Ribbon会自动的帮助你基于某种规则（如简单轮询，随机连接等）去连接这些机器。我们也很容易使用Ribbon实现自定义的负载均衡算法。 它基于Netflix Ribbon实现。通过Spring Cloud的封装，可以让我们轻松地将面向服务的REST模版请求自动转换成客户端负载均衡的服务调用。Spring Cloud Ribbon虽然只是一个工具类框架，它不像服务注册中心、配置中心、API网关那样需要独立部署，但是它几乎存在于每一个Spring Cloud构建的微服务和基础设施中。因为微服务间的调用，API网关的请求转发等内容，实际上都是通过Ribbon来实现的，包括后续我们将要介绍的Feign，它也是基于Ribbon实现的工具。所以，对Spring Cloud Ribbon的理解和使用，对于我们使用Spring Cloud来构建微服务非常重要。 面试造飞机, 工作拧螺丝 Ribbon能干嘛 LB（负载均衡 LB，即负载均衡(Load Balance)，在微服务或分布式集群中经常用的一种应用。 负载均衡简单的说就是将用户的请求平摊的分配到多个服务上，从而达到系统的HA。 常见的负载均衡有软件Nginx，LVS，硬件 F5等。 相应的在中间件，例如：dubbo和SpringCloud中均给我们提供了负载均衡，SpringCloud的负载均衡算法可以自定义。 负载均衡的简单分类 集中式LB 即在服务的消费方和提供方之间使用独立的LB设施 (可以是硬件，如F5, 也可以是软件，如nginx), 由该设施负责把访问请求通过某种策略转发至服务的提供方； 将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器。Ribbon就属于进程内LB，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址。 注意： Ribbon就属于进程内LB ，它只是一个类库，集成于消费方进程，消费方通过它来 获取到服务提供方的地址 。 具体操作 pom 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;springcloud&lt;/artifactId&gt; &lt;groupId&gt;cn.com.codingce&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;springcloud-consumer-dept&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!--我们需要拿到实体类, 所以要配置api -module--&gt; &lt;dependency&gt; &lt;groupId&gt;cn.com.codingce&lt;/groupId&gt; &lt;artifactId&gt;springcloud-api&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;!--热部署工具--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--Ribbon--&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-ribbon --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--Eureka 客户端--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; ConfigBean 12345678910111213141516171819202122package cn.com.codingce.springcloud.config;import org.springframework.cloud.client.loadbalancer.LoadBalanced;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.client.RestTemplate;@Configurationpublic class ConfigBean &#123; //configuration -- spring applicationContext.xml //配置负载均衡实现RestTemplate @LoadBalanced //IRule //AvailabilityFilteringRule: 先会过滤掉, 跳闸, 访问故障服务器 //RoundRobinRule 轮询 //RandomRule 随机 //RetryRule： 会按照轮询获取服务~ 如果服务获取失败, 则会在指定的时间内进行, 重试 @Bean @LoadBalanced public RestTemplate getRestTemplate() &#123; return new RestTemplate(); &#125;&#125; DeptConsumerController 12345678910111213141516171819202122232425262728293031323334353637383940414243package cn.com.codingce.springcloud.controller;import cn.com.codingce.pojo.Dept;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.client.RestTemplate;import java.util.List;@RestControllerpublic class DeptConsumerController &#123; // 理解消费者, 不应该有service层 //RestFul风格 //(url, 实体: Map classs&lt;T&gt; responseType) @Autowired private RestTemplate restTemplate; //提供多种便捷访问远程http服务的方法 //原 private static final String REST_URL_PREFIX = \"http://localhost:8001\"; // Ribbon 我们这里是地址 因该是一个变量 通过服务来访问 private static final String REST_URL_PREFIX = \"http://SPRINGCLOUD-PROVIDER-DEPT\"; @RequestMapping(\"/consumer/dept/add\") public boolean add(Dept dept) &#123; return restTemplate.postForObject(REST_URL_PREFIX + \"/dept/add\", dept, Boolean.class); &#125; //http://localhost:8001/dept/list @RequestMapping(\"/consumer/dept/get/&#123;id&#125;\") public Dept get(@PathVariable(\"id\") Long id) &#123; return restTemplate.getForObject(REST_URL_PREFIX + \"/dept/get/\" + id, Dept.class ); &#125; @RequestMapping(\"/consumer/dept/list\") public List&lt;Dept&gt; list() &#123; return restTemplate.getForObject(REST_URL_PREFIX + \"/dept/list\" , List.class ); &#125;&#125; 自定义负载均衡 注意一点: 自定义类 单独拿出来 该类不能被@ComponentScan扫描到 项目截图 自定义CodingCeRandomRule 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package cn.com.codingce.myrule;import com.netflix.client.config.IClientConfig;import com.netflix.loadbalancer.AbstractLoadBalancerRule;import com.netflix.loadbalancer.ILoadBalancer;import com.netflix.loadbalancer.Server;import java.util.List;import java.util.concurrent.ThreadLocalRandom;/** * 该类不能被@ComponentScan扫描到 * @author xzMa */public class CodingCeRandomRule extends AbstractLoadBalancerRule &#123; //自定义 每个服务, 访问5次, 换下一个服务(3个) //total = 0 默认=0 如果=5 我们指向下一个服务点 private int total = 0; //被调用的次数 private int currentIndex = 0; //当前是谁在提供服务 public CodingCeRandomRule() &#123;&#125;// @SuppressWarnings(&#123;\"RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE\"&#125;) public Server choose(ILoadBalancer lb, Object key) &#123; if (lb == null) &#123; return null; &#125; else &#123; Server server = null; while(server == null) &#123; //线程中断 if (Thread.interrupted()) &#123; return null; &#125; List&lt;Server&gt; upList = lb.getReachableServers(); //获得活着的服务 List&lt;Server&gt; allList = lb.getAllServers(); //获得全部服务 int serverCount = allList.size(); if (serverCount == 0) &#123; return null; &#125; //int index = this.chooseRandomInt(serverCount); //生成区间随机数 //server = (Server)upList.get(index); //从活着的服务, 随机获取一个 //=================================================================== if (total &lt; 5) &#123; server = upList.get(currentIndex); total++; &#125; else &#123; total = 0; currentIndex++; //判断当前数量是否大于活着的数量 if(currentIndex &gt; upList.size()) &#123; currentIndex = 0; &#125; server = upList.get(currentIndex); //从活着的服务中, 获取指定指定的服务进行操作 &#125; if (server == null) &#123; Thread.yield(); &#125; else &#123; if (server.isAlive()) &#123; return server; &#125; server = null; Thread.yield(); &#125; &#125; return server; &#125; &#125; protected int chooseRandomInt(int serverCount) &#123; return ThreadLocalRandom.current().nextInt(serverCount); &#125; @Override public Server choose(Object key) &#123; return this.choose(this.getLoadBalancer(), key); &#125; @Override public void initWithNiwsConfig(IClientConfig clientConfig) &#123; &#125;&#125; CodingCeRule 123456789101112131415161718package cn.com.codingce.myrule;import com.netflix.loadbalancer.IRule;import com.netflix.loadbalancer.RandomRule;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class CodingCeRule &#123; @Bean public IRule myRule() &#123; return new CodingCeRandomRule(); //默认是轮询 现在我们定义为 CodingCeRandomRule // 本次自定义 频繁操作 会出现 500 错误 继续自定义写RetryRule &#125;&#125; 项目地址: https://github.com/xzMhehe/codingce-java","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://i.codingce.com.cn/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://i.codingce.com.cn/tags/SpringCloud/"}]},{"title":"Eureka","slug":"Eureka","date":"2020-09-08T04:15:44.000Z","updated":"2020-12-13T04:41:40.422Z","comments":true,"path":"2020/09/08/Eureka/","link":"","permalink":"http://i.codingce.com.cn/2020/09/08/Eureka/","excerpt":"","text":"Eureka[juˈriːkə] 简介 Eureka是Netflix服务发现的服务端与客户端，Eureka提供服务注册以及服务发现的能力，当是Eureka Server时(注册中心)，所有的客户端会向其注册，当是Eureka Client时，可以从注册中心获取对应的服务信息，或者是向Eureka Server将自己作为实例注册进去，每个Eureka不仅仅是一个服务端同时还是一个客户端。 注册中心 当Eureka想要成为注册中心时，必须将注册中心的服务地址指向自己，同时禁用服务检索的功能。Eureka是一个高可用的组件，它没有后端缓存，每一个实例注册之后需要向注册中心发送心跳来检测服务的可用性，注册中心不处理请求的转发，只是记录每个实例注册进来的信息。 项目搭建 导入依赖 编写配置文件 开启这个功能 @EnableXXXXXX 配置类 Eureka服务 pom 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;springcloud&lt;/artifactId&gt; &lt;groupId&gt;cn.com.codingce&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;springcloud-eureka-7001&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-eureka-server --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--热部署工具--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; EurekaServer 12345678910111213package cn.com.codingce;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;@SpringBootApplication@EnableEurekaServer //EnableEurekaServer 服务端启动类public class EurekaServer &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaServer.class, args); &#125;&#125; application.yml 123456789101112server: port: 7001# Eureka配置eureka: instance: hostname: localhost #Eureka服务端实例的名字 client: register-with-eureka: false # 表示是否向eureka注册中心注册自己 fetch-registry: false # 表示如果 false 则表示自己为注册中心 service-url: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ Eureka 的自我保护模式详解 访问Eureka主页时，如果看到这样一段大红色的句子： EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY’RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE. （那么就表明着Eureka的 自我保护模式(self-preservation mode) 被启动了，当 Eureka Server 节点在短时间内丢失了过多实例的连接时（比如网络故障或频繁的启动关闭客户端），那么这个节点就会进入自我保护模式，一旦进入到该模式，Eureka server 就会保护服务注册表中的信息，不再删除服务注册表中的数据（即不会注销任何微服务），当网络故障恢复后，该 Ereaka Server 节点就会自动退出自我保护模式） 在自我保护模式中, EurekaServe 会保护注册表中的信息, 不再注销任何服务实例. 当他重新收到心跳数重新恢复到阈值以上时, 该EurekaServe节点就会自动推出自我保护模式. 它的哲学就是宁可保存错误的服务注册信息, 也不盲目注销任何可能健康的实例, 一句话：好死不如赖活着 综上, 自我保护模式中, 自我保护模式是一种应对网络异常安全保护措施, 它的架构哲学是宁可同时保留所有微服务(健康的服务和不健康的服务都会保留), 也不盲目注销任何健康的服务. 使用自我保护模式, 可以让Eureka集群更加健壮和稳定. 在SpringCloud中, 可以使用eureka.serve.enable-self-preservation = false 禁用自我保护模式 [不推荐关闭自我保护机制] 默认情况下，如果 Ereaka Server 在一段时间内没有接受到某个微服务示例的心跳，便会注销该实例（默认90秒），而一旦进入自我保护模式，那么即使你关闭了指定实例，仍然会发现该 Ereaka Server 的注册实例中会存在被关闭的实例信息，如果你对该实例做了负载均衡，那么仅关闭了其中一个实例，则通过网关调用接口api时很可能会发生如下异常： 1234567&#123;\"timestamp\": 1507707671780,\"status\": 500,\"error\": \"Internal Server Error\",\"exception\": \"com.netflix.zuul.exception.ZuulException\",\"message\": \"GENERAL\"&#125; 解决这种情况的方法主要有几种方式： 等待 Eureka Server 自动恢复 正常的情况下，等待网络恢复（或者没有频繁的启动与关闭实例）后，等待一段时间 Eureka Server 会自动关闭自我保护模式，但是如果它迟迟没有关闭该模式，那么便可以尝试手动关闭，如下。 重启 Eureka Server 通常而言，PRD 环境建议对 Eureka Server 做负载均衡，这样在依次关闭并开启 Eureka Server 后，无效的实例会被清除，并且不会对正常的使用照成影响。 关闭 Eureka 的自我保护模式 在yml配置文件中新增如下配置： 1234eureka: server: enable-self-preservation: false eviction-interval-timer-in-ms: 4000 # This is not required 对比Zookeeper 回顾CAP原则 RDBMS(Mysql、Oracle、sqlServer) ==&gt;ACID NoSQL(redis、 mongdb)==&gt;CAP ACID是什么 A(Atomicity)原子性：事务里面的所有操作，要么全部做完，要么都不做，只要有一个失败，整个事务都失败，需要回滚 C(Consistency)一致性：以转账案例为例，假设有五个账户，每个账户余额是100元，那么五个账户总额是500元，如果在这个5个账户之间同时发生多个转账，无论并发多少个，比如在A与B账户之间转账5元，在C与D账户之间转账10元，在B与E之间转账15元，五个账户总额也应该还是500元，这就是保护性和不变性 I(Isolation)隔离性：并发的事务之间互不影响 D(Durability)持久性：事务一旦提交，数据将永久保存在数据库上 CAP是什么 C(Consistency)强一致性 A(Availability)可用性 P(Partition tolerance) 分区容错性 CAP的三进二 CA AP CP CAP理论核心 一个分布式系统不可能同时很好的满足一致性、可用性和分区容错性三个要求 根据CAP原理, 将NOSQL数据库分成了满足CA原则， 满足CP原则满足AP原则三大类 CA：单点集群, 满足一致性, 可用性的系统, 通常可扩展性差 CP: 满足一致性, 分区容错性的系统, 通常性能不是特别高 AP：满足可用性，分区容错性的系统，通常可能对一致性要求低一点 作为服务注册中心, Eureka比Zookeeper好在哪里 著名的CAP理论指出, 一个分布式系统不可能同时满足C(一致性)A(可用性)P(容错性) 由于分区容错性P在分布式系统中是必须要保证的, 因此我们只能在A和C之前进行权衡 Zookeeper保证的是CP Eureka保证的是AP Zookeeper保证的是CP 当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的信息，但不能就收服务直接 down 掉不可用。也就是说服务注册的可用性要高于一致性 当时 zk 会出现这么一个情况，当 mastr 节点因网络故障和其他节点失去联系时，剩余节点会重新进行选举。问题在于，选举时间比较长，30s~120s，且选举期间，整个 zk 是不可用的。这就导致了在选举期间，注册服务的瘫痪。在云部署的环境下，因网络问题使 zk 集群时区 master 节点是交大概率会发生的事情，虽然服务能够最终恢复，但是漫长的选举时间导致的注册服务长期不可用是不能容忍的。 Eureka保证的是AP Eureka 明白这一点，因此在设计时，就优先保证可用性. Eureka 各个节点是平等的 ，几个节点挂掉不会影响正常工作，只要有一台 Eureka 存在，就可以保证注册服务可用（保证可用性），只不过查到的信息可能不是最新的（不保证强一致性）。除此之外，Eureka 还有一种自我保护机制，如果在 15 分钟内超过 85% 的节点没有正常的心跳，那么 Eureka 就会认为客户端与注册中心出现了故障，此时会出现以下几种情况： Eureka 不再从注册列表中移出因长时间没收到心跳而应该过期的服务 Eureka 仍然能够接受新服务的注册和查询要求，但是不会被同步到其他节点上（即保证当前节点依然可用） 当网络稳定时，当前实例新的注册信息会被同步到其他节点中 结论 Eureka 可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像 zookeeper 那样使整个注册服务瘫痪 服务注册集群搭建 springcloud-eureka-7002 pom 12345678910111213141516171819202122232425262728&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;springcloud&lt;/artifactId&gt; &lt;groupId&gt;cn.com.codingce&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;springcloud-eureka-7002&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-eureka-server --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--热部署工具--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; application.yml 123456789101112server: port: 7002# Eureka配置eureka: instance: hostname: eureka7002.com #Eureka服务端实例的名字 client: register-with-eureka: false # 表示是否向eureka注册中心注册自己 fetch-registry: false # 表示如果 false 则表示自己为注册中心 service-url: defaultZone: http://eureka7001.com:7001/eureka/, http://eureka7003.com:7003/eureka/ 启动类 12345678910111213package cn.com.codingce;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;@SpringBootApplication@EnableEurekaServer //EnableEurekaServer 服务端启动类public class EurekaServer_7003 &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaServer_7003.class, args); &#125;&#125; springcloud-eureka-7003 pom 12345678910111213141516171819202122232425262728&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;springcloud&lt;/artifactId&gt; &lt;groupId&gt;cn.com.codingce&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;springcloud-eureka-7003&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-eureka-server --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--热部署工具--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; application.yml 12345678910111213141516server: port: 7003# Eureka配置server: port: 7003# Eureka配置eureka: instance: hostname: eureka7003.com #Eureka服务端实例的名字 client: register-with-eureka: false # 表示是否向eureka注册中心注册自己 fetch-registry: false # 表示如果 false 则表示自己为注册中心 service-url: defaultZone: http://eureka7001.com:7001/eureka/, http://eureka7002.com:7002/eureka/ 启动类 12345678910111213package cn.com.codingce;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;@SpringBootApplication@EnableEurekaServer //EnableEurekaServer 服务端启动类public class EurekaServer_7003 &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaServer_7003.class, args); &#125;&#125;","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://i.codingce.com.cn/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://i.codingce.com.cn/tags/SpringCloud/"}]},{"title":"初识springcloud","slug":"初识springcloud","date":"2020-09-02T05:28:39.000Z","updated":"2020-12-13T04:41:40.438Z","comments":true,"path":"2020/09/02/初识springcloud/","link":"","permalink":"http://i.codingce.com.cn/2020/09/02/%E5%88%9D%E8%AF%86springcloud/","excerpt":"","text":"Spring Cloud 是一套完整的微服务解决方案，基于 Spring Boot 框架，准确的说，它不是一个框架，而是一个大的容器，它将市面上较好的微服务框架集成进来，从而简化了开发者的代码量。 Spring Cloud 是什么？ Spring Cloud 是一系列框架的有序集合，它利用 Spring Boot 的开发便利性简化了分布式系统的开发，比如服务发现、服务网关、服务路由、链路追踪等。Spring Cloud 并不重复造轮子，而是将市面上开发得比较好的模块集成进去，进行封装，从而减少了各模块的开发成本。换句话说：Spring Cloud 提供了构建分布式系统所需的“全家桶”。 Spring Cloud 现状 目前，国内使用 Spring Cloud 技术的公司并不多见，不是因为 Spring Cloud 不好，主要原因有以下几点： Spring Cloud 中文文档较少，出现问题网上没有太多的解决方案。 国内创业型公司技术老大大多是阿里系员工，而阿里系多采用 Dubbo 来构建微服务架构。 大型公司基本都有自己的分布式解决方案，而中小型公司的架构很多用不上微服务，所以没有采用 Spring Cloud 的必要性。 但是，微服务架构是一个趋势，而 Spring Cloud 是微服务解决方案的佼佼者. Spring Cloud 优缺点 优点 集大成者，Spring Cloud 包含了微服务架构的方方面面。 约定优于配置，基于注解，没有配置文件。 轻量级组件，Spring Cloud 整合的组件大多比较轻量级，且都是各自领域的佼佼者。 开发简便，Spring Cloud 对各个组件进行了大量的封装，从而简化了开发。 开发灵活，Spring Cloud 的组件都是解耦的，开发人员可以灵活按需选择组件。 缺点 项目结构复杂，每一个组件或者每一个服务都需要创建一个项目。 部署门槛高，项目部署需要配合 Docker 等容器技术进行集群部署，而要想深入了解 Docker，学习成本高。 Spring Cloud 的优势是显而易见的。学习 Spring Cloud 是一个不错的选择。 Spring Cloud 和 Dubbo 对比 Dubbo 只是实现了服务治理，而 Spring Cloud 实现了微服务架构的方方面面，服务治理只是其中的一个方面。下面通过一张图对其进行比较： 可以看出，Spring Cloud 比较全面，而 Dubbo 由于只实现了服务治理，需要集成其他模块，需要单独引入，增加了学习成本和集成成本。 项目结构 总包 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;cn.com.codingce&lt;/groupId&gt; &lt;artifactId&gt;springcloud&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;modules&gt; &lt;module&gt;springcloud-api&lt;/module&gt; &lt;module&gt;springcloud-provider-dept&lt;/module&gt; &lt;module&gt;springcloud-consumer-dept&lt;/module&gt; &lt;/modules&gt; &lt;!--打包方式--&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;!--统一配置 版本号--&gt; &lt;properties&gt; &lt;junit.version&gt;4.12&lt;/junit.version&gt; &lt;lombok.version&gt;1.16.10&lt;/lombok.version&gt; &lt;mysql.version&gt;8.0.11&lt;/mysql.version&gt; &lt;druid.version&gt;1.1.10&lt;/druid.version&gt; &lt;logbackcore.version&gt;1.2.3&lt;/logbackcore.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- springcloud的依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Greenwich.SR1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!--springboot依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;scope&gt;2.1.4.RELEASE&lt;/scope&gt; &lt;/dependency&gt; &lt;!--连接数据库--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;$&#123;druid.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/ch.qos.logback/logback-core --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;$&#123;lombok.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-devtools --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;version&gt;2.2.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-jetty --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;version&gt;2.1.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;&lt;/project&gt; 实体类 pom 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;springcloud&lt;/artifactId&gt; &lt;groupId&gt;cn.com.codingce&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;springcloud-api&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!--当前module自己需要的依赖, 如果父依赖中已经配置了版本--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--junit--&gt;&lt;!-- &lt;dependency&gt;--&gt;&lt;!-- &lt;groupId&gt;junit&lt;/groupId&gt;--&gt;&lt;!-- &lt;artifactId&gt;junit&lt;/artifactId&gt;--&gt;&lt;!-- &lt;/dependency&gt;--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; Dept 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package cn.com.codingce.pojo;import lombok.experimental.Accessors;import java.io.Serializable;/** * @author xzMa * Dept实体类 orm 类表关系映射 */@Accessors //链式写法public class Dept implements Serializable &#123; private Long deptno; private String dname; private String db_source; /** * Dept dept = new Dept(); * dept.setDeptNo(\"\").setDeptyName()..... 都行 */ public Dept() &#123; &#125; public Dept(Long deptno, String dname, String db_source) &#123; this.deptno = deptno; this.dname = dname; this.db_source = db_source; &#125; public Long getDeptno() &#123; return deptno; &#125; public void setDeptno(Long deptno) &#123; this.deptno = deptno; &#125; public String getDname() &#123; return dname; &#125; public void setDname(String dname) &#123; this.dname = dname; &#125; public String getDb_source() &#123; return db_source; &#125; public void setDb_source(String db_source) &#123; this.db_source = db_source; &#125; @Override public String toString() &#123; return \"Dept&#123;\" + \"deptno=\" + deptno + \", dname='\" + dname + '\\'' + \", db_source='\" + db_source + '\\'' + '&#125;'; &#125;&#125; 服务端 pom 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;springcloud&lt;/artifactId&gt; &lt;groupId&gt;cn.com.codingce&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;springcloud-provider-dept&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!--我们需要拿到实体类, 所以要配置api -module--&gt; &lt;dependency&gt; &lt;groupId&gt;cn.com.codingce&lt;/groupId&gt; &lt;artifactId&gt;springcloud-api&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/ch.qos.logback/logback-core --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;!-- &amp;lt;!&amp;ndash;jetty&amp;ndash;&amp;gt;--&gt;&lt;!-- &amp;lt;!&amp;ndash; https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-jetty &amp;ndash;&amp;gt;--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--热部署工具--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; Controller 12345678910111213141516171819202122232425262728293031323334353637383940package cn.com.codingce.controller;import cn.com.codingce.pojo.Dept;import cn.com.codingce.service.DeptService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;import java.util.List;/** * @author xzMa * * 提供RestFul服务 */@RestControllerpublic class DeptController &#123; @Resource private DeptService deptService; @PostMapping(\"/dept/add\") public boolean addDept(Dept dept) &#123; return deptService.addDept(dept); &#125; @GetMapping(\"/dept/get/&#123;id&#125;\") public Dept queryBuId(@PathVariable(\"id\") Long id) &#123; return deptService.queryById(id); &#125; @GetMapping(\"/dept/list\") public List&lt;Dept&gt; queryAll() &#123; return deptService.queryAll(); &#125;&#125; DAO (mapper) 12345678910111213141516171819package cn.com.codingce.dao;import cn.com.codingce.pojo.Dept;import org.apache.ibatis.annotations.Mapper;import org.springframework.stereotype.Repository;import java.util.List;@Mapper@Repositorypublic interface DeptDao &#123; public boolean addDept(Dept dept); public Dept queryById(Long id); public List&lt;Dept&gt; queryAll();&#125; Mapper.xml 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"cn.com.codingce.dao.DeptDao\"&gt; &lt;insert id=\"addDept\" parameterType=\"Dept\"&gt; insert into dept(dname, db_source) values (#&#123;dname&#125;, DATABASE()) &lt;/insert&gt; &lt;select id=\"queryById\" parameterType=\"Long\" resultType=\"Dept\"&gt; select * from dept where deptno = #&#123;deptno&#125; &lt;/select&gt; &lt;select id=\"queryAll\" resultType=\"Dept\"&gt; select * from dept &lt;/select&gt;&lt;/mapper&gt; Service接口 12345678910111213package cn.com.codingce.service;import cn.com.codingce.pojo.Dept;import java.util.List;public interface DeptService &#123; public boolean addDept(Dept dept); public Dept queryById(Long id); public List&lt;Dept&gt; queryAll();&#125; Service实现类 123456789101112131415161718192021222324252627282930package cn.com.codingce.service;import cn.com.codingce.dao.DeptDao;import cn.com.codingce.pojo.Dept;import org.springframework.stereotype.Service;import javax.annotation.Resource;import java.util.List;@Servicepublic class DeptServiceImpl implements DeptService &#123; @Resource private DeptDao deptDao; @Override public boolean addDept(Dept dept) &#123; return deptDao.addDept(dept); &#125; @Override public Dept queryById(Long id) &#123; return deptDao.queryById(id); &#125; @Override public List&lt;Dept&gt; queryAll() &#123; return deptDao.queryAll(); &#125;&#125; mybatis-config.xml 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;!--核心配置文件--&gt;&lt;configuration&gt; &lt;!--开启二级缓存--&gt; &lt;settings&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt; &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/&gt; &lt;/settings&gt;&lt;/configuration&gt; application.yml 123456789101112131415161718192021server: port: 8001#mybatis配置mybatis: type-aliases-package: cn.com.codingce.pojo config-location: classpath:mybatis/mybatis-config.xml mapper-locations: classpath:mybatis/mapper/*.xml# configuration:# map-underscore-to-camel-case: true# spring配置spring: application: name: springcloud-provider-dept datasource: type: com.alibaba.druid.pool.DruidDataSource # 数据源 德鲁伊 driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://cdb-q9atzwrq.bj.tencentcdb.com:10167/db01?useSSL=true username: root password: 123456 客户端 pom 123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;springcloud&lt;/artifactId&gt; &lt;groupId&gt;cn.com.codingce&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;springcloud-consumer-dept&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!--我们需要拿到实体类, 所以要配置api -module--&gt; &lt;dependency&gt; &lt;groupId&gt;cn.com.codingce&lt;/groupId&gt; &lt;artifactId&gt;springcloud-api&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;!--热部署工具--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 配置文件 123456789101112131415package cn.com.codingce.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.client.RestTemplate;@Configurationpublic class ConfigBean &#123; //configuration -- spring applicationContext.xml @Bean public RestTemplate getRestTemplate() &#123; return new RestTemplate(); &#125;&#125; Controller 1234567891011121314151617181920212223242526272829303132333435363738394041package cn.com.codingce.controller;import cn.com.codingce.pojo.Dept;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.client.RestTemplate;import java.util.List;@RestControllerpublic class DeptConsumerController &#123; // 理解消费者, 不应该有service层 //RestFul风格 //(url, 实体: Map classs&lt;T&gt; responseType) @Autowired private RestTemplate restTemplate; //提供多种便捷访问远程http服务的方法 private static final String REST_URL_PREFIX = \"http://localhost:8001\"; @RequestMapping(\"/consumer/dept/add\") public boolean add(Dept dept) &#123; return restTemplate.postForObject(REST_URL_PREFIX + \"/dept/add\", dept, Boolean.class); &#125; //http://localhost:8001/dept/list @RequestMapping(\"/consumer/dept/get/&#123;id&#125;\") public Dept get(@PathVariable(\"id\") Long id) &#123; return restTemplate.getForObject(REST_URL_PREFIX + \"/dept/get/\" + id, Dept.class ); &#125; @RequestMapping(\"/consumer/dept/list\") public List&lt;Dept&gt; list() &#123; return restTemplate.getForObject(REST_URL_PREFIX + \"/dept/list\" , List.class ); &#125;&#125; application.yml 12server: port: 80","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://i.codingce.com.cn/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://i.codingce.com.cn/tags/SpringCloud/"}]},{"title":"微服务总结","slug":"微服务总结","date":"2020-09-01T14:53:56.000Z","updated":"2020-12-13T04:41:40.438Z","comments":true,"path":"2020/09/01/微服务总结/","link":"","permalink":"http://i.codingce.com.cn/2020/09/01/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%80%BB%E7%BB%93/","excerpt":"","text":"微服务架构的4个核心问题 服务很多, 客户端该怎么访问? 这么多服务, 服务之间如何通信? 这么多服务, 如何治理? 服务挂了怎么办? 解决方案 SpringCloud生态 SpringBoot SpringCloud NetFlix 一站式解决方案 api网关 zuul组件 Feign —HttpClinet —Http通信方式同步阻塞 服务注册与发现: Eureka 熔断机制: Hystrix Apache Dubbo Zookeeper 半自动需要整合别人的 api网关 没有 找第三方组件, 或者自己实现 Dubbo Zookeeper 没有借助 Hystrix Dubbo 这个方案并不完善~ SpringCloud Alibaba 一站式解决方案 更简单 新概念 服务网格~Serve Mesh istio 万变不离其宗 API网关 HTTP RPC 注册和发现 熔断机制 网络不可靠! 常见面试题 什么是微服务 微服务之间是如何建立通信的 SpringCloud和Dubbp有哪些区别 SpringCloud和SpringBoot请谈谈你对他们呢得理解 什么服务熔断? 什么是服务降级 微服务得优缺点是什么? 说下你在项目开发中遇到的坑 你所知道的微服务技术有哪些? 列举一二 eureka和zookeeper都可以实现提供服务注册与发现功能, 请说明两个的区别? 微服务概述 什么是微服务 什么是微服务？（熟悉的同学可以直接跳过） 简单举例：看军事新闻的同学应该都知道，一艘航空母舰作战能力虽然很强，但是弱点太明显，就是防御能力太差，单艘的航空母舰很少单独行动，通常航空母舰战斗群才是主要军事力量，你可以把单艘航母理解为的单体应用（防御差，机动性不好），把航母战斗群（调度复杂，维护费用高）理解为微服务。 大部分的开发者经历和开发过单体应用，无论是传统的 Servlet + JSP，还是 SSM，还是现在的 SpringBoot，它们都是单体应用，那么长期陪伴我们的单体应用有什么弊端？我们是面临了什么问题，导致我们要抛弃单体应用转向微服务架构？个人总结主要问题如下： 部署成本高（无论是修改1行代码，还是10行代码，都要全量替换） 改动影响大，风险高（不论代码改动多小，成本都相同） 因为成本高，风险高，所以导致部署频率低（无法快速交付客户需求） 当然还有例如无法满足快速扩容，弹性伸缩，无法适应云环境特性等问题，但我们不一一详谈了，以上的问题，都是微服务架构要解决的问题，至于具体是怎么解决的，我们先放到后面再聊 https://martinfowler.com/articles/microservices.html 微服务与微服务架构 微服务 强调的是服务的大小, 它关注的是某一点, 在具体解决某一问题/提供落地对应服务的一个服务应用, 侠义的看, 可以看作是IDEA中的一个个微服务工程, 或者Moudel IDEA工具里面使用Maven开发的, 一个个独立的Moudel, 它具体使用springboot开发的一个模块, 专业的事情交给专业的模块来做, 一个模块就做一个事情 强调的是一个个的个体, 每个个体完成一个具体的任务或者功能 微服务架构 一种新的框架形式, Martin Fowler 2014年提出 微服务框架是一种框架模式, 它提倡将单一应用程序化为一组服务, 服务之间相互协调, 互相配合, 为用户提供最终价值. 每个服务运行在其独立进程中, 服务于服务间采用轻量级的通信机制相互协作, 每个服务都围绕着具体业务来构建, 并且能够独立部署到生产环境中, 另外, 尽量避免统一的, 集中式的管理机制. 对于一个具体服务而言, 应根据服务上下文, 选择合适的语言工具进行构建. 微服务的优缺点 优点: 这种单体架构的优点在于方便管理，所有代码在同一项目中，但是当需求越来越多，项目规模越来越大，其坏处也很明显。 单一职责原则 每个服务足够内聚, 足够小, 代码容易理解, 这样能够聚焦一个指定的业务功能或业务需求 开发简单, 开发效率高, 一个服务就是专一的只干一件事情 微服务可以被小团队开发, 这个小团队是2-5人开发人员组成 微服务是松耦合的, 具有功能意义的服务, 无论是在开发阶段还是在部署阶段 微服务可以使用不同语言开发 易于和第三方库集成, 微服务允许容易灵活的方式自动部署, 通过持续集成工具, 如Jenkins Hudson bamboo 微服务允许你利用融合最新技术 微服务只是逻辑代码, 不会和html css或其他界面混合 每个微服务都有自己的存储能力, 可以有自己的数据库, 也可以有一些数据库 缺点: 开发人员需要处理分布式系统的复杂性 多服务运维难度, 随着服务增加, 运维压力也在增加(运维压力增大) 系统部署依赖 服务间通信成本 数据一致性 系统集成测试 性能监控 项目过于臃肿，部署效率低下 当大大小小的功能模块都集中在同一项目的时候，整个项目必然会变得臃肿，让开发者难以维护。单体应用的代码越来越多，依赖的资源越来越多时，应用编译打包、部署测试一次非常耗时。 系统高可用性差，资源无法隔离 整个单体系统的各个功能模块都依赖于同样的数据库、内存等资源，一旦某个功能模块对资源使用不当，整个系统都会被拖垮。 开发成本高 早期在团队开发人员只有两三个人的时候，协作修改代码，打包部署，更新发布这完全可以控制。但是团队一旦扩张，还是按照早期的方法去开发，那如果测试阶段只要有一块功能有问题，就得重新编译打包部署。所有的开发人员又都得参与其中，效率低下，开发成本极高。 无法灵活拓展 当系统的访问量越来越大的时候，单体系统固然可以进行水平扩展，部署在多台机器上组成集群： 为什么选择SpringCloud作为微服务框架 选型依据 整体解决方案和框架的成熟度 社区热度 可维护性 学习曲线 当前各大IT公司用的微服务框架有哪些 阿里: dubbo HFS 京东: JSF 新浪: Motan 当当网: DubboX … 各微服务框架对比","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://i.codingce.com.cn/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://i.codingce.com.cn/tags/SpringCloud/"}]},{"title":"Dubbo和Zookeeper集成","slug":"Dubbo和Zookeeper集成","date":"2020-08-26T13:01:42.000Z","updated":"2020-12-13T04:41:40.422Z","comments":true,"path":"2020/08/26/Dubbo和Zookeeper集成/","link":"","permalink":"http://i.codingce.com.cn/2020/08/26/Dubbo%E5%92%8CZookeeper%E9%9B%86%E6%88%90/","excerpt":"","text":"分布式理论 什么是分布式系统？ 在《分布式系统原理与范型》一书中有如下定义：“分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像单个相关系统”； 分布式系统是由一组通过网络进行通信、为了完成共同的任务而协调工作的计算机节点组成的系统。分布式系统的出现是为了用廉价的、普通的机器完成单个计算机无法完成的计算、存储任务。其目的是利用更多的机器，处理更多的数据。 分布式系统（distributed system）是建立在网络之上的软件系统。 首先需要明确的是，只有当单个节点的处理能力无法满足日益增长的计算、存储任务的时候，且硬件的提升（加内存、加磁盘、使用更好的CPU）高昂到得不偿失的时候，应用程序也不能进一步优化的时候，才需要考虑分布式系统。因为，分布式系统要解决的问题本身就是和单机系统一样的，而由于分布式系统多节点、通过网络通信的拓扑结构，会引入很多单机系统没有的问题，为了解决这些问题又会引入更多的机制、协议，带来更多的问题。。。 Dubbo文档 随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，急需一个治理系统确保架构有条不紊的演进。 在Dubbo的官网文档有这样一张图 单一应用架构 当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。 适用于小型网站，小型管理系统，将所有功能都部署到一个功能里，简单易用。 缺点： 性能扩展比较难 协同开发问题 不利于升级维护 垂直应用架构 当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。 通过切分业务来实现各个模块独立部署，降低了维护和部署的难度，团队各司其职更易管理，性能扩展也更方便，更有针对性。 缺点：公用模块无法重复利用，开发性的浪费 分布式服务架构 当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。 流动计算架构 当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)[ Service Oriented Architecture]是关键。 什么是RPC RPC【Remote Procedure Call】是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。 也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数/方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。为什么要用RPC呢？就是无法在一个进程内，甚至一个计算机内通过本地调用的方式完成的需求，比如不同的系统间的通讯，甚至不同的组织间的通讯，由于计算能力需要横向扩展，需要在多台机器组成的集群上部署应用。RPC就是要像调用本地的函数一样去调远程函数； 推荐阅读文章：https://www.jianshu.com/p/2accc2840a1b RPC基本原理 步骤解析： RPC两个核心模块：通讯，序列化。 测试环境搭建 Dubbo Apache Dubbo |ˈdʌbəʊ| 是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。 dubbo官网 http://dubbo.apache.org/zh-cn/index.html 1.了解Dubbo的特性 2.查看官方文档 dubbo基本概念 服务提供者（Provider）：暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。 服务消费者（Consumer）：调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 注册中心（Registry）：注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者 监控中心（Monitor）：服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心 调用关系说明 服务容器负责启动，加载，运行服务提供者。 服务提供者在启动时，向注册中心注册自己提供的服务。 服务消费者在启动时，向注册中心订阅自己所需的服务。 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。 Dubbo环境搭建 点进dubbo官方文档，推荐使用Zookeeper 注册中心 什么是zookeeper呢？可以查看官方文档 Window下安装zookeeper 下载zookeeper ：地址， 下载3.4.14 ， 最新版！解压zookeeper 运行/bin/zkServer.cmd ，初次运行会报错，没有zoo.cfg配置文件； 可能遇到问题：闪退 ! 解决方案：编辑zkServer.cmd文件末尾添加pause 。这样运行出错就不会退出，会提示错误信息，方便找到原因。 修改zoo.cfg配置文件 将conf文件夹下面的zoo_sample.cfg复制一份改名为zoo.cfg即可。 注意几个重要位置： dataDir=./ 临时数据存储的目录（可写相对路径） clientPort=2181 zookeeper的端口号 修改完成后再次启动zookeeper 使用zkCli.cmd测试 ls /：列出zookeeper根下保存的所有节点 [zk: 127.0.0.1:2181(CONNECTED) 4] ls / [zookeeper] create –e /xzMhehe 123：创建一个xzMhehe节点，值为123 get /xzMhehe：获取/xzMhehe节点的值 window下安装dubbo-admin dubbo本身并不是一个服务软件。它其实就是一个jar包，能够帮你的java程序连接到zookeeper，并利用zookeeper消费、提供服务。 但是为了让用户更好的管理监控众多的dubbo服务，官方提供了一个可视化的监控程序dubbo-admin，不过这个监控即使不装也不影响使用。 这里来安装一下： 下载dubbo-admin 地址 ：https://github.com/apache/dubbo-admin/tree/master 解压进入目录 修改 dubbo-admin\\src\\main\\resources \\application.properties 指定zookeeper地址 12345678910server.port=7001spring.velocity.cache=falsespring.velocity.charset=UTF-8spring.velocity.layout-url=/templates/default.vmspring.messages.fallback-to-system-locale=falsespring.messages.basename=i18n/messagespring.root.password=rootspring.guest.password=guestdubbo.registry.address=zookeeper://127.0.0.1:2181 在项目目录下打包dubbo-admin 1mvn clean package -Dmaven.test.skip=true 第一次打包的过程有点慢，需要耐心等待！直到成功！ 执行 dubbo-admin\\target 下的dubbo-admin-0.0.1-SNAPSHOT.jar java -jar dubbo-admin-0.0.1-SNAPSHOT.jar 【注意：zookeeper的服务一定要打开！】 执行完毕，去访问一下 http://localhost:7001/ ， 这时候需要输入登录账户和密码，都是默认的root-root； 登录成功后，查看界面 安装完成！ dubbo-admin: 是一个监控管理后台, 查看注册了哪些服务, 哪些服务被消费了 zookeeper: 注册中心 Dubbo: jar包 SpringBoot + Dubbo + zookeeper 框架搭建 启动zookeeper ！ IDEA创建一个空项目； 创建一个模块，实现服务提供者：provider-server ， 选择web依赖即可 项目创建完毕，写一个服务，比如卖票的服务； 编写接口 1234567package cn.com.codingce.service;public interface TicketService &#123; public String getTicket();&#125; 编写实现类 12345678910111213141516package cn.com.codingce.service;import org.apache.dubbo.config.annotation.Service;import org.springframework.stereotype.Component;//zooheeper服务注册与发现@Service@Component //使用了dubbo后尽量别用Service注解 使用的话 使用dubbo的service注解public class TicketServiceImpl implements TicketService &#123; @Override public String getTicket() &#123; return \"掌上编程\"; &#125;&#125; 创建一个模块，实现服务消费者：consumer-server ， 选择web依赖即可 项目创建完毕，写一个服务，比如用户的服务； 编写service 12345678910111213141516package cn.com.codingce.service;import org.apache.dubbo.config.annotation.Reference;import org.springframework.stereotype.Component;@Componentpublic class UserService &#123; @Reference private TicketService ticketService; public void buyTicket() &#123; System.out.println(\"===============\" + ticketService.getTicket()); &#125;&#125; 需求：现在的用户想使用买票的服务，这要怎么弄呢 ？ 服务提供者 将服务提供者注册到注册中心，需要整合Dubbo和zookeeper，所以需要导包 从dubbo官网进入github，看下方的帮助文档，找到dubbo-springboot，找到依赖包 123456&lt;!-- Dubbo Spring Boot Starter --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.7.3&lt;/version&gt;&lt;/dependency&gt; zookeeper的包去maven仓库下载，zkclient； 123456&lt;!-- https://mvnrepository.com/artifact/com.github.sgroschupf/zkclient --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.1&lt;/version&gt;&lt;/dependency&gt; 【新版的坑】zookeeper及其依赖包，解决日志冲突，还需要剔除日志依赖； 1234567891011121314151617181920212223&lt;!-- 引入zookeeper --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-framework&lt;/artifactId&gt; &lt;version&gt;2.12.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt; &lt;version&gt;2.12.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.4.14&lt;/version&gt; &lt;!--排除这个slf4j-log4j12--&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 在springboot配置文件中配置dubbo相关属性！ 12345678server.port=8081# 服务应用名字dubbo.application.name=provider-server# 注册中心地址dubbo.registry.address=zookeeper://127.0.0.1:2181# 哪些服务要被注册dubbo.scan.base-packages=cn.com.codingce.service 在service的实现类中配置服务注解，发布服务！注意导包问题 12345678910111213141516package cn.com.codingce.service;import org.apache.dubbo.config.annotation.Service;import org.springframework.stereotype.Component;//zooheeper服务注册与发现@Service@Component //使用了dubbo后尽量别用Service注解 使用的话 使用dubbo的service注解public class TicketServiceImpl implements TicketService &#123; @Override public String getTicket() &#123; return \"掌上编程\"; &#125;&#125; 逻辑理解 ：应用启动起来，dubbo就会扫描指定的包下带有@component注解的服务，将它发布在指定的注册中心中！ 服务消费者 导入依赖，和之前的依赖一样； 12345678910111213141516171819202122232425262728293031323334353637&lt;!--dubbo--&gt;&lt;!-- Dubbo Spring Boot Starter --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.7.3&lt;/version&gt;&lt;/dependency&gt;&lt;!--zookeeper--&gt;&lt;!-- https://mvnrepository.com/artifact/com.github.sgroschupf/zkclient --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 引入zookeeper --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-framework&lt;/artifactId&gt; &lt;version&gt;2.12.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt; &lt;version&gt;2.12.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.4.14&lt;/version&gt; &lt;!--排除这个slf4j-log4j12--&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 配置参数 123456server.port=8082# 服务应用名字dubbo.application.name=consumer-server# 注册中心地址dubbo.registry.address=zookeeper://127.0.0.1:2181 本来正常步骤是需要将服务提供者的接口打包，然后用pom文件导入，这里使用简单的方式，直接将服务的接口拿过来，路径必须保证正确，即和服务提供者相同； 完善消费者的服务类 12345678910111213141516package cn.com.codingce.service;import org.apache.dubbo.config.annotation.Reference;import org.springframework.stereotype.Component;@Componentpublic class UserService &#123; @Reference private TicketService ticketService; public void buyTicket() &#123; System.out.println(\"===============\" + ticketService.getTicket()); &#125;&#125; 测试类编写； 123456789101112131415161718192021package cn.com.codingce;import cn.com.codingce.service.UserService;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;@SpringBootTestclass ConsumerServerApplicationTests &#123; @Autowired private UserService userService; @Test void contextLoads() &#123; userService.buyTicket(); &#125;&#125; 启动测试 开启zookeeper 打开dubbo-admin实现监控【可以不用做】 开启服务者 消费者消费测试，结果： 监控中心 ： 这就是SpingBoot + dubbo + zookeeper实现分布式开发的应用，其实就是一个服务拆分的思想；","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://i.codingce.com.cn/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://i.codingce.com.cn/tags/SpringBoot/"}]},{"title":"Java流(Steam、文件(File)和IO)","slug":"Java流-Steam、文件-File-和IO","date":"2020-08-21T09:06:41.000Z","updated":"2020-12-13T04:41:40.422Z","comments":true,"path":"2020/08/21/Java流-Steam、文件-File-和IO/","link":"","permalink":"http://i.codingce.com.cn/2020/08/21/Java%E6%B5%81-Steam%E3%80%81%E6%96%87%E4%BB%B6-File-%E5%92%8CIO/","excerpt":"","text":"Java 流(Stream)、文件(File)和IO Java.io 包几乎包含了所有操作输入、输出需要的类。所有这些流类代表了输入源和输出目标。 Java.io 包中的流支持很多种格式，比如：基本类型、对象、本地化字符集等等。 一个流可以理解为一个数据的序列。输入流表示从一个源读取数据，输出流表示向一个目标写数据。 Java 为 I/O 提供了强大的而灵活的支持，使其更广泛地应用到文件传输和网络编程中。 读取控制台输入 (JDK 5 前) Java 的控制台输入由 System.in 完成。 为了获得一个绑定到控制台的字符流，你可以把 System.in 包装在一个 BufferedReader 对象中来创建一个字符流。 下面是创建 BufferedReader 的基本语法： 12BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); 从控制台读取多字符输入 从 BufferedReader 对象读取一个字符要使用 read() 方法，它的语法如下： 1int read( ) throws IOException 每次调用 read() 方法，它从输入流读取一个字符并把该字符作为整数值返回。 当流结束的时候返回 -1。该方法抛出 IOException。 下面的程序示范了用 read() 方法从控制台不断读取字符直到用户输入 “q”。 1234567891011121314151617//使用 BufferedReader 在控制台读取字符 import java.io.*; public class BRRead &#123; public static void main(String args[]) throws IOException &#123; char c; // 使用 System.in 创建 BufferedReader BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); System.out.println(\"输入字符, 按下 'q' 键退出。\"); // 读取字符 do &#123; c = (char) br.read(); System.out.println(c); &#125; while (c != 'q'); &#125;&#125; 以上实例编译运行结果如下: 123456789101112输入字符, 按下 'q' 键退出。runoobrunoobqq 从控制台读取字符串 (JDK 5 前) 从标准输入读取一个字符串需要使用 BufferedReader 的 readLine() 方法。 它的一般格式是： 1String readLine( ) throws IOException 下面的程序读取和显示字符行直到你输入了单词&quot;end&quot;。 12345678910111213141516//使用 BufferedReader 在控制台读取字符import java.io.*; public class BRReadLines &#123; public static void main(String args[]) throws IOException &#123; // 使用 System.in 创建 BufferedReader BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String str; System.out.println(\"Enter lines of text.\"); System.out.println(\"Enter 'end' to quit.\"); do &#123; str = br.readLine(); System.out.println(str); &#125; while (!str.equals(\"end\")); &#125;&#125; 以上实例编译运行结果如下: 12345678Enter lines of text.Enter 'end' to quit.This is line oneThis is line oneThis is line twoThis is line twoendend JDK 5 后的版本我们也可以使用 Java Scanner 类来获取控制台的输入 读写文件 如前所述，一个流被定义为一个数据序列。输入流用于从源读取数据，输出流用于向目标写数据。 下图是一个描述输入流和输出流的类层次图。 下面将要讨论的两个重要的流是 FileInputStream 和 FileOutputStream： FileInputStream 该流用于从文件读取数据，它的对象可以用关键字 new 来创建。 有多种构造方法可用来创建对象。 可以使用字符串类型的文件名来创建一个输入流对象来读取文件： 1InputStream f = new FileInputStream(\"C:/java/hello\"); 也可以使用一个文件对象来创建一个输入流对象来读取文件。我们首先得使用 File() 方法来创建一个文件对象： 12File f = new File(\"C:/java/hello\");InputStream out = new FileInputStream(f); 创建了InputStream对象，就可以使用下面的方法来读取流或者进行其他的流操作。 序号 方法及描述 1 public void close() throws IOException{} 关闭此文件输入流并释放与此流有关的所有系统资源。抛出IOException异常。 2 protected void finalize()throws IOException {} 这个方法清除与该文件的连接。确保在不再引用文件输入流时调用其 close 方法。抛出IOException异常。 3 public int read(int r)throws IOException{} 这个方法从 InputStream 对象读取指定字节的数据。返回为整数值。返回下一字节数据，如果已经到结尾则返回-1。 4 public int read(byte[] r) throws IOException{} 这个方法从输入流读取r.length长度的字节。返回读取的字节数。如果是文件结尾则返回-1。 5 public int available() throws IOException{} 返回下一次对此输入流调用的方法可以不受阻塞地从此输入流读取的字节数。返回一个整数值。 FileOutputStream 该类用来创建一个文件并向文件中写数据。 如果该流在打开文件进行输出前，目标文件不存在，那么该流会创建该文件。 有两个构造方法可以用来创建 FileOutputStream 对象。 使用字符串类型的文件名来创建一个输出流对象： 1OutputStream f = new FileOutputStream(\"C:/java/hello\") 也可以使用一个文件对象来创建一个输出流来写文件。我们首先得使用File()方法来创建一个文件对象： 12File f = new File(\"C:/java/hello\");OutputStream f = new FileOutputStream(f); 序号 方法及描述 1 public void close() throws IOException{} 关闭此文件输入流并释放与此流有关的所有系统资源。抛出IOException异常。 2 protected void finalize()throws IOException {} 这个方法清除与该文件的连接。确保在不再引用文件输入流时调用其 close 方法。抛出IOException异常。 3 public void write(int w)throws IOException{} 这个方法把指定的字节写到输出流中。 4 public int read(byte[] r) throws IOException{} 这个方法从输入流读取r.length长度的字节。返回读取的字节数。如果是文件结尾则返回-1。 5 public void write(byte[] w) 把指定数组中w.length长度的字节写到OutputStream中。 下面是一个演示 InputStream 和 OutputStream 用法的例子： 123456789101112131415161718192021222324import java.io.*; public class fileStreamTest &#123; public static void main(String args[]) &#123; try &#123; byte bWrite[] = &#123; 11, 21, 3, 40, 5 &#125;; OutputStream os = new FileOutputStream(\"test.txt\"); for (int x = 0; x &lt; bWrite.length; x++) &#123; os.write(bWrite[x]); // writes the bytes &#125; os.close(); InputStream is = new FileInputStream(\"test.txt\"); int size = is.available(); for (int i = 0; i &lt; size; i++) &#123; System.out.print((char) is.read() + \" \"); &#125; is.close(); &#125; catch (IOException e) &#123; System.out.print(\"Exception\"); &#125; &#125;&#125; 上面的程序首先创建文件test.txt，并把给定的数字以二进制形式写进该文件，同时输出到控制台上。 以上代码由于是二进制写入，可能存在乱码，你可以使用以下代码实例来解决乱码问题： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//文件名 :fileStreamTest2.javaimport java.io.*; public class fileStreamTest2 &#123; public static void main(String[] args) throws IOException &#123; File f = new File(\"a.txt\"); FileOutputStream fop = new FileOutputStream(f); // 构建FileOutputStream对象,文件不存在会自动新建 OutputStreamWriter writer = new OutputStreamWriter(fop, \"UTF-8\"); // 构建OutputStreamWriter对象,参数可以指定编码,默认为操作系统默认编码,windows上是gbk writer.append(\"中文输入\"); // 写入到缓冲区 writer.append(\"\\r\\n\"); // 换行 writer.append(\"English\"); // 刷新缓存冲,写入到文件,如果下面已经没有写入的内容了,直接close也会写入 writer.close(); // 关闭写入流,同时会把缓冲区内容写入文件,所以上面的注释掉 fop.close(); // 关闭输出流,释放系统资源 FileInputStream fip = new FileInputStream(f); // 构建FileInputStream对象 InputStreamReader reader = new InputStreamReader(fip, \"UTF-8\"); // 构建InputStreamReader对象,编码与写入相同 StringBuffer sb = new StringBuffer(); while (reader.ready()) &#123; sb.append((char) reader.read()); // 转成char加到StringBuffer对象中 &#125; System.out.println(sb.toString()); reader.close(); // 关闭读取流 fip.close(); // 关闭输入流,释放系统资源 &#125;&#125; Java Scanner 类 java.util.Scanner 是 Java5 的新特征，我们可以通过 Scanner 类来获取用户的输入。 下面是创建 Scanner 对象的基本语法： 1Scanner s = new Scanner(System.in); 接下来我们演示一个最简单的数据输入，并通过 Scanner 类的 next() 与 nextLine() 方法获取输入的字符串，在读取前我们一般需要 使用 hasNext 与 hasNextLine 判断是否还有输入的数据： 使用 next 方法： 1234567891011121314151617import java.util.Scanner; public class ScannerDemo &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); // 从键盘接收数据 // next方式接收字符串 System.out.println(\"next方式接收：\"); // 判断是否还有输入 if (scan.hasNext()) &#123; String str1 = scan.next(); System.out.println(\"输入的数据为：\" + str1); &#125; scan.close(); &#125;&#125; 执行以上程序输出结果为： 12345$ javac ScannerDemo.java$ java ScannerDemonext方式接收：runoob com输入的数据为：runoob 可以看到 com 字符串并未输出，接下来我们看 nextLine。 使用 nextLine 方法： 1234567891011121314151617import java.util.Scanner; public class ScannerDemo &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); // 从键盘接收数据 // nextLine方式接收字符串 System.out.println(\"nextLine方式接收：\"); // 判断是否还有输入 if (scan.hasNextLine()) &#123; String str2 = scan.nextLine(); System.out.println(\"输入的数据为：\" + str2); &#125; scan.close(); &#125;&#125; 执行以上程序输出结果为： 12345$ javac ScannerDemo.java$ java ScannerDemonextLine方式接收：runoob com输入的数据为：runoob com 可以看到 com 字符串输出。 next() 与 nextLine() 区别 next(): 一定要读取到有效字符后才可以结束输入。 对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。 只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。 next() 不能得到带有空格的字符串。 nextLine()： 以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。 可以获得空白。 如果要输入 int 或 float 类型的数据，在 Scanner 类中也有支持，但是在输入之前最好先使用 hasNextXxx() 方法进行验证，再使用 nextXxx() 来读取： 12345678910111213141516171819202122232425262728293031import java.util.Scanner; public class ScannerDemo &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); // 从键盘接收数据 int i = 0; float f = 0.0f; System.out.print(\"输入整数：\"); if (scan.hasNextInt()) &#123; // 判断输入的是否是整数 i = scan.nextInt(); // 接收整数 System.out.println(\"整数数据：\" + i); &#125; else &#123; // 输入错误的信息 System.out.println(\"输入的不是整数！\"); &#125; System.out.print(\"输入小数：\"); if (scan.hasNextFloat()) &#123; // 判断输入的是否是小数 f = scan.nextFloat(); // 接收小数 System.out.println(\"小数数据：\" + f); &#125; else &#123; // 输入错误的信息 System.out.println(\"输入的不是小数！\"); &#125; scan.close(); &#125;&#125; 执行以上程序输出结果为： 123456$ javac ScannerDemo.java$ java ScannerDemo输入整数：12整数数据：12输入小数：1.2小数数据：1.2","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://i.codingce.com.cn/tags/Java/"}]},{"title":"Swagger","slug":"Swagger","date":"2020-08-20T01:13:15.000Z","updated":"2020-12-13T04:41:40.438Z","comments":true,"path":"2020/08/20/Swagger/","link":"","permalink":"http://i.codingce.com.cn/2020/08/20/Swagger/","excerpt":"","text":"项目集成Swagger 了解Swagger的概念及作用 掌握在项目中集成Swagger自动生成API文档 Swagger简介 前后端分离 前端 -&gt; 前端控制层、视图层 后端 -&gt; 后端控制层、服务层、数据访问层 前后端通过API进行交互 前后端相对独立且松耦合 产生的问题 前后端集成，前端或者后端无法做到“及时协商，尽早解决”，最终导致问题集中爆发 解决方案 首先定义schema [ 计划的提纲 ]，并实时跟踪最新的API，降低集成风险 Swagger 号称世界上最流行的API框架 Restful Api 文档在线自动生成器 =&gt; API 文档 与API 定义同步更新 直接运行，在线测试API 支持多种语言 （如：Java，PHP等） 官网：https://swagger.io/ SpringBoot集成Swagger SpringBoot集成Swagger =&gt; springfox，两个jar包 Springfox-swagger2 swagger-springmvc 使用Swagger 要求：jdk 1.8 + 否则swagger2无法运行 步骤： 新建一个SpringBoot-web项目 添加Maven依赖 123456789101112&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 --&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt; 编写HelloController，测试确保运行成功！ 要使用Swagger，需要编写一个配置类-SwaggerConfig来配置 Swagger 1234@Configuration //配置类@EnableSwagger2// 开启Swagger2的自动配置public class SwaggerConfig &#123; &#125; 访问测试 ：http://localhost:8080/swagger-ui.html ，可以看到swagger的界面； 配置Swagger Swagger实例Bean是Docket，所以通过配置Docket实例来配置Swaggger. 1234@Bean //配置docket以配置Swagger具体参数public Docket docket() &#123; return new Docket(DocumentationType.SWAGGER_2);&#125; 可以通过apiInfo()属性配置文档信息 12345678910111213//配置swaagger信息 private ApiInfo apiInfo() &#123; //作者信息 Contact contact = new Contact(\"马鑫泽\", \"https://i.codingce.com.cn\", \"codingce@gmail.com\"); return new ApiInfo(\"掌上编程\", \"即使再小的帆也能远航\", \"1.0\", \"https://i.codingce.com.cn\", contact, \"Apache 2.0\", \"http://www.apache.org/licenses/LICENSE-2.0\", new ArrayList()); &#125; Docket 实例关联上 apiInfo() 1234@Beanpublic Docket docket() &#123; return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo());&#125; 重启项目，访问测试 http://localhost:8080/swagger-ui.html 看下效果； 配置扫描接口 构建Docket时通过select()方法配置怎么扫描接口. 12345678@Beanpublic Docket docket() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select()// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口 .apis(RequestHandlerSelectors.basePackage(\"com.kuang.swagger.controller\")) .build();&#125; 重启项目测试，由于我们配置根据包的路径扫描接口，所以我们只能看到一个类 除了通过包路径配置扫描接口外，还可以通过配置其他方式扫描接口，这里注释一下所有的配置方式： 1234567any() // 扫描所有，项目中的所有接口都会被扫描到none() // 不扫描接口// 通过方法上的注解扫描，如withMethodAnnotation(GetMapping.class)只扫描get请求withMethodAnnotation(final Class&lt;? extends Annotation&gt; annotation)// 通过类上的注解扫描，如.withClassAnnotation(Controller.class)只扫描有controller注解的类中的接口withClassAnnotation(final Class&lt;? extends Annotation&gt; annotation)basePackage(final String basePackage) // 根据包路径扫描接口 除此之外，我们还可以配置接口扫描过滤： 12345678910@Beanpublic Docket docket() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select()// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口 .apis(RequestHandlerSelectors.basePackage(\"com.kuang.swagger.controller\")) // 配置如何通过path过滤,即这里只扫描请求以/kuang开头的接口 .paths(PathSelectors.ant(\"/kuang/**\")) .build();&#125; 这里的可选值还有 1234any() // 任何请求都扫描none() // 任何请求都不扫描regex(final String pathRegex) // 通过正则表达式控制ant(final String antPattern) // 通过ant()控制 配置Swagger开关 通过enable()方法配置是否启用swagger，如果是false，swagger将不能在浏览器中访问了 1234567891011@Beanpublic Docket docket() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .enable(false) //配置是否启用Swagger，如果是false，在浏览器将无法访问 .select()// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口 .apis(RequestHandlerSelectors.basePackage(\"com.kuang.swagger.controller\")) // 配置如何通过path过滤,即这里只扫描请求以/kuang开头的接口 .paths(PathSelectors.ant(\"/kuang/**\")) .build();&#125; 如何动态配置当项目处于test、dev环境时显示swagger，处于prod时不显示？ 1234567891011121314151617@Beanpublic Docket docket(Environment environment) &#123; // 设置要显示swagger的环境 Profiles of = Profiles.of(\"dev\", \"test\"); // 判断当前是否处于该环境 // 通过 enable() 接收此参数判断是否要显示 boolean b = environment.acceptsProfiles(of); return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .enable(b) //配置是否启用Swagger，如果是false，在浏览器将无法访问 .select()// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口 .apis(RequestHandlerSelectors.basePackage(\"com.kuang.swagger.controller\")) // 配置如何通过path过滤,即这里只扫描请求以/kuang开头的接口 .paths(PathSelectors.ant(\"/kuang/**\")) .build();&#125; 可以在项目中增加一个dev的配置文件查看效果！ 配置API分组 如果没有配置分组，默认是default。通过groupName()方法即可配置分组： 12345678return new Docket(DocumentationType.SWAGGER_2) //用的自己的 return new Docket(DocumentationType.SWAGGER_2); 默认 .apiInfo(apiInfo()) //enable 是否启动Swagger, 如果false则Swagger不能再浏览器中访问 //.enable(false) .groupName(\"掌上编程\") .enable(flag) .select() 如何配置多个分组？配置多个分组只需要配置多个docket即可： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class SwaggerConfig &#123; @Bean public Docket docket1() &#123; return new Docket(DocumentationType.SWAGGER_2) .groupName(\"A\"); &#125; @Bean public Docket docket2() &#123; return new Docket(DocumentationType.SWAGGER_2) .groupName(\"B\"); &#125; @Bean public Docket docket3() &#123; return new Docket(DocumentationType.SWAGGER_2) .groupName(\"C\"); &#125; @Bean public Docket docket4() &#123; return new Docket(DocumentationType.SWAGGER_2) .groupName(\"D\"); &#125; @Bean //配置docket以配置Swagger具体参数 链式编程 public Docket docket(Environment environment) &#123; //设置要显示的Swagger环境 Profiles profiles = Profiles.of(\"dev\", \"test\"); //获取项目环境 Environment environment.acceptsProfiles(profiles);判断是否处于自己设定的环境中 boolean flag = environment.acceptsProfiles(profiles); return new Docket(DocumentationType.SWAGGER_2) //用的自己的 return new Docket(DocumentationType.SWAGGER_2); 默认 .apiInfo(apiInfo()) //enable 是否启动Swagger, 如果false则Swagger不能再浏览器中访问 //.enable(false) .groupName(\"掌上编程\") .enable(flag) .select() //RequestHandlerSelectors配置要扫面接口的方式 //basePackage 指定要扫描的包 .apis(RequestHandlerSelectors.basePackage(\"cn.com.codingce.controller\")) //any() 扫描全部 //no() 都不扫描 //withClassAnnotation :扫描类上的注解, 参数是一个注解反射的对象 //withMethodAnnotation :扫描方法上的注解 .apis(RequestHandlerSelectors.basePackage(\"cn.com.codingce.controller\")) //paths() 过滤路径 //.paths(PathSelectors.ant(\"/codingce/**\")) .build();//build工厂模式 &#125; 常用注解 Swagger的所有注解定义在io.swagger.annotations包下 下面列一些经常用到的，未列举出来的可以另行查阅说明： Swagger注解 简单说明 @Api(tags = “xxx模块说明”) 作用在模块类上 @ApiOperation(“xxx接口说明”) 作用在接口方法上 @ApiModel(“xxxPOJO说明”) 作用在模型类上：如VO、BO @ApiModelProperty(value = “xxx属性说明”,hidden = true) 作用在类方法和属性上，hidden设置为true可以隐藏该属性 @ApiParam(“xxx参数说明”) 作用在参数、方法和字段上，类似@ApiModelProperty 也可以给请求的接口配置一些注释 1234567891011121314151617181920212223242526272829//Operation接口@ApiOperation(\"Hello控制类\")@RestControllerpublic class HelloCobtroller &#123; @RequestMapping(value = \"/hello\") public String hello() &#123; return \"hello\"; &#125; @PostMapping(\"/myuser\") public User user() &#123; return new User(); &#125; //Operation接口, 不是放在类上, 是方法 @ApiOperation(\"Hello控制类\") @RequestMapping(value = \"/hello2\") public String hello2() &#123; return \"hello\"; &#125; @ApiOperation(\"Hello控制类\") @RequestMapping(value = \"/hello3\") public String hello3(@ApiParam(\"用户名\") String username) &#123; return \"hello\" + username; &#125;&#125; 拓展：其他皮肤 默认的 访问 http://localhost:8080/swagger-ui.html 12345&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt; bootstrap-ui 访问 http://localhost:8080/doc.html 123456&lt;!-- 引入swagger-bootstrap-ui包 /doc.html--&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;swagger-bootstrap-ui&lt;/artifactId&gt; &lt;version&gt;1.9.1&lt;/version&gt;&lt;/dependency&gt; Layui-ui 访问 http://localhost:8080/docs.html 123456&lt;!-- 引入swagger-ui-layer包 /docs.html--&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.caspar-chen&lt;/groupId&gt; &lt;artifactId&gt;swagger-ui-layer&lt;/artifactId&gt; &lt;version&gt;1.1.3&lt;/version&gt;&lt;/dependency&gt; mg-ui 访问 http://localhost:8080/document.html 123456&lt;!-- 引入swagger-ui-layer包 /document.html--&gt;&lt;dependency&gt; &lt;groupId&gt;com.zyplayer&lt;/groupId&gt; &lt;artifactId&gt;swagger-mg-ui&lt;/artifactId&gt; &lt;version&gt;1.0.6&lt;/version&gt;&lt;/dependency&gt;","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://i.codingce.com.cn/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://i.codingce.com.cn/tags/SpringBoot/"}]},{"title":"shiro","slug":"shiro","date":"2020-08-18T06:47:51.000Z","updated":"2020-12-13T04:41:40.438Z","comments":true,"path":"2020/08/18/shiro/","link":"","permalink":"http://i.codingce.com.cn/2020/08/18/shiro/","excerpt":"","text":"什么是shiro Apache Shiro是一个强大且易用的Java安全框架,执行身份验证、授权、密码和会话管理。使用Shiro的易于理解的API,您可以快速、轻松地获得任何应用程序,从最小的移动应用程序到最大的网络和企业应用程序。 主要功能 三个核心组件：Subject, SecurityManager 和 Realms. Subject：即“当前操作用户”。但是，在Shiro中，Subject这一概念并不仅仅指人，也可以是第三方进程、后台帐户（Daemon Account）或其他类似事物。它仅仅意味着“当前跟软件交互的东西”。Subject代表了当前用户的安全操作，SecurityManager则管理所有用户的安全操作。 SecurityManager：它是Shiro框架的核心，典型的Facade模式，Shiro通过SecurityManager来管理内部组件实例，并通过它来提供安全管理的各种服务。 Realm： Realm充当了Shiro与应用安全数据间的“桥梁”或者“连接器”。也就是说，当对用户执行认证（登录）和授权（访问控制）验证时，Shiro会从应用配置的Realm中查找用户及其权限信息。从这个意义上讲，Realm实质上是一个安全相关的DAO：它封装了数据源的连接细节，并在需要时将相关数据提供给Shiro。当配置Shiro时，你必须至少指定一个Realm，用于认证和（或）授权。配置多个Realm是可以的，但是至少需要一个。 Shiro内置了可以连接大量安全数据源（又名目录）的Realm，如LDAP、关系数据库（JDBC）、类似INI的文本配置资源以及属性文件等。如果缺省的Realm不能满足需求，你还可以插入代表自定义数据源的自己的Realm实现。 使用步骤 首先去github下载shiro项目 https://github.com/apache/shiro 进入项目打开samples文件夹 分析quickstart项目 新建项目springboot-08-shiro 编写log4j.properties 123456789101112131415161718log4j.rootLogger=INFO, stdoutlog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%d %p [%c] - %m %n# General Apache librarieslog4j.logger.org.apache=WARN# Springlog4j.logger.org.springframework=WARN# Default Shiro logginglog4j.logger.org.apache.shiro=INFO# Disable verbose logginglog4j.logger.org.apache.shiro.util.ThreadContext=WARNlog4j.logger.org.apache.shiro.cache.ehcache.EhCache=WARN shiro.ini 123456789101112131415161718192021222324252627[users]# user 'root' with password 'secret' and the 'admin' roleroot = secret, admin# user 'guest' with the password 'guest' and the 'guest' roleguest = guest, guest# user 'presidentskroob' with password '12345' (\"That's the same combination on# my luggage!!!\" ;)), and role 'president'presidentskroob = 12345, president# user 'darkhelmet' with password 'ludicrousspeed' and roles 'darklord' and 'schwartz'darkhelmet = ludicrousspeed, darklord, schwartz# user 'lonestarr' with password 'vespa' and roles 'goodguy' and 'schwartz'lonestarr = vespa, goodguy, schwartz# -----------------------------------------------------------------------------# Roles with assigned permissions# # Each line conforms to the format defined in the# org.apache.shiro.realm.text.TextConfigurationRealm#setRoleDefinitions JavaDoc# -----------------------------------------------------------------------------[roles]# 'admin' role has all permissions, indicated by the wildcard '*'admin = *# The 'schwartz' role can do anything (*) with any lightsaber:schwartz = lightsaber:*# The 'goodguy' role is allowed to 'drive' (action) the winnebago (type) with# license plate 'eagle5' (instance specific id)goodguy = winnebago:drive:eagle5 Quickstart.java 官方的例子，里面存在过时的类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.*;import org.apache.shiro.ini.IniSecurityManagerFactory;import org.apache.shiro.mgt.SecurityManager;import org.apache.shiro.session.Session;import org.apache.shiro.subject.Subject;import org.apache.shiro.lang.util.Factory;import org.slf4j.Logger;import org.slf4j.LoggerFactory;/** * Simple Quickstart application showing how to use Shiro's API. * * @since 0.9 RC2 */public class Quickstart &#123; private static final transient Logger log = LoggerFactory.getLogger(Quickstart.class); public static void main(String[] args) &#123; // The easiest way to create a Shiro SecurityManager with configured // realms, users, roles and permissions is to use the simple INI config. // We'll do that by using a factory that can ingest a .ini file and // return a SecurityManager instance: // Use the shiro.ini file at the root of the classpath // (file: and url: prefixes load from files and urls respectively): Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(\"classpath:shiro.ini\"); SecurityManager securityManager = factory.getInstance(); // for this simple example quickstart, make the SecurityManager // accessible as a JVM singleton. Most applications wouldn't do this // and instead rely on their container configuration or web.xml for // webapps. That is outside the scope of this simple quickstart, so // we'll just do the bare minimum so you can continue to get a feel // for things. SecurityUtils.setSecurityManager(securityManager); // Now that a simple Shiro environment is set up, let's see what you can do: // get the currently executing user: Subject currentUser = SecurityUtils.getSubject(); // Do some stuff with a Session (no need for a web or EJB container!!!) Session session = currentUser.getSession(); session.setAttribute(\"someKey\", \"aValue\"); String value = (String) session.getAttribute(\"someKey\"); if (value.equals(\"aValue\")) &#123; log.info(\"Retrieved the correct value! [\" + value + \"]\"); &#125; // let's login the current user so we can check against roles and permissions: if (!currentUser.isAuthenticated()) &#123; UsernamePasswordToken token = new UsernamePasswordToken(\"lonestarr\", \"vespa\"); token.setRememberMe(true); try &#123; currentUser.login(token); &#125; catch (UnknownAccountException uae) &#123; log.info(\"There is no user with username of \" + token.getPrincipal()); &#125; catch (IncorrectCredentialsException ice) &#123; log.info(\"Password for account \" + token.getPrincipal() + \" was incorrect!\"); &#125; catch (LockedAccountException lae) &#123; log.info(\"The account for username \" + token.getPrincipal() + \" is locked. \" + \"Please contact your administrator to unlock it.\"); &#125; // ... catch more exceptions here (maybe custom ones specific to your application? catch (AuthenticationException ae) &#123; //unexpected condition? error? &#125; &#125; //say who they are: //print their identifying principal (in this case, a username): log.info(\"User [\" + currentUser.getPrincipal() + \"] logged in successfully.\"); //test a role: if (currentUser.hasRole(\"schwartz\")) &#123; log.info(\"May the Schwartz be with you!\"); &#125; else &#123; log.info(\"Hello, mere mortal.\"); &#125; //test a typed permission (not instance-level) if (currentUser.isPermitted(\"lightsaber:wield\")) &#123; log.info(\"You may use a lightsaber ring. Use it wisely.\"); &#125; else &#123; log.info(\"Sorry, lightsaber rings are for schwartz masters only.\"); &#125; //a (very powerful) Instance Level permission: if (currentUser.isPermitted(\"winnebago:drive:eagle5\")) &#123; log.info(\"You are permitted to 'drive' the winnebago with license plate (id) 'eagle5'. \" + \"Here are the keys - have fun!\"); &#125; else &#123; log.info(\"Sorry, you aren't allowed to drive the 'eagle5' winnebago!\"); &#125; //all done - log out! currentUser.logout(); System.exit(0); &#125;&#125; SpringBoot整合Shiro 认证 导包 12345678910111213141516171819202122232425262728293031323334353637&lt;dependencies&gt; &lt;!--shiro Subject 用户 SecurityManager 管理所有用户 Realm 连接数据 --&gt; &lt;!--shiro整合Spring的包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--thymeleaf--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 编写shiro配置类ShiroConfig 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package cn.com.codingce.config;import org.apache.shiro.spring.web.ShiroFilterFactoryBean;import org.apache.shiro.web.mgt.DefaultWebSecurityManager;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import java.util.HashMap;import java.util.LinkedHashMap;@Configurationpublic class ShiroConfig &#123; //ShiroFilterFactroyBean 第三步 @Bean public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier(\"securityManager\") DefaultWebSecurityManager webSecurityManager) &#123; ShiroFilterFactoryBean bean = new ShiroFilterFactoryBean(); //设置安全管理器 bean.setSecurityManager(webSecurityManager); //添加shiro 的内置过滤器 /** * anno 无需认证就可以访问 * authc: 必须认证才能访问 * user: 必须拥有记住我功能才能使用 * perms: 拥有对某个资源的权限才能访问 * role: 拥有某个角色权限才能访问 * // filterMap.put(\"/user/add\", \"authc\"); * // filterMap.put(\"/user/update\", \"authc\"); 支持通配符 /user/* */ HashMap&lt;String, String&gt; filterMap = new LinkedHashMap&lt;&gt;(); filterMap.put(\"/user/*\", \"authc\"); //设置登录的请求 bean.setLoginUrl(\"/toLogin\"); bean.setFilterChainDefinitionMap(filterMap); return bean; &#125; //DafaultWebSecurityManager 第二步 @Bean(name = \"securityManager\") public DefaultWebSecurityManager getDefaultWebSecurityManager(@Qualifier(\"userRealm\") UserRealm userRealm) &#123; DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); //关联UserRealm securityManager.setRealm(userRealm); return securityManager; &#125; //创建realm对象, 需要自定义 这是第一步 || @Bean(name = \"UserRealm\") 互联 @Qualifier(\"userRealm\") 与方法名一致 前面的@Bean就不用写name属性 @Bean public UserRealm userRealm() &#123; return new UserRealm(); &#125;&#125; Realm 123456789101112131415161718192021222324252627282930313233343536373839package cn.com.codingce.config;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.AuthenticationInfo;import org.apache.shiro.authc.AuthenticationToken;import org.apache.shiro.authc.SimpleAuthenticationInfo;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.authz.AuthorizationInfo;import org.apache.shiro.realm.AuthorizingRealm;import org.apache.shiro.subject.PrincipalCollection;//自定义的Realmpublic class UserRealm extends AuthorizingRealm &#123; //授权 @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; System.out.println(\"执行了授权\"); return null; &#125; //认证 @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; System.out.println(\"执行了认证\"); //用户名，密码 String name = \"root\"; String password = \"123\"; UsernamePasswordToken userToken= (UsernamePasswordToken)authenticationToken; if (!userToken.getUsername().equals(name)) &#123; return null; //UnknownAccountException &#125; //密码认证 return new SimpleAuthenticationInfo(\"\", password, \"\"); &#125;&#125; 前端页面 login.html 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;登录&lt;/h1&gt;&lt;p th:text=\"$&#123;msg&#125;\" style=\"color: red\"&gt;&lt;/p&gt;&lt;form th:action=\"@&#123;/login&#125;\"&gt; &lt;p&gt;用户名:&lt;input type=\"text\" name=\"username\" placeholder=\"请输入用户名\"&gt;&lt;/p&gt; &lt;p&gt;密码:&lt;input type=\"text\" name=\"password\" placeholder=\"请输入密码\"&gt;&lt;/p&gt; &lt;input type=\"submit\" value=\"登录\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; index.html 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;首页&lt;/h1&gt;&lt;p th:text=\"$&#123;msg&#125;\"&gt;&lt;/p&gt;&lt;a th:href=\"@&#123;/user/add&#125;\"&gt;add&lt;/a&gt;&lt;a th:href=\"@&#123;/user/update&#125;\"&gt;update&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; MyController 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package cn.com.codingce.controller;import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.IncorrectCredentialsException;import org.apache.shiro.authc.LockedAccountException;import org.apache.shiro.authc.UnknownAccountException;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.subject.Subject;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class MyController &#123; @RequestMapping(&#123;\"/\", \"/index\"&#125;) public String toIndex(Model model) &#123; model.addAttribute(\"msg\", \"helloshiro\"); return \"index\"; &#125; @RequestMapping(\"/user/add\") public String add() &#123; return \"/user/add\"; &#125; @RequestMapping(\"/user/update\") public String update() &#123; return \"/user/update\"; &#125; @RequestMapping(\"/toLogin\") public String toLogin() &#123; return \"login\"; &#125; @RequestMapping(\"/login\") public String login(String username, String password, Model model) &#123; //获取当前用户 Subject subject = SecurityUtils.getSubject(); //封装用户的登陆数据 UsernamePasswordToken token = new UsernamePasswordToken(username, password); try &#123; subject.login(token); //执行登录方法没有异常就说明ok了 return \"index\"; &#125; catch (UnknownAccountException e) &#123; //用户名不存在 model.addAttribute(\"msg\", \"用户名不存在\"); return \"login\"; &#125; catch (IncorrectCredentialsException ice) &#123; //密码错误 model.addAttribute(\"msg\", \"密码错误\"); return \"login\"; &#125; &#125;&#125; 环境搭建以及简单的认证就完成了 授权 修改ShiroConfig 12345678910111213141516171819202122232425262728293031323334@Bean public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier(\"securityManager\") DefaultWebSecurityManager webSecurityManager) &#123; ShiroFilterFactoryBean bean = new ShiroFilterFactoryBean(); //设置安全管理器 bean.setSecurityManager(webSecurityManager); //添加shiro 的内置过滤器 /** * anno 无需认证就可以访问 * authc: 必须认证才能访问 * user: 必须拥有记住我功能才能使用 * perms: 拥有对某个资源的权限才能访问 * role: 拥有某个角色权限才能访问 * // filterMap.put(\"/user/add\", \"authc\"); * // filterMap.put(\"/user/update\", \"authc\"); 支持通配符 /user/* */ HashMap&lt;String, String&gt; filterMap = new LinkedHashMap&lt;&gt;(); //授权 正常情况下, 没有授权回跳到未授权页面 filterMap.put(\"/user/add\", \"perms[user:add]\"); filterMap.put(\"/user/update\", \"perms[user:update]\"); filterMap.put(\"/user/*\", \"authc\"); //设置登录的请求 bean.setLoginUrl(\"/toLogin\"); //设置未经授权的请求 bean.setUnauthorizedUrl(\"/noauth\"); bean.setFilterChainDefinitionMap(filterMap); return bean; &#125; UserRealm 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//自定义的Realmpublic class UserRealm extends AuthorizingRealm &#123; @Autowired private UserServiceImpl userService; //授权 @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; System.out.println(\"执行了授权\"); //SimpleAuthorizationInfo SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(); info.addStringPermission(\"user:add\"); //拿到当前登录的对象 Subject subject = SecurityUtils.getSubject(); User currentUser = (User) subject.getPrincipal(); System.out.println(currentUser.toString()); //设置当前用户的权限 info.addStringPermission(currentUser.getPrems()); return info; &#125; //认证 @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; System.out.println(\"执行了认证\"); //用户名，密码 String name = \"root\"; String password = \"123\"; UsernamePasswordToken userToken= (UsernamePasswordToken)authenticationToken; //连接真实数据库 User user = userService.queryUserByName(userToken.getUsername()); System.out.println(user.toString()); if (user == null) &#123; return null; &#125;// if (!userToken.getUsername().equals(name)) &#123;// return null; //UnknownAccountException// &#125; //密码认证// return new SimpleAuthenticationInfo(\"\", password, \"\"); //连数据库 此处认证的user信息通过赋值第一个参数 为user 传递给认证 通过subject.getPrincipal()获取登录用户 return new SimpleAuthenticationInfo(user, user.getPwd(), \"\"); &#125;&#125;","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://i.codingce.com.cn/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://i.codingce.com.cn/tags/SpringBoot/"}]},{"title":"集成SpringSecurity","slug":"集成SpringSecurity","date":"2020-08-17T04:13:56.000Z","updated":"2020-12-13T04:41:40.453Z","comments":true,"path":"2020/08/17/集成SpringSecurity/","link":"","permalink":"http://i.codingce.com.cn/2020/08/17/%E9%9B%86%E6%88%90SpringSecurity/","excerpt":"","text":"SpringSecurity 安全简介 在 Web 开发中，安全一直是非常重要的一个方面。安全虽然属于应用的非功能性需求，但是应该在应用开发的初期就考虑进来。如果在应用开发的后期才考虑安全的问题，就可能陷入一个两难的境地：一方面，应用存在严重的安全漏洞，无法满足用户的要求，并可能造成用户的隐私数据被攻击者窃取；另一方面，应用的基本架构已经确定，要修复安全漏洞，可能需要对系统的架构做出比较重大的调整，因而需要更多的开发时间，影响应用的发布进程。因此，从应用开发的第一天就应该把安全相关的因素考虑进来，并在整个应用的开发过程中。 市面上存在比较有名的：Shiro，Spring Security ！ Spring Security官网介绍 Spring Security is a powerful and highly customizable authentication and access-control framework. It is the de-facto standard for securing Spring-based applications. Spring Security is a framework that focuses on providing both authentication and authorization to Java applications. Like all Spring projects, the real power of Spring Security is found in how easily it can be extended to meet custom requirements Spring Security是一个功能强大且高度可定制的身份验证和访问控制框架。它实际上是保护基于spring的应用程序的标准。 Spring Security是一个框架，侧重于为Java应用程序提供身份验证和授权。与所有Spring项目一样，Spring安全性的真正强大之处在于它可以轻松地扩展以满足定制需求 从官网的介绍中可以知道这是一个权限框架。想之前做项目是没有使用框架是怎么控制权限的？对于权限 一般会细分为功能权限，访问权限，和菜单权限。代码会写的非常的繁琐，冗余。 怎么解决之前写权限代码繁琐，冗余的问题，一些主流框架就应运而生而Spring Scecurity就是其中的一种。 Spring 是一个非常流行和成功的 Java 应用开发框架。Spring Security 基于 Spring 框架，提供了一套 Web 应用安全性的完整解决方案。一般来说，Web 应用的安全性包括用户认证（Authentication）和用户授权（Authorization）两个部分。用户认证指的是验证某个用户是否为系统中的合法主体，也就是说用户能否访问该系统。用户认证一般要求用户提供用户名和密码。系统通过校验用户名和密码来完成认证过程。用户授权指的是验证某个用户是否有权限执行某个操作。在一个系统中，不同用户所具有的权限是不同的。比如对一个文件来说，有的用户只能进行读取，而有的用户可以进行修改。一般来说，系统会为不同的用户分配不同的角色，而每个角色则对应一系列的权限。 对于上面提到的两种应用情景，Spring Security 框架都有很好的支持。在用户认证方面，Spring Security 框架支持主流的认证方式，包括 HTTP 基本认证、HTTP 表单验证、HTTP 摘要认证、OpenID 和 LDAP 等。在用户授权方面，Spring Security 提供了基于角色的访问控制和访问控制列表（Access Control List，ACL），可以对应用中的领域对象进行细粒度的控制。 实战测试 实验环境搭建 新建一个初始的springboot项目web模块，thymeleaf模块 导入静态资源 controller跳转！ 1234567891011121314151617181920212223242526272829303132333435package cn.com.codingce.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class RouterController &#123; @RequestMapping(&#123;\"/\", \"/index\"&#125;) public String index() &#123; return \"index\"; &#125; @RequestMapping(\"/tologin\") public String toLogin() &#123; return \"views/login\"; &#125; @RequestMapping(\"/level1/&#123;id&#125;\") public String leve1(@PathVariable int id) &#123; return \"views/level1/\" + id; &#125; @RequestMapping(\"/level2/&#123;id&#125;\") public String leve2(@PathVariable int id) &#123; return \"views/level2/\" + id; &#125; @RequestMapping(\"/level3/&#123;id&#125;\") public String leve3(@PathVariable int id) &#123; return \"views/level3/\" + id; &#125;&#125; 认识SpringSecurity Spring Security 是针对Spring项目的安全框架，也是Spring Boot底层安全模块默认的技术选型，他可以实现强大的Web安全控制，对于安全控制，仅需要引入 spring-boot-starter-security 模块，进行少量的配置，即可实现强大的安全管理！ 记住几个类： WebSecurityConfigurerAdapter：自定义Security策略 AuthenticationManagerBuilder：自定义认证策略 @EnableWebSecurity：开启WebSecurity模式 Spring Security的两个主要目标是 “认证” 和 “授权”（访问控制）。 “认证”（Authentication） 身份验证是关于验证您的凭据，如用户名/用户ID和密码，以验证您的身份。 身份验证通常通过用户名和密码完成，有时与身份验证因素结合使用。 “授权” （Authorization） 授权发生在系统成功验证您的身份后，最终会授予您访问资源（如信息，文件，数据库，资金，位置，几乎任何内容）的完全权限。 这个概念是通用的，而不是只在Spring Security 中存在。 认证和授权 目前，的测试环境，是谁都可以访问的，使用 Spring Security 增加上认证和授权的功能 引入 Spring Security 模块 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; 编写 Spring Security 配置类 参考官网：https://spring.io/projects/spring-security 查看自己项目中的版本，找到对应的帮助文档： https://docs.spring.io/spring-security/site/docs/5.3.0.RELEASE/reference/html5 #servlet-applications 8.16.4 编写基础配置类 12345678910111213141516171819202122232425package cn.com.codingce.config;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import javax.sql.DataSource;//AOP 的好处 横切@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Autowired DataSource dataSource; //链式编程 //授权 @Override protected void configure(HttpSecurity http) throws Exception &#123; &#125;&#125; 定制请求的授权规则 123456789@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; // 定制请求的授权规则 // 首页所有人可以访问 http.authorizeRequests().antMatchers(\"/\").permitAll() .antMatchers(\"/level1/**\").hasRole(\"vip1\") .antMatchers(\"/level2/**\").hasRole(\"vip2\") .antMatchers(\"/level3/**\").hasRole(\"vip3\");&#125; 测试一下：发现除了首页都进不去了！因为目前没有登录的角色，因为请求需要登录的角色拥有对应的权限才可以！ 在configure()方法中加入以下配置，开启自动配置的登录功能！ 1234// 开启自动配置的登录功能// /login 请求来到登录页// /login?error 重定向到这里表示登录失败http.formLogin(); 测试一下：发现，没有权限的时候，会跳转到登录的页面！ 查看刚才登录页的注释信息； 可以定义认证规则，重写configure(AuthenticationManagerBuilder auth)方法 123456789101112//定义认证规则@Overrideprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; //在内存中定义，也可以在jdbc中去拿.... auth.inMemoryAuthentication() .withUser(\"xzM\").password(\"123456\").roles(\"vip2\",\"vip3\") .and() .withUser(\"root\").password(\"123456\").roles(\"vip1\",\"vip2\",\"vip3\") .and() .withUser(\"guest\").password(\"123456\").roles(\"vip1\",\"vip2\");&#125; 测试，可以使用这些账号登录进行测试！发现会报错！ There is no PasswordEncoder mapped for the id “null” 原因，要将前端传过来的密码进行某种方式加密，否则就无法登录，修改代码 我选择这BCryptPasswordEncoder加密 123456auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder()) .withUser(\"xzM\").password(new BCryptPasswordEncoder().encode(\"123456\")).roles(\"vip2\",\"vip3\") .and() .withUser(\"root\").password(new BCryptPasswordEncoder().encode(\"123456\")).roles(\"vip1\",\"vip2\",\"vip3\") .and() .withUser(\"guest\").password(new BCryptPasswordEncoder().encode(\"123456\")).roles(\"vip1\",\"vip2\"); 权限控制和注销 开启自动配置的注销的功能 12//注销 开启注销功能 跳转首页 .logoutSuccessUrl(\"/\"); 注销成功来到首页http.logout().logoutSuccessUrl(\"/\"); 在前端，增加一个注销的按钮，index.html 导航栏中 1&lt;li sec:authorize=\"isAuthenticated()\"&gt;&lt;a th:href=\"@&#123;/logout&#125;\"&gt;注销&lt;/a&gt;&lt;/li&gt; 现在又来一个需求：用户没有登录的时候，导航栏上只显示登录按钮，用户登录之后，导航栏可以显示登录的用户信息及注销按钮！还有就是，比如kuangshen这个用户，它只有 vip2，vip3功能，那么登录则只显示这两个功能，而vip1的功能菜单不显示！这个就是真实的网站情况了！该如何做呢？ 需要结合thymeleaf中的一些功能 sec：authorize=“isAuthenticated()”:是否认证登录！来显示不同的页面 Maven依赖： 123456&lt;!-- https://mvnrepository.com/artifact/org.thymeleaf.extras/thymeleaf-extras-springsecurity4 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt; &lt;version&gt;3.0.4.RELEASE&lt;/version&gt;&lt;/dependency&gt; 修改 前端页面、导入命名空间 1xmlns:sec=\"http://www.thymeleaf.org/thymeleaf-extras-springsecurity5\" 修改导航栏，增加认证判断 12345&lt;ul class=\"nav navbar-nav navbar-right\"&gt; &lt;li&gt;&lt;a th:href=\"@&#123;/&#125;\"&gt;主页&lt;/a&gt;&lt;/li&gt; &lt;li sec:authorize=\"!isAuthenticated()\"&gt;&lt;a th:href=\"@&#123;/tologin&#125;\"&gt;登录&lt;/a&gt;&lt;/li&gt; &lt;li sec:authorize=\"isAuthenticated()\"&gt;&lt;a th:href=\"@&#123;/logout&#125;\"&gt;注销&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 如果注销404了，就是因为它默认防止csrf跨站请求伪造，因为会产生安全问题，可以将请求改为post表单提交，或者在spring security中关闭csrf功能；试试：在 配置中增加 http.csrf().disable(); 12http.csrf().disable();//关闭csrf功能:跨站请求伪造,默认只能通过post方式提交logout请求http.logout().logoutSuccessUrl(\"/\"); 继续将下面的角色功能块认证完成！ 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;div class=\"column\" sec:authorize=\"hasRole('vip1')\"&gt; &lt;div class=\"ui raised segment\"&gt; &lt;div class=\"ui\"&gt; &lt;div class=\"content\"&gt; &lt;h3 class=\"content\"&gt;Level 1&lt;/h3&gt; &lt;hr&gt; &lt;div&gt;&lt;a th:href=\"@&#123;/level1/1&#125;\"&gt;level1-1&lt;/a&gt;&lt;/div&gt; &lt;div&gt;&lt;a th:href=\"@&#123;/level1/2&#125;\"&gt;level1-2&lt;/a&gt;&lt;/div&gt; &lt;div&gt;&lt;a th:href=\"@&#123;/level1/3&#125;\"&gt;level1-3&lt;/a&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"column\" sec:authorize=\"hasRole('vip2')\"&gt; &lt;div class=\"ui raised segment\"&gt; &lt;div class=\"ui\"&gt; &lt;div class=\"content\"&gt; &lt;h3 class=\"content\"&gt;Level 2&lt;/h3&gt; &lt;hr&gt; &lt;div&gt;&lt;a th:href=\"@&#123;/level2/1&#125;\"&gt;level2-1&lt;/a&gt;&lt;/div&gt; &lt;div&gt;&lt;a th:href=\"@&#123;/level2/2&#125;\"&gt;level2-2&lt;/a&gt;&lt;/div&gt; &lt;div&gt;&lt;a th:href=\"@&#123;/level2/3&#125;\"&gt;level2-3&lt;/a&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"column\" sec:authorize=\"hasRole('vip3')\"&gt; &lt;div class=\"ui raised segment\"&gt; &lt;div class=\"ui\"&gt; &lt;div class=\"content\"&gt; &lt;h3 class=\"content\"&gt;Level 3&lt;/h3&gt; &lt;hr&gt; &lt;div&gt;&lt;a th:href=\"@&#123;/level3/1&#125;\"&gt;level3-1&lt;/a&gt;&lt;/div&gt; &lt;div&gt;&lt;a th:href=\"@&#123;/level3/2&#125;\"&gt;level3-2&lt;/a&gt;&lt;/div&gt; &lt;div&gt;&lt;a th:href=\"@&#123;/level3/3&#125;\"&gt;level3-3&lt;/a&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 权限控制和注销搞定 记住我 现在的情况，只要登录之后，关闭浏览器，再登录，就会让重新登录，但是很多网站的情况，就是有一个记住密码的功能，这个该如何实现 很简单 开启记住我功能 1234567//定制请求的授权规则@Overrideprotected void configure(HttpSecurity http) throws Exception &#123;//。。。。。。。。。。。 //记住我 http.rememberMe();&#125; 再次启动项目测试一下，发现登录页多了一个记住我功能，登录之后关闭 浏览器，然后重新打开浏览器访问，发现用户依旧存在！ 思考：如何实现的呢？ 其实非常简单 可以查看浏览器的cookie 点击注销的时候，可以发现，spring security 帮自动删除了这个 cookie 定制登录页 现在这个登录页面都是spring security 默认的，怎么样可以使用自己写的Login界面呢？ 在刚才的登录页配置后面指定 loginpage 1http.formLogin().loginPage(\"/toLogin\"); 然后前端也需要指向自己定义的 login请求 1&lt;li sec:authorize=\"!isAuthenticated()\"&gt;&lt;a th:href=\"@&#123;/tologin&#125;\"&gt;登录&lt;/a&gt;&lt;/li&gt; 登录的话，需要将这些信息发送到哪里，也需要配置，login.html 配置提交请求及方式，方式必须为post: 在 loginPage()源码中的注释上有写明： 123456789101112131415161718&lt;form class=\"form-signin\" th:action=\"@&#123;/login&#125;\" method=\"post\"&gt; &lt;h2 class=\"form-signin-heading\" th:text=\"#&#123;login.tip&#125;\"&gt; &lt;/h2&gt; &lt;label for=\"inputUserName\" class=\"sr-only\" th:text=\"#&#123;login.username&#125;\"&gt;&lt;/label&gt; &lt;input type=\"text\" id=\"inputUserName\" name=\"username\" class=\"form-control\" th:placeholder=\"#&#123;login.username&#125;\" required=\"\" autofocus=\"\"&gt; &lt;label for=\"inputPassword\" class=\"sr-only\" th:text=\"#&#123;login.password&#125;\"&gt;&lt;/label&gt; &lt;input type=\"password\" id=\"inputPassword\" name=\"password\" class=\"form-control\" th:placeholder=\"#&#123;login.password&#125;\" required=\"\"&gt; &lt;div class=\"checkbox\"&gt; &lt;label&gt; &lt;input type=\"checkbox\" name=\"remember\"&gt;[[#&#123;login.remember&#125;]] &lt;/label&gt; &lt;/div&gt; &lt;button class=\"btn btn-lg btn-primary btn-block\" type=\"submit\"&gt;[[#&#123;login.btn&#125;]]&lt;/button&gt; &lt;p class=\"text-muted\"&gt;2017-2021&lt;/p&gt; &lt;a class=\"btn btn-sm\" th:href=\"@&#123;/index.html(l='zn_CN')&#125;\"&gt;中文&lt;/a&gt; &lt;a class=\"btn btn-sm\" th:href=\"@&#123;/index.html(l='en_US')&#125;\"&gt;英文&lt;/a&gt;&lt;/form&gt; 这个请求提交上来，还需要验证处理，怎么做呢？可以查看formLogin()方法的源码！配置接收登录的用户名和密码的参数！ 12345http.formLogin() .usernameParameter(\"username\") .passwordParameter(\"password\") .loginPage(\"/toLogin\") .loginProcessingUrl(\"/login\"); // 登陆表单提交请求 在登录页增加记住我的多选框 1&lt;input type=\"checkbox\" name=\"remember\"&gt; 记住我 后端验证处理！ 1http.rememberMe().rememberMeParameter(\"remember\"); 完整配置代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package cn.com.codingce.config;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import javax.sql.DataSource;//AOP 的好处 横切@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Autowired DataSource dataSource; //链式编程 //授权 @Override protected void configure(HttpSecurity http) throws Exception &#123; //super.configure(http); // 定制请求的授权规则 // 首页所有人可以访问 http.authorizeRequests().antMatchers(\"/\").permitAll() .antMatchers(\"/level1/**\").hasRole(\"vip1\") .antMatchers(\"/level2/**\").hasRole(\"vip2\") .antMatchers(\"/level3/**\").hasRole(\"vip3\"); //没有权限默认会到登录页 http.formLogin().loginPage(\"/tologin\").loginProcessingUrl(\"/login\"); //以下是自定义表单参数名不然与表单名称不符会报错// http.formLogin().loginPage(\"/tologin\").usernameParameter(\"user\").passwordParameter(\"pwd\").loginProcessingUrl(\"/login\"); //注销 开启注销功能 跳转首页 .logoutSuccessUrl(\"/\"); 注销成功来到首页 http.logout().logoutSuccessUrl(\"/\"); //防止网站攻击 get不安全 http.csrf().disable(); //关闭csrf功能 //开启记住我功能 cookie// 系统默认 http.rememberMe(); 下面是自定义 http.rememberMe().rememberMeParameter(\"remember\"); &#125; //定义 认证 规则 @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; //在内存中定义，也可以在jdbc中去拿.... //Spring security 5.0中新增了多种加密方式，也改变了密码的格式。 //要想我们的项目还能够正常登陆，需要修改一下configure中的代码。我们要将前端传过来的密码进行某种方式加密 //spring security 官方推荐的是使用bcrypt加密方式。// auth.inMemoryAuthentication()// .withUser(\"xzM\").password(\"123456\").roles(\"vip2\",\"vip3\")// .and()// .withUser(\"root\").password(\"123456\").roles(\"vip1\",\"vip2\",\"vip3\")// .and()// .withUser(\"guest\").password(\"123456\").roles(\"vip1\"); auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder()) .withUser(\"xzM\").password(new BCryptPasswordEncoder().encode(\"123456\")).roles(\"vip2\",\"vip3\") .and() .withUser(\"root\").password(new BCryptPasswordEncoder().encode(\"123456\")).roles(\"vip1\",\"vip2\",\"vip3\") .and() .withUser(\"guest\").password(new BCryptPasswordEncoder().encode(\"123456\")).roles(\"vip1\",\"vip2\"); // ensure the passwords are encoded properly// UserBuilder users = User.withDefaultPasswordEncoder();// auth// .jdbcAuthentication()// .dataSource(dataSource)// .withDefaultSchema()// .withUser(users.username(\"user\").password(\"password\").roles(\"USER\"))// .withUser(users.username(\"admin\").password(\"password\").roles(\"USER\",\"ADMIN\")); &#125;&#125; 还有一点 本次SpringBoot版本为2.0.9.RELEASE, SpringBoot太高版本, SpringSecurity页面语法不会生效, 我的是降级后的, 其他SpringBoot版本为2.2.9.RELEASE","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://i.codingce.com.cn/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://i.codingce.com.cn/tags/SpringBoot/"}]},{"title":"SpringBoot页面国际化","slug":"SpringBoot页面国际化","date":"2020-08-15T00:21:18.000Z","updated":"2020-12-13T04:41:40.422Z","comments":true,"path":"2020/08/15/SpringBoot页面国际化/","link":"","permalink":"http://i.codingce.com.cn/2020/08/15/SpringBoot%E9%A1%B5%E9%9D%A2%E5%9B%BD%E9%99%85%E5%8C%96/","excerpt":"","text":"页面国际化 有的时候，的网站会去涉及中英文甚至多语言的切换，这时候就需要学习国际化了！ 准备工作 先在IDEA中统一设置properties的编码问题！ 编写国际化配置文件，抽取页面需要显示的国际化页面消息。 配置文件编写 在resources资源文件下新建一个i18n目录，存放国际化配置文件 建立一个login.properties文件，还有一个login_zh_CN.properties；发现IDEA自动识别了要做国际化操作；文件夹变了！ 可以在这上面去新建一个文件； 弹出如下页面：添加一个英文的； 接下来，编写配置，可以看到idea下面有另外一个视图； login.properties ：默认 12345login.btn=登录login.password=密码login.remember=记住我login.tip=请登录login.username=用户名 英文： 12345login.btn=Sgin inlogin.password=Passwordlogin.remember=Remember melogin.tip=please log inlogin.username=UserName 中文： 12345login.btn=登录login.password=密码login.remember=记住我login.tip=请登录login.username=用户名 配置文件生效探究 去看一下SpringBoot对国际化的自动配置！这里又涉及到一个类：MessageSourceAutoConfiguration 里面有一个方法，这里发现SpringBoot已经自动配置好了管理国际化资源文件的组件 ResourceBundleMessageSource； 12345678910111213141516171819202122// 获取 properties 传递过来的值进行判断@Beanpublic MessageSource messageSource(MessageSourceProperties properties) &#123; ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource(); if (StringUtils.hasText(properties.getBasename())) &#123; // 设置国际化文件的基础名（去掉语言国家代码的） messageSource.setBasenames( StringUtils.commaDelimitedListToStringArray( StringUtils.trimAllWhitespace(properties.getBasename()))); &#125; if (properties.getEncoding() != null) &#123; messageSource.setDefaultEncoding(properties.getEncoding().name()); &#125; messageSource.setFallbackToSystemLocale(properties.isFallbackToSystemLocale()); Duration cacheDuration = properties.getCacheDuration(); if (cacheDuration != null) &#123; messageSource.setCacheMillis(cacheDuration.toMillis()); &#125; messageSource.setAlwaysUseMessageFormat(properties.isAlwaysUseMessageFormat()); messageSource.setUseCodeAsDefaultMessage(properties.isUseCodeAsDefaultMessage()); return messageSource;&#125; 真实的情况是放在了i18n目录下，所以要去配置这个messages的路径； 1spring.messages.basename=i18n.login 配置页面国际化值 去页面获取国际化的值，查看Thymeleaf的文档，找到message取值操作为：#{…}。去页面测试： 配置国际化解析 在Spring中有一个国际化的Locale （区域信息对象）；里面有一个叫做LocaleResolver （获取区域信息对象）的解析器！ 去webmvc自动配置文件，寻找一下 看到SpringBoot默认配置： 1234567891011121314@Bean@ConditionalOnMissingBean@ConditionalOnProperty(prefix = \"spring.mvc\", name = \"locale\")public LocaleResolver localeResolver() &#123; // 容器中没有就自己配，有的话就用用户配置的 if (this.mvcProperties.getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) &#123; return new FixedLocaleResolver(this.mvcProperties.getLocale()); &#125; // 接收头国际化分解 AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver(); localeResolver.setDefaultLocale(this.mvcProperties.getLocale()); return localeResolver;&#125; AcceptHeaderLocaleResolver 这个类中有一个方法 1234567891011121314151617181920public Locale resolveLocale(HttpServletRequest request) &#123; Locale defaultLocale = this.getDefaultLocale(); // 默认的就是根据请求头带来的区域信息获取Locale进行国际化 if (defaultLocale != null &amp;&amp; request.getHeader(\"Accept-Language\") == null) &#123; return defaultLocale; &#125; else &#123; Locale requestLocale = request.getLocale(); List&lt;Locale&gt; supportedLocales = this.getSupportedLocales(); if (!supportedLocales.isEmpty() &amp;&amp; !supportedLocales.contains(requestLocale)) &#123; Locale supportedLocale = this.findSupportedLocale(request, supportedLocales); if (supportedLocale != null) &#123; return supportedLocale; &#125; else &#123; return defaultLocale != null ? defaultLocale : requestLocale; &#125; &#125; else &#123; return requestLocale; &#125; &#125;&#125; 那假如现在想点击链接让的国际化资源生效，就需要让自己的Locale生效！ 自己写一个自己的LocaleResolver，可以在链接上携带区域信息！ 修改一下前端页面的跳转连接： 123&lt;!-- 这里传入参数不需要使用 ？使用 （key=value）--&gt;&lt;a class=\"btn btn-sm\" th:href=\"@&#123;/index.html(l='zh_CN')&#125;\"&gt;中文&lt;/a&gt;&lt;a class=\"btn btn-sm\" th:href=\"@&#123;/index.html(l='en_US')&#125;\"&gt;English&lt;/a&gt; 写一个处理的组件类！ 123456789101112131415161718192021222324252627282930313233package cn.com.codingce.config;import org.springframework.util.StringUtils;import org.springframework.web.servlet.LocaleResolver;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.util.Locale;public class MyLocaleResolver implements LocaleResolver &#123; //解析请求 @Override public Locale resolveLocale(HttpServletRequest httpServletRequest) &#123; //获取请求语言的参数链接 String language = httpServletRequest.getParameter(\"l\"); Locale locale = Locale.getDefault();//如果没有就使用默认 //如果请求的链接携带了国际化参数 if (!StringUtils.isEmpty(language)) &#123; //zh_CN String[] split = language.split(\"_\"); //国家, 地区 locale = new Locale(split[0], split[1]); &#125; return locale; &#125; @Override public void setLocale(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Locale locale) &#123; &#125;&#125; 为了让自己的区域化信息能够生效，需要再配置一下这个组件！在自己的MvcConofig下添加bean； 12345//自定义的国际化组件就生效了， 只有注入才能生效@Beanpublic LocaleResolver localeResolver() &#123; return new MyLocaleResolver();&#125;","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://i.codingce.com.cn/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://i.codingce.com.cn/tags/SpringBoot/"}]},{"title":"SpringBoot问题总结","slug":"SpringBoot问题总结","date":"2020-08-14T08:55:36.000Z","updated":"2020-12-13T04:41:40.422Z","comments":true,"path":"2020/08/14/SpringBoot问题总结/","link":"","permalink":"http://i.codingce.com.cn/2020/08/14/SpringBoot%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/","excerpt":"","text":"Spring Boot 2.x 增加拦截器后静态资源文件404无法访问 问题描述 Spring Boot 2.2.0 增加自定义拦截器后发现静态资源都没法访问，报 404 错误。 网上找了几个方案比如修改资源文件路径由 /** 改为 /static/** 然后添加到排除列表，我的项目没效果。 最后发现是配置拦截器的方式不一样造成的，注意以下两个细节： 配置拦截器的几种方式 在 spring boot2.x 中已经不推荐再使用 WebMvcConfigurationAdapter，官方声明已过时。 所以要继承 WebMvcConfigurationSupport 或者实现 WebMvcConfigurer（注意这两种有区别造成资源文件被拦截） 12345678910111213141516//方式①implements WebMvcConfigurer //不会覆盖@EnableAutoConfiguration关于WebMvcAutoConfiguration的配置//方式②@EnableWebMvcimplements WebMvcConfigurer //会覆盖@EnableAutoConfiguration关于WebMvcAutoConfiguration的配置//方式③extends WebMvcConfigurationSupport //会覆盖@EnableAutoConfiguration关于WebMvcAutoConfiguration的配置//方式④extends DelegatingWebMvcConfiguration //会覆盖@EnableAutoConfiguration关于WebMvcAutoConfiguration的配置 注意上面的几种拦截实现方式，只有第①种implements WebMvcConfigurer默认不会覆盖 @EnableAutoConfiguration 关于 WebMvcAutoConfiguration 的配置，这种话我看不懂，但发现下面几种都覆盖了会造成资源文件就无法访问。若被覆盖了，可自己再实现 addResourceHandlers() 即可。 解决方案 方案一（推荐） 注意这里没有 @EnableWebMvc 注解 123456789101112131415@Configurationpublic class MyWebMvcConfigurer implements WebMvcConfigurer &#123; @Bean public AuthInterceptor authInterceptor() &#123; return new AuthInterceptor(); &#125; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(authInterceptor()) .addPathPatterns(&quot;&#x2F;**&quot;) &#x2F;&#x2F;拦截所有请求 .excludePathPatterns(&quot;&#x2F;static&#x2F;**&quot;); &#x2F;&#x2F;排除静态资源（注意默认的静态资源路径是&#x2F;**） &#125;&#125; 方案二 如果用了 @EnableWebMvc 注解的话，必须重写 addResourceHandlers() 方法 12345678910111213141516171819202122232425262728@Configuration@EnableWebMvcpublic class MyWebMvcConfigurer implements WebMvcConfigurer &#123; @Bean public AuthInterceptor authInterceptor() &#123; return new AuthInterceptor(); &#125; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(authInterceptor()) .addPathPatterns(\"/**\") //拦截所有请求 .excludePathPatterns(\"/static/**\"); //排除静态资源（注意默认的静态资源路径是/**） &#125; /** * SpringBoot 2.x 要重写该方法，不然 css、js、image 等静态资源路径无法访问 */ @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; registry.addResourceHandler(\"/**\") .addResourceLocations(\"classpath:/META-INF/resources/\") .addResourceLocations(\"classpath:/resources/\") .addResourceLocations(\"classpath:/static/\") .addResourceLocations(\"classpath:/public/\"); &#125;&#125; 方案三 如题是继承 WebMvcConfigurationSupport 类，那么需要和方案二一样必须重写 addResourceHandlers() 方法。 1234567891011121314151617181920212223242526@Configurationpublic class WebMvcConfigurer extends WebMvcConfigurationSupport &#123; @Bean public AuthInterceptor authInterceptor() &#123; return new AuthInterceptor(); &#125; @Override protected void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(authInterceptor()) .addPathPatterns(\"/**\") //拦截所有请求 .excludePathPatterns(\"/static/**\"); //排除静态资源（注意默认的静态资源路径是/**） super.addInterceptors(registry); &#125; @Override protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123; registry.addResourceHandler(\"/**\") .addResourceLocations(\"classpath:/META-INF/resources/\") .addResourceLocations(\"classpath:/resources/\") .addResourceLocations(\"classpath:/static/\") .addResourceLocations(\"classpath:/public/\"); super.addResourceHandlers(registry); &#125;&#125;","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://i.codingce.com.cn/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://i.codingce.com.cn/tags/SpringBoot/"}]},{"title":"Web开发静态资源处理|thymeleaf模板引擎","slug":"Web开发静态资源处理","date":"2020-08-13T06:52:13.000Z","updated":"2020-12-13T04:41:40.438Z","comments":true,"path":"2020/08/13/Web开发静态资源处理/","link":"","permalink":"http://i.codingce.com.cn/2020/08/13/Web%E5%BC%80%E5%8F%91%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%A4%84%E7%90%86/","excerpt":"","text":"Web开发探究 简介 使用SpringBoot的步骤: 创建一个SpringBoot应用，选择需要的模块，SpringBoot就会默认将的需要的模块自动配置好 手动在配置文件中配置部分配置项目就可以运行起来了 专注编写业务代码，不需要考虑以前那样一大堆的配置了。 比如SpringBoot到底帮配置了什么？能不能修改？能修改哪些配置？能不能扩展？ 向容器中自动配置组件 ：*** Autoconfiguration 自动配置类，封装配置文件的内容：***Properties 静态资源处理 静态资源映射规则 这个静态资源映射规则： SpringBoot中，SpringMVC的web配置都在 WebMvcAutoConfiguration 这个配置类里面； 可以去看看 WebMvcAutoConfigurationAdapter 中有很多配置方法； 有一个方法：addResourceHandlers 添加资源处理 123456789101112131415161718192021222324@Overridepublic void addResourceHandlers(ResourceHandlerRegistry registry) &#123; if (!this.resourceProperties.isAddMappings()) &#123; // 已禁用默认资源处理 logger.debug(\"Default resource handling disabled\"); return; &#125; // 缓存控制 Duration cachePeriod = this.resourceProperties.getCache().getPeriod(); CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl(); // webjars 配置 if (!registry.hasMappingForPattern(\"/webjars/**\")) &#123; customizeResourceHandlerRegistration(registry.addResourceHandler(\"/webjars/**\") .addResourceLocations(\"classpath:/META-INF/resources/webjars/\") .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl)); &#125; // 静态资源配置 String staticPathPattern = this.mvcProperties.getStaticPathPattern(); if (!registry.hasMappingForPattern(staticPathPattern)) &#123; customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern) .addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations())) .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl)); &#125;&#125; 读一下源代码：比如所有的 /webjars/** ， 都需要去 classpath:/META-INF/resources/webjars/ 找对应的资源； 什么是webjars 呢？ Webjars本质就是以jar包的方式引入的静态资源 ， 以前要导入一个静态资源文件，直接导入即可。 使用SpringBoot需要使用Webjars，可以去搜索一下： 网站：https://www.webjars.org 要使用jQuery，只要要引入jQuery对应版本的pom依赖即可！ 12345&lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt;&lt;/dependency&gt; 访问：只要是静态资源，SpringBoot就会去对应的路径寻找资源，这里访问：http://localhost:8080/webjars/jquery/3.4.1/jquery.js 第二种静态资源映射规则 项目中要是使用自己的静态资源该怎么导入呢？看下一行代码； 去找staticPathPattern发现第二种映射规则 ：/** , 访问当前的项目任意资源，它会去找 resourceProperties 这个类，可以点进去看一下分析： 12345678910111213// 进入方法public String[] getStaticLocations() &#123; return this.staticLocations;&#125;// 找到对应的值private String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS;// 找到路径private static final String[] CLASSPATH_RESOURCE_LOCATIONS = &#123; \"classpath:/META-INF/resources/\", \"classpath:/resources/\", \"classpath:/static/\", \"classpath:/public/\" &#125;; ResourceProperties 可以设置和静态资源有关的参数；这里面指向了它会去寻找资源的文件夹，即上面数组的内容。 所以得出结论，以下四个目录存放的静态资源可以被识别： 1234\"classpath:/META-INF/resources/\"\"classpath:/resources/\"\"classpath:/static/\"\"classpath:/public/\" 自定义静态资源路径 也可以自己通过配置文件来指定一下，哪些文件夹是需要放静态资源文件的，在application.properties中配置； 1spring.resources.static-locations=classpath:/coding/,classpath:/kuang/ 一旦自己定义了静态文件夹的路径，原来的自动配置就都会失效了！ 首页处理 就是的首页 12345678910@Beanpublic WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext applicationContext, FormattingConversionService mvcConversionService, ResourceUrlProvider mvcResourceUrlProvider) &#123; WelcomePageHandlerMapping welcomePageHandlerMapping = new WelcomePageHandlerMapping( new TemplateAvailabilityProviders(applicationContext), applicationContext, getWelcomePage(), // getWelcomePage 获得欢迎页 this.mvcProperties.getStaticPathPattern()); welcomePageHandlerMapping.setInterceptors(getInterceptors(mvcConversionService, mvcResourceUrlProvider)); return welcomePageHandlerMapping;&#125; 点进去继续看 123456789101112private Optional&lt;Resource&gt; getWelcomePage() &#123; String[] locations = getResourceLocations(this.resourceProperties.getStaticLocations()); // ::是java8 中新引入的运算符 // Class::function的时候function是属于Class的，应该是静态方法。 // this::function的funtion是属于这个对象的。 // 简而言之，就是一种语法糖而已，是一种简写 return Arrays.stream(locations).map(this::getIndexHtml).filter(this::isReadable).findFirst();&#125;// 欢迎页就是一个location下的的 index.html 而已private Resource getIndexHtml(String location) &#123; return this.resourceLoader.getResource(location + \"index.html\");&#125; 欢迎页，静态资源文件夹下的所有 index.html 页面；被 /** 映射。 比如访问 http://localhost:8080/ ，就会找静态资源文件夹下的 index.html 新建一个 index.html ，在上面的3个目录中任意一个；然后访问测试 http://localhost:8080/ 看结果 Thymeleaf 模板引擎 前端交给页面，是html页面。如果是以前开发，需要把他们转成jsp页面，jsp好处就是当查出一些数据转发到JSP页面以后，可以用jsp轻松实现数据的显示，及交互等。 jsp支持非常强大的功能，包括能写Java代码，但是呢，现在的这种情况，SpringBoot这个项目首先是以jar的方式，不是war，像第二，用的还是嵌入式的Tomcat，所以呢，他现在默认是不支持jsp的。 那不支持jsp，如果直接用纯静态页面的方式，那给开发会带来非常大的麻烦，那怎么办呢？ SpringBoot推荐你可以来使用模板引擎： 模板引擎，其实大家听到很多，其实jsp就是一个模板引擎，还有用的比较多的freemarker，包括SpringBoot给推荐的Thymeleaf，模板引擎有非常多，但再多的模板引擎，他们的思想都是一样的，什么样一个思想呢来看一下这张图： 模板引擎的作用就是来写一个页面模板，比如有些值呢，是动态的，写一些表达式。而这些值，从哪来呢，就是在后台封装一些数据。然后把这个模板和这个数据交给模板引擎，模板引擎按照这个数据帮你把这表达式解析、填充到指定的位置，然后把这个数据最终生成一个想要的内容给写出去，这就是这个模板引擎，不管是jsp还是其他模板引擎，都是这个思想。只不过，就是说不同模板引擎之间，他们可能这个语法有点不一样。其他的就不介绍了，主要来介绍一下SpringBoot给推荐的Thymeleaf模板引擎，这模板引擎呢，是一个高级语言的模板引擎，他的这个语法更简单。而且，功能更强大。 引入Thymeleaf 怎么引入呢，对于springboot来说，什么事情不都是一个start的事情嘛，去在项目中引入一下.三个网址： Thymeleaf 官网：https://www.thymeleaf.org/ Thymeleaf 在Github 的主页：https://github.com/thymeleaf/thymeleaf Spring官方文档：找到对应的版本https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#using-boot-starter 找到对应的pom依赖：可以适当点进源码看下本来的包！ 12345&lt;!--thymeleaf--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; Maven会自动下载jar包，可以去看下下载的东西； Thymeleaf分析 首先得按照SpringBoot的自动配置原理看一下这个Thymeleaf的自动配置规则，在按照那个规则，进行使用。 去找一下Thymeleaf的自动配置类：ThymeleafProperties 1234567891011121314@ConfigurationProperties( prefix = \"spring.thymeleaf\")public class ThymeleafProperties &#123; private static final Charset DEFAULT_ENCODING; public static final String DEFAULT_PREFIX = \"classpath:/templates/\"; public static final String DEFAULT_SUFFIX = \".html\"; private boolean checkTemplate = true; private boolean checkTemplateLocation = true; private String prefix = \"classpath:/templates/\"; private String suffix = \".html\"; private String mode = \"HTML\"; private Charset encoding;&#125; 可以在其中看到默认的前缀和后缀！ 只需要把的html页面放在类路径下的templates下，thymeleaf就可以帮自动渲染了。 使用thymeleaf什么都不需要配置，只需要将他放在指定的文件夹下即可！ 测试 编写一个IndexController 123456789101112131415161718192021package cn.com.codingce.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;//在templates目录下的所有页面, 只能通过controller来跳转//这个需要模板引擎的支持 thymelaf@Controllerpublic class IndexController &#123; @GetMapping(\"/index\") public String index() &#123; return \"index\"; &#125; @GetMapping(\"/test\") public String test() &#123; return \"test\"; &#125;&#125; 编写一个测试页面 test.html 放在 templates 目录下 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;test&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; Thymeleaf 语法学习 要学习语法，还是参考官网文档最为准确，找到对应的版本看一下； Thymeleaf 官网：https://www.thymeleaf.org/ ， 简单看一下官网！去下载Thymeleaf的官方文档！ 做个最简单的练习 ：需要查出一些数据，在页面中展示 修改测试请求，增加数据传输； 1234567@GetMapping(\"/test2\")public String test1(Model model)&#123; //存入数据 model.addAttribute(\"msg\",\"Hello,Thymeleaf\"); //classpath:/templates/test.html return \"test2\";&#125; 要使用thymeleaf，需要在html文件中导入命名空间的约束，方便提示,可以去官方文档的#3中看一下命名空间拿来过来： 1xmlns:th=\"http://www.thymeleaf.org\" 编写下前端页面 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;掌上编程&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;测试页面&lt;/h1&gt;&lt;!--th:text就是将div中的内容设置为它指定的值，和之前学习的Vue一样--&gt;&lt;div th:text=\"$&#123;msg&#125;\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; -可以使用任意的 th:attr 来替换Html中原生属性的值！ 能写哪些表达式呢？ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465Simple expressions:（表达式语法）Variable Expressions: $&#123;...&#125;：获取变量值；OGNL； 1）、获取对象的属性、调用方法 2）、使用内置的基本对象：#18 #ctx : the context object. #vars: the context variables. #locale : the context locale. #request : (only in Web Contexts) the HttpServletRequest object. #response : (only in Web Contexts) the HttpServletResponse object. #session : (only in Web Contexts) the HttpSession object. #servletContext : (only in Web Contexts) the ServletContext object. 3）、内置的一些工具对象： #execInfo : information about the template being processed. #uris : methods for escaping parts of URLs/URIs #conversions : methods for executing the configured conversion service (if any). #dates : methods for java.util.Date objects: formatting, component extraction, etc. #calendars : analogous to #dates , but for java.util.Calendar objects. #numbers : methods for formatting numeric objects. #strings : methods for String objects: contains, startsWith, prepending/appending, etc. #objects : methods for objects in general. #bools : methods for boolean evaluation. #arrays : methods for arrays. #lists : methods for lists. #sets : methods for sets. #maps : methods for maps. #aggregates : methods for creating aggregates on arrays or collections.================================================================================== Selection Variable Expressions: *&#123;...&#125;：选择表达式：和$&#123;&#125;在功能上是一样； Message Expressions: #&#123;...&#125;：获取国际化内容 Link URL Expressions: @&#123;...&#125;：定义URL； Fragment Expressions: ~&#123;...&#125;：片段引用表达式Literals（字面量） Text literals: 'one text' , 'Another one!' ,… Number literals: 0 , 34 , 3.0 , 12.3 ,… Boolean literals: true , false Null literal: null Literal tokens: one , sometext , main ,… Text operations:（文本操作） String concatenation: + Literal substitutions: |The name is $&#123;name&#125;| Arithmetic operations:（数学运算） Binary operators: + , - , * , / , % Minus sign (unary operator): - Boolean operations:（布尔运算） Binary operators: and , or Boolean negation (unary operator): ! , not Comparisons and equality:（比较运算） Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le ) Equality operators: == , != ( eq , ne ) Conditional operators:条件运算（三元运算符） If-then: (if) ? (then) If-then-else: (if) ? (then) : (else) Default: (value) ?: (defaultvalue) Special tokens: No-Operation: _ 练习测试： 编写一个Controller 123456789@GetMapping(\"/test3\")public String test3(Model model)&#123; //存入数据 model.addAttribute(\"msg\",\"&lt;h1&gt;Hello,Thymeleaf&lt;/h1&gt;\"); //classpath:/templates/test.html model.addAttribute(\"users\", Arrays.asList(\"掌上编程\", \"xzM\", \"TianRuan\")); return \"test3\";&#125; 测试页面取出数据 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div th:text=\"$&#123;msg&#125;\"&gt;&lt;/div&gt;&lt;div th:utext=\"$&#123;msg&#125;\"&gt;&lt;/div&gt;&lt;div th:each=\"user : $&#123;users&#125;\" th:text=\"$&#123;user&#125;\"&gt;&lt;/div&gt;&lt;br/&gt;第二种&lt;br/&gt;&lt;div th:each=\"user : $&#123;users&#125;\"&gt;[[$&#123;user&#125;]]&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 看完语法，很多样式，即使现在学习了，也会忘记，所以在学习过程中，需要使用什么，根据官方文档来查询，才是最重要的，要熟练使用官方文档！","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://i.codingce.com.cn/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://i.codingce.com.cn/tags/SpringBoot/"}]},{"title":"JSR303数据校验|多环境切换|自动配置原理","slug":"JSR303数据校验及多环境切换","date":"2020-08-13T00:00:28.000Z","updated":"2020-12-13T04:41:40.422Z","comments":true,"path":"2020/08/13/JSR303数据校验及多环境切换/","link":"","permalink":"http://i.codingce.com.cn/2020/08/13/JSR303%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C%E5%8F%8A%E5%A4%9A%E7%8E%AF%E5%A2%83%E5%88%87%E6%8D%A2/","excerpt":"","text":"JSR303数据校验 使用 Springboot中可以用@validated来校验数据，如果数据异常则会统一抛出异常，方便异常中心统一处理。我们这里来写个注解让我们的name只能支持Email格式； 12345678@Component //注册bean@ConfigurationProperties(prefix = \"person\")@Validated //数据校验public class Person &#123; @Email(message=\"邮箱格式错误\") //name必须是邮箱格式 private String name;&#125; 运行结果 ：default message [不是一个合法的电子邮件地址]; 使用数据校验，可以保证数据的正确性； 常见参数 12345678910111213141516171819202122232425262728@NotNull(message=\"名字不能为空\")private String userName;@Max(value=120,message=\"年龄最大不能查过120\")private int age;@Email(message=\"邮箱格式错误\")private String email;空检查@Null 验证对象是否为null@NotNull 验证对象是否不为null, 无法查检长度为0的字符串@NotBlank 检查约束字符串是不是Null还有被Trim的长度是否大于0,只对字符串,且会去掉前后空格.@NotEmpty 检查约束元素是否为NULL或者是EMPTY. Booelan检查@AssertTrue 验证 Boolean 对象是否为 true @AssertFalse 验证 Boolean 对象是否为 false 长度检查@Size(min=, max=) 验证对象（Array,Collection,Map,String）长度是否在给定的范围之内 @Length(min=, max=) string is between min and max included.日期检查@Past 验证 Date 和 Calendar 对象是否在当前时间之前 @Future 验证 Date 和 Calendar 对象是否在当前时间之后 @Pattern 验证 String 对象是否符合正则表达式的规则.......等等除此以外，我们还可以自定义一些数据校验规则 多环境切换 profile是Spring对不同环境提供不同配置功能的支持，可以通过激活不同的环境版本，实现快速切换环境； 多配置文件 我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml , 用来指定多个环境版本； 例如: application-test.properties 代表测试环境配置 application-dev.properties 代表开发环境配置 但是Springboot并不会直接启动这些配置文件，它默认使用application.properties主配置 文件 我们需要通过一个配置来选择需要激活的环境： 1234#比如在配置文件中指定使用dev环境，我们可以通过设置不同的端口号进行测试；#我们启动SpringBoot，就可以看到已经切换到dev下的配置了；spring.profiles.active=dev yaml的多文档块 和properties配置文件中一样，但是使用yml去实现不需要创建多个配置文件，更加方便了 ! 123456789101112131415161718192021server: port: 8081#选择要激活那个环境块spring: profiles: active: prod---server: port: 8083spring: profiles: dev #配置环境的名称---server: port: 8084spring: profiles: prod #配置环境的名称 注意：如果yml和properties同时都配置了端口，并且没有激活其他环境 ， 默认会使用properties配置文件的！ 配置文件加载位置 外部加载配置文件的方式十分多，选择最常用的即可，在开发的资源文件中进行配置！ 官方外部配置文件说明参考文档 springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件： 优先级1：项目路径下的config文件夹配置文件 优先级2：项目路径下配置文件 优先级3：资源路径下的config文件夹配置文件 优先级4：资源路径下配置文件 优先级由高到底，高优先级的配置会覆盖低优先级的配置； SpringBoot会从这四个位置全部加载主配置文件；互补配置； 在最低级的配置文件中设置一个项目访问路径的配置来测试互补问题； 12#配置项目的访问路径server.servlet.context-path=/codingce 拓展，运维小技巧 指定位置加载配置文件 还可以通过spring.config.location来改变默认的配置文件位置 项目打包好以后，可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；这种情况，一般是后期运维做的多，相同配置，外部指定的配置文件优先级最高 1java -jar spring-boot-config.jar --spring.config.location=F:/application.properties 自动配置原理 配置文件到底能写什么？怎么写？ SpringBoot官方文档中有大量的配置，法全部记住 分析自动配置原理 以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//表示这是一个配置类，和以前编写的配置文件一样，也可以给容器中添加组件；@Configuration //启动指定类的ConfigurationProperties功能； //进入这个HttpProperties查看，将配置文件中对应的值和HttpProperties绑定起来； //并把HttpProperties加入到ioc容器中@EnableConfigurationProperties(&#123;HttpProperties.class&#125;) //Spring底层@Conditional注解 //根据不同的条件判断，如果满足指定的条件，整个配置类里面的配置就会生效； //这里的意思就是判断当前应用是否是web应用，如果是，当前配置类生效@ConditionalOnWebApplication( type = Type.SERVLET)//判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；@ConditionalOnClass(&#123;CharacterEncodingFilter.class&#125;)//判断配置文件中是否存在某个配置：spring.http.encoding.enabled； //如果不存在，判断也是成立的 //即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；@ConditionalOnProperty( prefix = \"spring.http.encoding\", value = &#123;\"enabled\"&#125;, matchIfMissing = true)public class HttpEncodingAutoConfiguration &#123; //他已经和SpringBoot的配置文件映射了 private final Encoding properties; //只有一个有参构造器的情况下，参数的值就会从容器中拿 public HttpEncodingAutoConfiguration(HttpProperties properties) &#123; this.properties = properties.getEncoding(); &#125; //给容器中添加一个组件，这个组件的某些值需要从properties中获取 @Bean @ConditionalOnMissingBean //判断容器没有这个组件？ public CharacterEncodingFilter characterEncodingFilter() &#123; CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.RESPONSE)); return filter; &#125; //。。。。。。。&#125; 一句话总结 ：根据当前不同的条件判断，决定这个配置类是否生效！ 一但这个配置类生效；这个配置类就会给容器中添加各种组件； 这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的； 所有在配置文件中能配置的属性都是在xxxxProperties类中封装着； 配置文件能配置什么就可以参照某个功能对应的这个属性类 12345//从配置文件中获取指定的值和bean的属性进行绑定@ConfigurationProperties(prefix = \"spring.http\") public class HttpProperties &#123; // .....&#125; 这就是自动装配的原理！ 精髓 SpringBoot启动会加载大量的自动配置类 看需要的功能有没有在SpringBoot默认写好的自动配置类当中； 再来看这个自动配置类中到底配置了哪些组件；（只要要用的组件存在在其中，就不需要再手动配置了） 给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。只需要在配置文件中指定这些属性的值即可； xxxxAutoConfigurartion：自动配置类；给容器中添加组件 xxxxProperties:封装配置文件中相关属性； 了解：@Conditional 自动配置类必须在一定的条件下才能生效； @Conditional派生注解（Spring注解版原生的@Conditional作用） 作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效； 那么多的自动配置类，必须在一定的条件下才能生效；也就是说，加载了这么多的配置类，但不是所有的都生效了。 怎么知道哪些自动配置类生效？ 可以通过启用 debug=true属性；来让控制台打印自动配置报告，这样就可以很方便的知道哪些自动配置类生效； 12#开启springboot的调试类debug=true Positive matches:（自动配置类启用的：正匹配） Negative matches:（没有启动，没有匹配成功的自动配置类：负匹配） Unconditional classes: （没有条件的类）","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://i.codingce.com.cn/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://i.codingce.com.cn/tags/SpringBoot/"}]},{"title":"AQS","slug":"AQS","date":"2020-08-12T13:37:36.000Z","updated":"2020-12-13T04:41:40.422Z","comments":true,"path":"2020/08/12/AQS/","link":"","permalink":"http://i.codingce.com.cn/2020/08/12/AQS/","excerpt":"","text":"目录： 1 AQS 简单介绍 2 AQS 原理 2.1 AQS 原理概览 2.2 AQS 对资源的共享方式 2.3 AQS底层使用了模板方法模式 3 Semaphore(信号量)-允许多个线程同时访问 4 CountDownLatch （倒计时器） 4.1 CountDownLatch 的三种典型用法 4.2 CountDownLatch 的使用示例 4.3 CountDownLatch 的不足 4.4 CountDownLatch相常见面试题： 5 CyclicBarrier(循环栅栏) 5.1 CyclicBarrier 的应用场景 5.2 CyclicBarrier 的使用示例 5.3 CyclicBarrier和CountDownLatch的区别 6 ReentrantLock 和 ReentrantReadWriteLock 常见问题：AQS原理？;CountDownLatch和CyclicBarrier了解吗,两者的区别是什么？用过Semaphore吗？ 本节思维导图： 1 AQS 简单介绍 AQS的全称为（AbstractQueuedSynchronizer），这个类在java.util.concurrent.locks包下面。 AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的ReentrantLock，Semaphore，其他的诸如ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的。当然，我们自己也能利用AQS非常轻松容易地构造出符合我们自己需求的同步器。 2 AQS 原理 在面试中被问到并发知识的时候，大多都会被问到“请你说一下自己对于AQS原理的理解”。下面给大家一个示例供大家参加，面试不是背题，大家一定要加入自己的思想，即使加入不了自己的思想也要保证自己能够通俗的讲出来而不是背出来。 下面大部分内容其实在AQS类注释上已经给出了，不过是英语看着比较吃力一点，感兴趣的话可以看看源码。 2.1 AQS 原理概览 AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。 CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node）来实现锁的分配。 看个AQS(AbstractQueuedSynchronizer)原理图： AQS使用一个int成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。AQS使用CAS对该同步状态进行原子操作实现对其值的修改。 1private volatile int state;//共享变量，使用volatile修饰保证线程可见性 状态信息通过protected类型的getState，setState，compareAndSetState进行操作 12345678910111213//返回同步状态的当前值protected final int getState() &#123; return state;&#125; // 设置同步状态的值protected final void setState(int newState) &#123; state = newState;&#125;//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）protected final boolean compareAndSetState(int expect, int update) &#123; return unsafe.compareAndSwapInt(this, stateOffset, expect, update);&#125; 2.2 AQS 对资源的共享方式 AQS定义两种资源共享方式 Exclusive（独占）：只有一个线程能执行，如ReentrantLock。又可分为公平锁和非公平锁： 公平锁：按照线程在队列中的排队顺序，先到者先拿到锁 非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的 Share（共享）：多个线程可同时执行，如Semaphore/CountDownLatch。Semaphore、CountDownLatCh、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。 ReentrantReadWriteLock 可以看成是组合式，因为ReentrantReadWriteLock也就是读写锁允许多个线程同时对某一资源进行读。 不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在上层已经帮我们实现好了。 2.3 AQS底层使用了模板方法模式 同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）： 使用者继承AbstractQueuedSynchronizer并重写指定的方法。（这些重写方法很简单，无非是对于共享资源state的获取和释放） 将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。 这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用，下面简单的给大家介绍一下模板方法模式，模板方法模式是一个很容易理解的设计模式之一。 模板方法模式是基于”继承“的，主要是为了在不改变模板结构的前提下在子类中重新定义模板中的内容以实现复用代码。举个很简单的例子假如我们要去一个地方的步骤是：购票buyTicket()-&gt;安检securityCheck()-&gt;乘坐某某工具回家ride()-&gt;到达目的地arrive()。我们可能乘坐不同的交通工具回家比如飞机或者火车，所以除了ride()方法，其他方法的实现几乎相同。我们可以定义一个包含了这些方法的抽象类，然后用户根据自己的需要继承该抽象类然后修改 ride()方法。 AQS使用了模板方法模式，自定义同步器时需要重写下面几个AQS提供的模板方法： 12345isHeldExclusively()//该线程是否正在独占资源。只有用到condition才需要去实现它。tryAcquire(int)//独占方式。尝试获取资源，成功则返回true，失败则返回false。tryRelease(int)//独占方式。尝试释放资源，成功则返回true，失败则返回false。tryAcquireShared(int)//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。tryReleaseShared(int)//共享方式。尝试释放资源，成功则返回true，失败则返回false。 默认情况下，每个方法都抛出 UnsupportedOperationException。 这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。AQS类中的其他方法都是final ，所以无法被其他类使用，只有这几个方法可以被其他类使用。 以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。 再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS(Compare and Swap)减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。 一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。 推荐两篇 AQS 原理和相关源码分析的文章： http://www.cnblogs.com/waterystone/p/4920797.html https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html 3 Semaphore(信号量)-允许多个线程同时访问 **synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。**示例代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940/** * * @author Snailclimb * @date 2018年9月30日 * @Description: 需要一次性拿一个许可的情况 */public class SemaphoreExample1 &#123; // 请求的数量 private static final int threadCount = 550; public static void main(String[] args) throws InterruptedException &#123; // 创建一个具有固定线程数量的线程池对象（如果这里线程池的线程数量给太少的话你会发现执行的很慢） ExecutorService threadPool = Executors.newFixedThreadPool(300); // 一次只能允许执行的线程数量。 final Semaphore semaphore = new Semaphore(20); for (int i = 0; i &lt; threadCount; i++) &#123; final int threadnum = i; threadPool.execute(() -&gt; &#123;// Lambda 表达式的运用 try &#123; semaphore.acquire();// 获取一个许可，所以可运行线程数量为20/1=20 test(threadnum); semaphore.release();// 释放一个许可 &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;); &#125; threadPool.shutdown(); System.out.println(\"finish\"); &#125; public static void test(int threadnum) throws InterruptedException &#123; Thread.sleep(1000);// 模拟请求的耗时操作 System.out.println(\"threadnum:\" + threadnum); Thread.sleep(1000);// 模拟请求的耗时操作 &#125;&#125; 执行 acquire 方法阻塞，直到有一个许可证可以获得然后拿走一个许可证；每个 release 方法增加一个许可证，这可能会释放一个阻塞的acquire方法。然而，其实并没有实际的许可证这个对象，Semaphore只是维持了一个可获得许可证的数量。 Semaphore经常用于限制获取某种资源的线程数量。 当然一次也可以一次拿取和释放多个许可，不过一般没有必要这样做： 123semaphore.acquire(5);// 获取5个许可，所以可运行线程数量为20/5=4test(threadnum);semaphore.release(5);// 获取5个许可，所以可运行线程数量为20/5=4 除了 acquire方法之外，另一个比较常用的与之对应的方法是tryAcquire方法，该方法如果获取不到许可就立即返回false。 Semaphore 有两种模式，公平模式和非公平模式。 公平模式： 调用acquire的顺序就是获取许可证的顺序，遵循FIFO； 非公平模式： 抢占式的。 Semaphore 对应的两个构造方法如下： 1234567public Semaphore(int permits) &#123; sync = new NonfairSync(permits); &#125; public Semaphore(int permits, boolean fair) &#123; sync = fair ? new FairSync(permits) : new NonfairSync(permits); &#125; 这两个构造方法，都必须提供许可的数量，第二个构造方法可以指定是公平模式还是非公平模式，默认非公平模式。 由于篇幅问题，如果对 Semaphore 源码感兴趣的朋友可以看下面这篇文章： https://blog.csdn.net/qq_19431333/article/details/70212663 4 CountDownLatch （倒计时器） CountDownLatch是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程的操作执行完后再执行。在Java并发中，countdownlatch的概念是一个常见的面试题，所以一定要确保你很好的理解了它。 4.1 CountDownLatch 的三种典型用法 ①某一线程在开始运行前等待n个线程执行完毕。将 CountDownLatch 的计数器初始化为n ：new CountDownLatch(n) ，每当一个任务线程执行完毕，就将计数器减1 countdownlatch.countDown()，当计数器的值变为0时，在CountDownLatch上 await() 的线程就会被唤醒。一个典型应用场景就是启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行。 ②实现多个线程开始执行任务的最大并行性。注意是并行性，不是并发，强调的是多个线程在某一时刻同时开始执行。类似于赛跑，将多个线程放到起点，等待发令枪响，然后同时开跑。做法是初始化一个共享的 CountDownLatch 对象，将其计数器初始化为 1 ：new CountDownLatch(1) ，多个线程在开始执行任务前首先 coundownlatch.await()，当主线程调用 countDown() 时，计数器变为0，多个线程同时被唤醒。 ③死锁检测：一个非常方便的使用场景是，你可以使用n个线程访问共享资源，在每次测试阶段的线程数目是不同的，并尝试产生死锁。 4.2 CountDownLatch 的使用示例 123456789101112131415161718192021222324252627282930313233343536373839/** * * @author SnailClimb * @date 2018年10月1日 * @Description: CountDownLatch 使用方法示例 */public class CountDownLatchExample1 &#123; // 请求的数量 private static final int threadCount = 550; public static void main(String[] args) throws InterruptedException &#123; // 创建一个具有固定线程数量的线程池对象（如果这里线程池的线程数量给太少的话你会发现执行的很慢） ExecutorService threadPool = Executors.newFixedThreadPool(300); final CountDownLatch countDownLatch = new CountDownLatch(threadCount); for (int i = 0; i &lt; threadCount; i++) &#123; final int threadnum = i; threadPool.execute(() -&gt; &#123;// Lambda 表达式的运用 try &#123; test(threadnum); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; finally &#123; countDownLatch.countDown();// 表示一个请求已经被完成 &#125; &#125;); &#125; countDownLatch.await(); threadPool.shutdown(); System.out.println(\"finish\"); &#125; public static void test(int threadnum) throws InterruptedException &#123; Thread.sleep(1000);// 模拟请求的耗时操作 System.out.println(\"threadnum:\" + threadnum); Thread.sleep(1000);// 模拟请求的耗时操作 &#125;&#125; 上面的代码中，我们定义了请求的数量为550，当这550个请求被处理完成之后，才会执行System.out.println(&quot;finish&quot;);。 与CountDownLatch的第一次交互是主线程等待其他线程。主线程必须在启动其他线程后立即调用CountDownLatch.await()方法。这样主线程的操作就会在这个方法上阻塞，直到其他线程完成各自的任务。 其他N个线程必须引用闭锁对象，因为他们需要通知CountDownLatch对象，他们已经完成了各自的任务。这种通知机制是通过 CountDownLatch.countDown()方法来完成的；每调用一次这个方法，在构造函数中初始化的count值就减1。所以当N个线程都调 用了这个方法，count的值等于0，然后主线程就能通过await()方法，恢复执行自己的任务。 4.3 CountDownLatch 的不足 CountDownLatch是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当CountDownLatch使用完毕后，它不能再次被使用。 4.4 CountDownLatch相常见面试题： 解释一下CountDownLatch概念？ CountDownLatch 和CyclicBarrier的不同之处？ 给出一些CountDownLatch使用的例子？ CountDownLatch 类中主要的方法？ 5 CyclicBarrier(循环栅栏) CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。 CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。 5.1 CyclicBarrier 的应用场景 CyclicBarrier 可以用于多线程计算数据，最后合并计算结果的应用场景。比如我们用一个Excel保存了用户所有银行流水，每个Sheet保存一个帐户近一年的每笔银行流水，现在需要统计用户的日均银行流水，先用多线程处理每个sheet里的银行流水，都执行完之后，得到每个sheet的日均银行流水，最后，再用barrierAction用这些线程的计算结果，计算出整个Excel的日均银行流水。 5.2 CyclicBarrier 的使用示例 示例1： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * * @author Snailclimb * @date 2018年10月1日 * @Description: 测试 CyclicBarrier 类中带参数的 await() 方法 */public class CyclicBarrierExample2 &#123; // 请求的数量 private static final int threadCount = 550; // 需要同步的线程数量 private static final CyclicBarrier cyclicBarrier = new CyclicBarrier(5); public static void main(String[] args) throws InterruptedException &#123; // 创建线程池 ExecutorService threadPool = Executors.newFixedThreadPool(10); for (int i = 0; i &lt; threadCount; i++) &#123; final int threadNum = i; Thread.sleep(1000); threadPool.execute(() -&gt; &#123; try &#123; test(threadNum); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;); &#125; threadPool.shutdown(); &#125; public static void test(int threadnum) throws InterruptedException, BrokenBarrierException &#123; System.out.println(\"threadnum:\" + threadnum + \"is ready\"); try &#123; /**等待60秒，保证子线程完全执行结束*/ cyclicBarrier.await(60, TimeUnit.SECONDS); &#125; catch (Exception e) &#123; System.out.println(\"-----CyclicBarrierException------\"); &#125; System.out.println(\"threadnum:\" + threadnum + \"is finish\"); &#125;&#125; 运行结果，如下： 123456789101112131415161718192021threadnum:0is readythreadnum:1is readythreadnum:2is readythreadnum:3is readythreadnum:4is readythreadnum:4is finishthreadnum:0is finishthreadnum:1is finishthreadnum:2is finishthreadnum:3is finishthreadnum:5is readythreadnum:6is readythreadnum:7is readythreadnum:8is readythreadnum:9is readythreadnum:9is finishthreadnum:5is finishthreadnum:8is finishthreadnum:7is finishthreadnum:6is finish...... 可以看到当线程数量也就是请求数量达到我们定义的 5 个的时候， await方法之后的方法才被执行。 另外，CyclicBarrier还提供一个更高级的构造函数CyclicBarrier(int parties, Runnable barrierAction)，用于在线程到达屏障时，优先执行barrierAction，方便处理更复杂的业务场景。示例代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * * @author SnailClimb * @date 2018年10月1日 * @Description: 新建 CyclicBarrier 的时候指定一个 Runnable */public class CyclicBarrierExample3 &#123; // 请求的数量 private static final int threadCount = 550; // 需要同步的线程数量 private static final CyclicBarrier cyclicBarrier = new CyclicBarrier(5, () -&gt; &#123; System.out.println(\"------当线程数达到之后，优先执行------\"); &#125;); public static void main(String[] args) throws InterruptedException &#123; // 创建线程池 ExecutorService threadPool = Executors.newFixedThreadPool(10); for (int i = 0; i &lt; threadCount; i++) &#123; final int threadNum = i; Thread.sleep(1000); threadPool.execute(() -&gt; &#123; try &#123; test(threadNum); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;); &#125; threadPool.shutdown(); &#125; public static void test(int threadnum) throws InterruptedException, BrokenBarrierException &#123; System.out.println(\"threadnum:\" + threadnum + \"is ready\"); cyclicBarrier.await(); System.out.println(\"threadnum:\" + threadnum + \"is finish\"); &#125;&#125; 运行结果，如下： 1234567891011121314151617181920212223threadnum:0is readythreadnum:1is readythreadnum:2is readythreadnum:3is readythreadnum:4is ready------当线程数达到之后，优先执行------threadnum:4is finishthreadnum:0is finishthreadnum:2is finishthreadnum:1is finishthreadnum:3is finishthreadnum:5is readythreadnum:6is readythreadnum:7is readythreadnum:8is readythreadnum:9is ready------当线程数达到之后，优先执行------threadnum:9is finishthreadnum:5is finishthreadnum:6is finishthreadnum:8is finishthreadnum:7is finish...... 5.3 CyclicBarrier和CountDownLatch的区别 CountDownLatch是计数器，只能使用一次，而CyclicBarrier的计数器提供reset功能，可以多次使用。但是我不那么认为它们之间的区别仅仅就是这么简单的一点。我们来从jdk作者设计的目的来看，javadoc是这么描述它们的： CountDownLatch: A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes.(CountDownLatch: 一个或者多个线程，等待其他多个线程完成某件事情之后才能执行；) CyclicBarrier : A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point.(CyclicBarrier : 多个线程互相等待，直到到达同一个同步点，再继续一起执行。) 对于CountDownLatch来说，重点是“一个线程（多个线程）等待”，而其他的N个线程在完成“某件事情”之后，可以终止，也可以等待。而对于CyclicBarrier，重点是多个线程，在任意一个线程没有完成，所有的线程都必须等待。 CountDownLatch是计数器，线程完成一个记录一个，只不过计数不是递增而是递减，而CyclicBarrier更像是一个阀门，需要所有线程都到达，阀门才能打开，然后继续执行。 CyclicBarrier和CountDownLatch的区别这部分内容参考了如下两篇文章： https://blog.csdn.net/u010185262/article/details/54692886 https://blog.csdn.net/tolcf/article/details/50925145?utm_source=blogxgwz0 6 ReentrantLock 和 ReentrantReadWriteLock ReentrantLock 和 synchronized 的区别在上面已经讲过了这里就不多做讲解。另外，需要注意的是：读写锁 ReentrantReadWriteLock 可以保证多个线程可以同时读，所以在读操作远大于写操作的时候，读写锁就非常有用了。 由于篇幅问题，关于 ReentrantLock 和 ReentrantReadWriteLock 详细内容可以查看我的这篇原创文章。 ReentrantLock 和 ReentrantReadWriteLock","categories":[],"tags":[{"name":"Multithread（多线程）","slug":"Multithread（多线程）","permalink":"http://i.codingce.com.cn/tags/Multithread%EF%BC%88%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%89/"}]},{"title":"hexo速度优化，gulp压缩静态资源","slug":"hexo速度优化，gulp压缩静态资源","date":"2020-08-11T00:36:17.000Z","updated":"2020-12-13T04:41:40.438Z","comments":true,"path":"2020/08/11/hexo速度优化，gulp压缩静态资源/","link":"","permalink":"http://i.codingce.com.cn/2020/08/11/hexo%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96%EF%BC%8Cgulp%E5%8E%8B%E7%BC%A9%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/","excerpt":"","text":"起因 自己博客插件加多了之后,感觉访问速度慢了些, 找了一些优化方法 少发送请求 把要加载的js文件（css文件同理）合并成一个（尽量少）文件，则可以向服务器少发送请求，从而减少等待时间。(前端不是很懂,太麻烦了,我只采用压缩文件这个方法) 压缩文件 使用压缩之后的js、css、img、html等静态资源文件，同样可以减少请求时间。(虽然html文件压缩对小网站意义不大,详见HTML代码到底该不该压缩, 但还是压一压吧TuT) js／css位置 css引用建议放在head标签里面；js脚本建议放到body内容的最后，原因：等待js加载或者脚本有错误的时候不会影响html页面的展示。 这里顺便说我的一点教训, 在给自己的博客添加或测试各种插件时,不保证在不同版本以及不同系统一定能成功,一定要做好备份, 备份, 备份 !即使那个插件把自己博客弄崩溃了, 我们还是能从备份中恢复过来, 更可以大胆地去做尝试了. 插件安装 安装gulp工具 $ npm install --global gulp 实现gulp压缩需要安装以下五个模块 gulp-htmlclean // 清理html gulp-htmlmin // 压缩html gulp-minify-css // 压缩css gulp-uglify // 混淆js gulp-imagemin // 压缩图片 安装命令: npm install gulp-htmlclean gulp-htmlmin gulp-minify-css gulp-uglify gulp-imagemin --save 添加系统环境变量, 将步骤1图红框的路径添加进Path中, 注意Users后面是你自己的用户名 重启Git, 在博客根目录下安装开发依赖: $ npm install --save-dev gulp 在站点根目录下新建gulpfile.js文件，内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142var gulp = require('gulp');//Plugins模块获取var minifycss = require('gulp-minify-css');var uglify = require('gulp-uglify');var htmlmin = require('gulp-htmlmin');var htmlclean = require('gulp-htmlclean');//压缩cssgulp.task('minify-css', function () &#123;return gulp.src('./public/**/*.css').pipe(minifycss()).pipe(gulp.dest('./public'));&#125;);//压缩htmlgulp.task('minify-html', function () &#123;return gulp.src('./public/**/*.html').pipe(htmlclean()).pipe(htmlmin(&#123;removeComments: true,minifyJS: true,minifyCSS: true,minifyURLs: true,&#125;)).pipe(gulp.dest('./public'))&#125;);//压缩js 不压缩min.jsgulp.task('minify-js', function () &#123;return gulp.src(['./public/**/*.js', '!./public/**/*.min.js']).pipe(uglify()).pipe(gulp.dest('./public'));&#125;);//4.0以前的写法 //gulp.task('default', [ // 'minify-html', 'minify-css', 'minify-js'//]);//4.0以后的写法// 执行 gulp 命令时执行的任务gulp.task('default', gulp.parallel('minify-html', 'minify-css', 'minify-js', function() &#123; // Do something after a, b, and c are finished.&#125;)); 使用 命令： hexo clean hexo generate gulp default //压缩js、css、img等文件, default是上面gulpfile.js合并任务的任务名 hexo deploy","categories":[{"name":"随记","slug":"随记","permalink":"http://i.codingce.com.cn/categories/%E9%9A%8F%E8%AE%B0/"}],"tags":[{"name":"随记","slug":"随记","permalink":"http://i.codingce.com.cn/tags/%E9%9A%8F%E8%AE%B0/"}]},{"title":"yaml配置注入","slug":"yaml配置注入","date":"2020-08-10T11:24:41.000Z","updated":"2020-12-13T04:41:40.438Z","comments":true,"path":"2020/08/10/yaml配置注入/","link":"","permalink":"http://i.codingce.com.cn/2020/08/10/yaml%E9%85%8D%E7%BD%AE%E6%B3%A8%E5%85%A5/","excerpt":"","text":"yaml语法学习 配置文件 SpringBoot使用一个全局的配置文件 ， 配置文件名称是固定的 application.properties 语法结构 ：key=value application.yml 语法结构 ：key：空格 value 配置文件的作用 ：修改SpringBoot自动配置的默认值，因为SpringBoot在底层都给我们自动配置好了； 比如可以在配置文件中修改Tomcat 默认启动的端口号 1server.port=8081 yaml概述 YAML是 “YAML Ain’t a Markup Language” （YAML不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：“Yet Another Markup Language”（仍是一种标记语言） 这种语言以数据作为中心，而不是以标记语言为重点！ 以前的配置文件，大多数都是使用xml来配置；比如一个简单的端口配置，我们来对比下yaml和xml 传统xml配置： 123&lt;server&gt; &lt;port&gt;8081&lt;port&gt;&lt;/server&gt; yaml配置： 12server： prot: 8080 yaml基础语法 说明：语法要求严格！ 空格不能省略 以缩进来控制层级关系，只要是左边对齐的一列数据都是同一个层级的。 属性和值的大小写都是十分敏感的. 字面量：普通的值 [ 数字，布尔值，字符串 ] 字面量直接写在后面就可以 ， 字符串默认不用加上双引号或者单引号； 1k: v 注意： “ ” 双引号，不会转义字符串里面的特殊字符 ， 特殊字符会作为本身想表示的意思；比如 ：name: “codingce \\n M” 输出 codingce 换行 M ‘’ 单引号，会转义特殊字符 ， 特殊字符最终会变成和普通字符一样输出比如 ：name: codingce \\n M 输出 codingce \\n M 对象、Map（键值对） 1234#对象、Map格式k: v1: v2: 在下一行来写对象的属性和值得关系，注意缩进；比如： 123student: name: zhangshangbiancheng age: 3 行内写法 1student: &#123;name: zhangshangbiancheng, age: 3&#125; 数组（ List、set ） 用 - 值表示数组中的一个元素,比如： 1234pets: - cat - dog - pig 行内写法 1pets: [cat,dog,pig] 修改SpringBoot的默认端口号 配置文件中添加，端口号的参数，就可以切换端口； 12server: port: 8082 注入配置文件 yaml文件更强大的地方在于，他可以给我们的实体类直接注入匹配值！ yaml注入配置文件 在springboot项目中的resources目录下新建一个文件 application.yml 编写一个实体类 Dog； 1234567891011121314151617181920212223242526272829303132333435363738394041package cn.com.codingce.pojo;import org.springframework.stereotype.Component;@Componentpublic class dag &#123; private String name; private Integer age; public dag() &#123; &#125; public dag(String name, Integer age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; @Override public String toString() &#123; return \"dag&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125;&#125; 思考，我们原来是如何给bean注入属性值的！@Value，给狗狗类测试一下： 1234567@Component //注册beanpublic class Dog &#123; @Value(\"阿黄\") private String name; @Value(\"18\") private Integer age;&#125; 在SpringBoot的测试类下注入狗狗输出一下； 123456789101112@SpringBootTestclass DemoApplicationTests &#123; @Autowired //将狗狗自动注入进来 Dog dog; @Test public void contextLoads() &#123; System.out.println(dog); //打印看下狗狗对象 &#125;&#125; 结果成功输出，@Value注入成功. 在编写一个复杂一点的实体类：Person 类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package cn.com.codingce.pojo;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;import java.util.Date;import java.util.List;import java.util.Map;@Component //注册bean到容器中public class Person &#123; private String name; private Integer age; private Boolean happy; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; public Person() &#123; &#125; public Person(String name, Integer age, Boolean happy, Date birth, Map&lt;String, Object&gt; maps, List&lt;Object&gt; lists, Dog dog) &#123; this.name = name; this.age = age; this.happy = happy; this.birth = birth; this.maps = maps; this.lists = lists; this.dog = dog; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public Boolean getHappy() &#123; return happy; &#125; public void setHappy(Boolean happy) &#123; this.happy = happy; &#125; public Date getBirth() &#123; return birth; &#125; public void setBirth(Date birth) &#123; this.birth = birth; &#125; public Map&lt;String, Object&gt; getMaps() &#123; return maps; &#125; public void setMaps(Map&lt;String, Object&gt; maps) &#123; this.maps = maps; &#125; public List&lt;Object&gt; getLists() &#123; return lists; &#125; public void setLists(List&lt;Object&gt; lists) &#123; this.lists = lists; &#125; public Dog getDog() &#123; return dog; &#125; public void setDog(Dog dog) &#123; this.dog = dog; &#125; @Override public String toString() &#123; return \"Person&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + \", happy=\" + happy + \", birth=\" + birth + \", maps=\" + maps + \", lists=\" + lists + \", dog=\" + dog + '&#125;'; &#125;&#125; 使用yaml配置的方式进行注入，大家写的时候注意区别和优势，我们编写一个yaml配置！ 12345678910111213person: name: maxinze age: 3 happy: false birth: 1998/01/01 maps: &#123;k1: v1,k2: v2&#125; lists: - code - girl - music dog: name: 阿黑 age: 1 刚才已经把person这个对象的所有值都写好了，现在来注入到类中 1234567891011121314151617/*@ConfigurationProperties作用：将配置文件中配置的每一个属性的值，映射到这个组件中；告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定参数 prefix = “person” : 将配置文件中的person下面的所有属性一一对应*/@Component //注册bean@ConfigurationProperties(prefix = \"person\")public class Person &#123; private String name; private Integer age; private Boolean happy; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog;&#125; IDEA 提示，springboot配置注解处理器没有找到，看文档，可以查看文档，找到一个依赖 1234567&lt;!-- 导入配置文件处理器，配置文件进行绑定就会有提示，需要重启 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 确认以上配置都OK之后，去测试类中测试一下： 123456789101112@SpringBootTestclass DemoApplicationTests &#123; @Autowired Person person; //将person自动注入进来 @Test public void contextLoads() &#123; System.out.println(person); //打印person信息 &#125;&#125; 结果：所有值全部注入成功！ yaml配置注入到实体类完全OK！ 加载指定的配置文件 @PropertySource ：加载指定的配置文件； @configurationProperties：默认从全局配置文件中获取值； 在resources目录下新建一个person.properties文件 1name=zhangshangbiancheng 然后在我们的代码中指定加载person.properties文件 123456789@PropertySource(value = \"classpath:person.properties\")@Component //注册beanpublic class Person &#123; @Value(\"$&#123;name&#125;\") private String name; ...... &#125; 再次输出测试一下：指定配置文件绑定成功！ 配置文件占位符 配置文件还可以编写占位符生成随机数 12345678910111213person: name: maxinze$&#123;random.uuid&#125; # 随机uuid age: $&#123;random.int&#125; # 随机int happy: false birth: 2000/01/01 maps: &#123;k1: v1,k2: v2&#125; lists: - code - girl - music dog: name: $&#123;person.hello:other&#125;_旺财 age: 1","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://i.codingce.com.cn/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://i.codingce.com.cn/tags/SpringBoot/"}]},{"title":"SpringBoot运行原理","slug":"SpringBoot运行原理初探","date":"2020-08-08T23:55:45.000Z","updated":"2020-12-13T04:41:40.422Z","comments":true,"path":"2020/08/09/SpringBoot运行原理初探/","link":"","permalink":"http://i.codingce.com.cn/2020/08/09/SpringBoot%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2/","excerpt":"","text":"Maven项目，一般从pom.xml文件探究起； pom.xml 父依赖 其中它主要是依赖一个父项目，主要是管理项目的资源过滤及插件！ 123456&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt; 点进去，发现还有一个父依赖 123456&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;&lt;/parent&gt; 这里才是真正管理SpringBoot应用里面所有依赖版本的地方，SpringBoot的版本控制中心； 以后导入依赖默认是不需要写版本；但是如果导入的包没有在依赖中管理着就需要手动配置版本了； 启动器 spring-boot-starter 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; **springboot-boot-starter-xxx：**就是spring-boot的场景启动器 **spring-boot-starter-web：**帮导入了web模块正常运行所依赖的组件； SpringBoot将所有的功能场景都抽取出来，做成一个个的starter （启动器），只需要在项目中引入这些starter即可，所有相关的依赖都会导入进来 ，要用什么功能就导入什么样的场景启动器即可 ；未来也可以自己自定义 starter； 主启动类 分析完了 pom.xml 来看看这个启动类 默认的主启动类 1234567891011//@SpringBootApplication 来标注一个主程序类//说明这是一个Spring Boot应用@SpringBootApplicationpublic class SpringbootApplication &#123; public static void main(String[] args) &#123; //以为是启动了一个方法，没想到启动了一个服务 SpringApplication.run(SpringbootApplication.class, args); &#125;&#125; 一个简单的启动类并不简单！ @SpringBootApplication 作用：标注在某个类上说明这个类是SpringBoot的主配置类 ， SpringBoot就应该运行这个类的main方法来启动SpringBoot应用； 进入这个注解：可以看到上面还有很多其他注解！ 1234567891011121314@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan( excludeFilters = &#123;@Filter( type = FilterType.CUSTOM, classes = &#123;TypeExcludeFilter.class&#125;), @Filter( type = FilterType.CUSTOM, classes = &#123;AutoConfigurationExcludeFilter.class&#125;)&#125;)public @interface SpringBootApplication &#123; // ......&#125; @ComponentScan 这个注解在Spring中很重要 ,它对应XML配置中的元素。 作用：自动扫描并加载符合条件的组件或者bean ， 将这个bean定义加载到IOC容器中 @SpringBootConfiguration 作用：SpringBoot的配置类 ，标注在某个类上 ， 表示这是一个SpringBoot的配置类； 继续进去这个注解查看 123456// 点进去得到下面的 @Component@Configurationpublic @interface SpringBootConfiguration &#123;&#125;@Componentpublic @interface Configuration &#123;&#125; 这里的 @Configuration，说明这是一个配置类 ，配置类就是对应Spring的xml 配置文件； 里面的 @Component 这就说明，启动类本身也是Spring中的一个组件而已，负责启动应用！ 回到 SpringBootApplication 注解中继续看。 @EnableAutoConfiguration @EnableAutoConfiguration ：开启自动配置功能 以前需要自己配置的东西，而现在SpringBoot可以自动配置 ；@EnableAutoConfiguration告诉SpringBoot开启自动配置功能，这样自动配置才能生效； 点进注解接续查看： @AutoConfigurationPackage ：自动配置包 123@Import(&#123;Registrar.class&#125;)public @interface AutoConfigurationPackage &#123;&#125; @import ：Spring底层注解@import ， 给容器中导入一个组件 Registrar.class 作用：将主启动类的所在包及包下面所有子包里面的所有组件扫描到Spring容器 ； 这个分析完了，退到上一步，继续看 @Import({AutoConfigurationImportSelector.class}) ：给容器导入组件 ； AutoConfigurationImportSelector ：自动配置导入选择器，那么它会导入哪些组件的选择器呢？ 这个类中有一个这样的方法 12345678// 获得候选的配置protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123; //这里的getSpringFactoriesLoaderFactoryClass（）方法 //返回的就是最开始看的启动自动导入配置文件的注解类；EnableAutoConfiguration List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader()); Assert.notEmpty(configurations, \"No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.\"); return configurations;&#125; 这个方法又调用了 SpringFactoriesLoader 类的静态方法！进入SpringFactoriesLoader类loadFactoryNames() 方法 12345public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader) &#123; String factoryClassName = factoryClass.getName(); //这里它又调用了 loadSpringFactories 方法 return (List)loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());&#125; 继续点击查看 loadSpringFactories 方法 1234567891011121314151617181920212223242526272829303132333435363738private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) &#123; //获得classLoader ，返回可以看到这里得到的就是EnableAutoConfiguration标注的类本身 MultiValueMap&lt;String, String&gt; result = (MultiValueMap)cache.get(classLoader); if (result != null) &#123; return result; &#125; else &#123; try &#123; //去获取一个资源 \"META-INF/spring.factories\" Enumeration&lt;URL&gt; urls = classLoader != null ? classLoader.getResources(\"META-INF/spring.factories\") : ClassLoader.getSystemResources(\"META-INF/spring.factories\"); LinkedMultiValueMap result = new LinkedMultiValueMap(); //将读取到的资源遍历，封装成为一个Properties while(urls.hasMoreElements()) &#123; URL url = (URL)urls.nextElement(); UrlResource resource = new UrlResource(url); Properties properties = PropertiesLoaderUtils.loadProperties(resource); Iterator var6 = properties.entrySet().iterator(); while(var6.hasNext()) &#123; Entry&lt;?, ?&gt; entry = (Entry)var6.next(); String factoryClassName = ((String)entry.getKey()).trim(); String[] var9 = StringUtils.commaDelimitedListToStringArray((String)entry.getValue()); int var10 = var9.length; for(int var11 = 0; var11 &lt; var10; ++var11) &#123; String factoryName = var9[var11]; result.add(factoryClassName, factoryName.trim()); &#125; &#125; &#125; cache.put(classLoader, result); return result; &#125; catch (IOException var13) &#123; throw new IllegalArgumentException(\"Unable to load factories from location [META-INF/spring.factories]\", var13); &#125; &#125;&#125; 发现一个多次出现的文件：spring.factories spring.factories 根据源头打开spring.factories ， 看到了很多自动配置的文件；这就是自动配置根源所在！ WebMvcAutoConfiguration 在上面的自动配置类随便找一个打开看看，比如 ：WebMvcAutoConfiguration 可以看到这些一个个的都是JavaConfig配置类，而且都注入了一些Bean，可以找一些自己认识的类 所以，自动配置真正实现是从classpath中搜寻所有的META-INF/spring.factories配置文件 ，并将其中对应的 org.springframework.boot.autoconfigure. 包下的配置项，通过反射实例化为对应标注了 @Configuration的JavaConfig形式的IOC容器配置类 ， 然后将这些都汇总成为一个实例并加载到IOC容器中。 结论： SpringBoot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值 将这些值作为自动配置类导入容器 ， 自动配置类就生效 ， 帮进行自动配置工作； 整个J2EE的整体解决方案和自动配置都在springboot-autoconfigure的jar包中； 它会给容器中导入非常多的自动配置类 （xxxAutoConfiguration）, 就是给容器中导入这个场景需要的所有组件 ， 并配置好这些组件 ； 有了自动配置类 ， 免去了手动编写配置注入功能组件等的工作； SpringApplication 不简单的方法 我最初以为就是运行了一个main方法，没想到却开启了一个服务； 123456@SpringBootApplicationpublic class SpringbootApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootApplication.class, args); &#125;&#125; SpringApplication.run分析 分析该方法主要分两部分，一部分是SpringApplication的实例化，二是run方法的执行； SpringApplication 这个类主要做了以下四件事情： 推断应用的类型是普通的项目还是Web项目 查找并加载所有可用初始化器 ， 设置到initializers属性中 找出所有的应用程序监听器，设置到listeners属性中 推断并设置main方法的定义类，找到运行的主类 查看构造器： 1234567public SpringApplication(ResourceLoader resourceLoader, Class... primarySources) &#123; // ...... this.webApplicationType = WebApplicationType.deduceFromClasspath(); this.setInitializers(this.getSpringFactoriesInstances(); this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class)); this.mainApplicationClass = this.deduceMainApplicationClass();&#125; run方法流程分析","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://i.codingce.com.cn/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://i.codingce.com.cn/tags/SpringBoot/"}]},{"title":"SpringBoot简介","slug":"SpringBoot简介","date":"2020-08-08T09:03:48.000Z","updated":"2020-12-13T04:41:40.422Z","comments":true,"path":"2020/08/08/SpringBoot简介/","link":"","permalink":"http://i.codingce.com.cn/2020/08/08/SpringBoot%E7%AE%80%E4%BB%8B/","excerpt":"","text":"SpringBoot简介 回顾什么是Spring Spring是一个开源框架，2003 年兴起的一个轻量级的Java 开发框架，作者：Rod Johnson 。 Spring是为了解决企业级应用开发的复杂性而创建的，简化开发。 Spring是如何简化Java开发的 为了降低Java开发的复杂性，Spring采用了以下4种关键策略： 基于POJO的轻量级和最小侵入性编程，所有东西都是bean； 通过IOC，依赖注入（DI）和面向接口实现松耦合； 基于切面（AOP）和惯例进行声明式编程； 通过切面和模版减少样式代码，RedisTemplate，xxxTemplate； 什么是SpringBoot 学过javaweb的同学就知道，开发一个web应用，从最初开始接触Servlet结合Tomcat, 跑出一个Hello Wolrld程序，是要经历特别多的步骤；后来就用了框架Struts，再后来是SpringMVC，到了现在的SpringBoot，过一两年又会有其他web框架出现；你们有经历过框架不断的演进，然后自己开发项目所有的技术也在不断的变化、改造吗？建议都可以去经历一遍； 言归正传，什么是SpringBoot呢，就是一个javaweb的开发框架，和SpringMVC类似，对比其他javaweb框架的好处，官方说是简化开发，约定大于配置， you can “just run”，能迅速的开发web应用，几行代码开发一个http接口。 所有的技术框架的发展似乎都遵循了一条主线规律：从一个复杂应用场景 衍生 一种规范框架，人们只需要进行各种配置而不需要自己去实现它，这时候强大的配置功能成了优点；发展到一定程度之后，人们根据实际生产应用情况，选取其中实用功能和设计精华，重构出一些轻量级的框架；之后为了提高开发效率，嫌弃原先的各类配置过于麻烦，于是开始提倡“约定大于配置”，进而衍生出一些一站式的解决方案。 是的这就是Java企业级应用-&gt;J2EE-&gt;spring-&gt;springboot的过程。 随着 Spring 不断的发展，涉及的领域越来越多，项目整合开发需要配合各种各样的文件，慢慢变得不那么易用简单，违背了最初的理念，甚至人称配置地狱。Spring Boot 正是在这样的一个背景下被抽象出来的开发框架，目的为了让大家更容易的使用 Spring 、更容易的集成各种常用的中间件、开源软件； Spring Boot 基于 Spring 开发，Spirng Boot 本身并不提供 Spring 框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于 Spring 框架的应用程序。也就是说，它并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。Spring Boot 以约定大于配置的核心思想，默认帮我们进行了很多设置，多数 Spring Boot 应用只需要很少的 Spring 配置。同时它集成了大量常用的第三方库配置（例如 Redis、MongoDB、Jpa、RabbitMQ、Quartz 等等），Spring Boot 应用中这些第三方库几乎可以零配置的开箱即用。 简单来说就是SpringBoot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，spring boot整合了所有的框架 。 Spring Boot 出生名门，从一开始就站在一个比较高的起点，又经过这几年的发展，生态足够完善，Spring Boot 已经当之无愧成为 Java 领域最热门的技术。 Spring Boot的主要优点： 为所有Spring开发者更快的入门 开箱即用，提供各种默认配置来简化项目配置 内嵌式容器简化Web项目 没有冗余代码生成和XML配置的要求 准备工作 我们将学习如何快速的创建一个Spring Boot应用，并且实现一个简单的Http请求处理。通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。 环境准备： java version “1.8.0_181” Maven-3.6.1 SpringBoot 2.x 最新版 开发工具： IDEA 创建基础项目说明 Spring官方提供了非常方便的工具让我们快速构建应用 Spring Initializr：https://start.spring.io/ 项目创建方式一：使用Spring Initializr 的 Web页面创建项目 打开 https://start.spring.io/ 填写项目信息 点击”Generate Project“按钮生成项目；下载此项目 解压项目包，并用IDEA以Maven项目导入，一路下一步即可，直到项目导入完毕。 如果是第一次使用，可能速度会比较慢，包比较多、需要耐心等待一切就绪。 项目创建方式二：使用 IDEA 直接创建项目 创建一个新项目 选择spring initalizr ， 可以看到默认就是去官网的快速构建工具那里实现 填写项目信息 选择初始化的组件（初学勾选 Web 即可） 填写项目路径 等待项目构建成功 项目结构分析： 通过上面步骤完成了基础项目的创建。就会自动生成以下文件。 程序的主启动类 一个 application.properties 配置文件 一个 测试类 一个 pom.xml pom.xml 分析 打开pom.xml，看看Spring Boot项目的依赖： 123456789101112131415161718192021222324252627282930313233343536373839&lt;!-- 父依赖 --&gt;&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;!-- web场景启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- springboot单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;!-- 剔除依赖 --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;!-- 打包插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 编写一个http接口 在主程序的同级目录下，新建一个controller包，一定要在同级目录下，否则识别不到 在包中新建一个HelloController类 12345678910@RestControllerpublic class HelloController &#123; @RequestMapping(\"/hello\") public String hello() &#123; return \"Hello World\"; &#125; &#125; 编写完毕后，从主程序启动项目，浏览器发起请求，看页面返回；控制台输出了 Tomcat 访问的端口号！ 将项目打成jar包，点击 maven的 package 可以配置打包时 跳过项目运行测试用例 1234567891011121314&lt;!-- 在工作中,很多情况下我们打包是不想执行测试用例的 可能是测试用例不完事,或是测试用例会影响数据库数据 跳过测试用例执 --&gt;&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;!--跳过项目运行测试用例--&gt; &lt;skipTests&gt;true&lt;/skipTests&gt; &lt;/configuration&gt;&lt;/plugin&gt; 如果打包成功，则会在target目录下生成一个 jar 包","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://i.codingce.com.cn/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://i.codingce.com.cn/tags/SpringBoot/"}]},{"title":"拦截器+文件上传下载","slug":"拦截器-文件上传下载","date":"2020-08-06T23:34:57.000Z","updated":"2020-12-13T04:41:40.453Z","comments":true,"path":"2020/08/07/拦截器-文件上传下载/","link":"","permalink":"http://i.codingce.com.cn/2020/08/07/%E6%8B%A6%E6%88%AA%E5%99%A8-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/","excerpt":"","text":"拦截器 概述 SpringMVC的处理器拦截器类似于Servlet开发中的过滤器Filter,用于对处理器进行预处理和后处理。开发者可以自己定义一些拦截器来实现特定的功能。 过滤器与拦截器的区别： 拦截器是AOP思想的具体应用。 过滤器 servlet规范中的一部分，任何java web工程都可以使用 在url-pattern中配置了/*之后，可以对所有要访问的资源进行拦截 拦截器 拦截器是SpringMVC框架自己的，只有使用了SpringMVC框架的工程才能使用 拦截器只会拦截访问的控制器方法， 如果访问的是jsp/html/css/image/js是不会进行拦截的 自定义拦截器 新建一个Moudule ， springmvc-07-Interceptor ， 添加web支持 配置web.xml 和 springmvc-servlet.xml 文件 编写一个拦截器 123456789101112131415161718192021222324252627package cn.com.codingce.config;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class MyIntercepetor implements HandlerInterceptor &#123; //return true 执行下一个拦截器, 放行 public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(\"==========处理前==========\"); return true; &#125; public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(\"==========处理后==========\"); &#125; public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(\"==========清理==========\"); &#125;&#125; 在springmvc的配置文件中配置拦截器 1234567891011&lt;!--关于拦截器的配置--&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--/** 包括路径及其子路径--&gt; &lt;!--/admin/* 拦截的是/admin/add等等这种 , /admin/add/user不会被拦截--&gt; &lt;!--/admin/** 拦截的是/admin/下的所有--&gt; &lt;mvc:mapping path=\"/**\"/&gt; &lt;!--bean配置的就是拦截器--&gt; &lt;bean class=\"cn.com.codingce.config.MyIntercepetor\"/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 编写一个Controller，接收请求 1234567891011121314151617181920212223242526272829303132package cn.com.codingce.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import javax.servlet.http.HttpSession;@Controller@RequestMapping(\"user\")public class LoginController &#123; @RequestMapping(\"/login\") public String login(HttpSession session, String username, String password, Model model) &#123; //把用户的信息存在Seesion中 session.setAttribute(\"userLoginInfo\", username); model.addAttribute(\"username\", username); model.addAttribute(\"password\", password); return \"main\"; &#125; @RequestMapping(\"/main\") public String main() &#123; return \"main\"; &#125; @RequestMapping(\"/goLogin\") public String goLogin() &#123; return \"login\"; &#125;&#125; 前端 index.jsp 1234567891011121314151617&lt;%-- Created by IntelliJ IDEA. User: xzMa Date: 2020/8/7 Time: 8:03 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=\"$&#123;pageContext.request.contextPath&#125;/user/goLogin\"&gt;登录页面&lt;/a&gt; &lt;a href=\"$&#123;pageContext.request.contextPath&#125;/user/main\"&gt;首页&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; 启动tomcat 测试 验证用户是否登录 (认证用户) 有一个登陆页面，需要写一个controller访问页面。 登陆页面有一提交表单的动作。需要在controller中处理。判断用户名密码是否正确。如果正确，向session中写入用户信息。返回登陆成功。 拦截用户请求，判断用户是否登陆。如果用户已经登陆。放行， 如果用户未登陆，跳转到登陆页面 编写一个登陆页面 login.jsp 1234567891011121314151617181920212223&lt;%-- Created by IntelliJ IDEA. User: xzMa Date: 2020/8/8 Time: 12:40 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%--在web-inf下所有的页面或者资源只能通过controller, 或者selvlet来进行访问--%&gt;&lt;h1&gt;登陆页面&lt;/h1&gt;&lt;form action=\"$&#123;pageContext.request.contextPath&#125;/user/login\" method=\"post\"&gt;用户名:&lt;input type=\"text\" name=\"username\"&gt;密码:&lt;input type=\"password\" name=\"password\"&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 编写一个Controller处理请求 1234567891011121314151617181920212223242526272829303132package cn.com.codingce.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import javax.servlet.http.HttpSession;@Controller@RequestMapping(\"user\")public class LoginController &#123; @RequestMapping(\"/login\") public String login(HttpSession session, String username, String password, Model model) &#123; //把用户的信息存在Seesion中 session.setAttribute(\"userLoginInfo\", username); model.addAttribute(\"username\", username); model.addAttribute(\"password\", password); return \"main\"; &#125; @RequestMapping(\"/main\") public String main() &#123; return \"main\"; &#125; @RequestMapping(\"/goLogin\") public String goLogin() &#123; return \"login\"; &#125;&#125; 编写一个登陆成功的页面 123456789101112131415161718&lt;%-- Created by IntelliJ IDEA. User: xzMa Date: 2020/8/8 Time: 12:39 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;首页&lt;/h1&gt;&lt;span&gt;$&#123;username&#125;&lt;/span&gt;&lt;br&gt;&lt;span&gt;$&#123;password&#125;&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 在 index 页面上测试跳转！启动Tomcat 测试，未登录也可以进入主页！ 12345678910111213&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;首页&lt;/h1&gt; &lt;hr&gt;&lt;%--登录--%&gt; &lt;a href=\"$&#123;pageContext.request.contextPath&#125;/user/jumplogin\"&gt;登录&lt;/a&gt; &lt;a href=\"$&#123;pageContext.request.contextPath&#125;/user/jumpSuccess\"&gt;成功页面&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; 编写用户登录拦截器 123456789101112131415161718192021222324252627282930313233343536373839404142package cn.com.codingce.config;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;public class LoginIntercepetor implements HandlerInterceptor &#123; //判断什么情况下没有登录 public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(\"执行前\"); HttpSession session = request.getSession(); //登录页面放行 if (request.getRequestURI().contains(\"goLogin\")) &#123; System.out.println(\"===========1===========\"); return true; &#125; if (request.getRequestURI().contains(\"login\")) &#123; System.out.println(\"===========1===========\"); return true; &#125; //放行: 判断什么情况下登录 if(session.getAttribute(\"userLoginInfo\") != null)&#123; System.out.println(\"===========2===========\"); return true; &#125; System.out.println(\"===========3===========\"); request.getRequestDispatcher(\"/WEB-INF/jsp/login.jsp\").forward(request, response); return false; &#125; public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(\"执行后\"); &#125; public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(\"清理\"); &#125;&#125; 在Springmvc的配置文件中注册拦截器 1234567891011&lt;!--关于拦截器的配置--&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--/** 包括路径及其子路径--&gt; &lt;!--/admin/* 拦截的是/admin/add等等这种 , /admin/add/user不会被拦截--&gt; &lt;!--/admin/** 拦截的是/admin/下的所有--&gt; &lt;mvc:mapping path=\"/user/**\"/&gt; &lt;!--bean配置的就是拦截器--&gt; &lt;bean class=\"cn.com.codingce.config.LoginIntercepetor\"/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 文件上传和下载 准备工作 文件上传是项目开发中最常见的功能之一 ,springMVC 可以很好的支持文件上传，但是SpringMVC上下文中默认没有装配MultipartResolver，因此默认情况下其不能处理文件上传工作。如果想使用Spring的文件上传功能，则需要在上下文中配置MultipartResolver。 前端表单要求：为了能上传文件，必须将表单的method设置为POST，并将enctype设置为multipart/form-data。只有在这样的情况下，浏览器才会把用户选择的文件以二进制数据发送给服务器； 对表单中的 enctype 属性做个详细的说明： application/x-www=form-urlencoded：默认方式，只处理表单域中的 value 属性值，采用这种编码方式的表单会将表单域中的值处理成 URL 编码方式。 multipart/form-data：这种编码方式会以二进制流的方式来处理表单数据，这种编码方式会把文件域指定文件的内容也封装到请求参数中，不会对字符编码。 text/plain：除了把空格转换为 “+” 号外，其他字符都不做编码处理，这种方式适用直接通过表单发送邮件。 1234&lt;form action=\"\" enctype=\"multipart/form-data\" method=\"post\"&gt; &lt;input type=\"file\" name=\"file\"/&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt; 一旦设置了enctype为multipart/form-data，浏览器即会采用二进制流的方式来处理表单数据，而对于文件上传的处理则涉及在服务器端解析原始的HTTP响应。在2003年，Apache Software Foundation发布了开源的Commons FileUpload组件，其很快成为Servlet/JSP程序员上传文件的最佳选择。 Servlet3.0规范已经提供方法来处理文件上传，但这种上传需要在Servlet中完成。 而Spring MVC则提供了更简单的封装。 Spring MVC为文件上传提供了直接的支持，这种支持是用即插即用的MultipartResolver实现的。 Spring MVC使用Apache Commons FileUpload技术实现了一个MultipartResolver实现类： CommonsMultipartResolver。因此，SpringMVC的文件上传还需要依赖Apache Commons FileUpload的组件。 文件上传 导入文件上传的jar包，commons-fileupload ， Maven会自动帮我们导入他的依赖包 commons-io包； 123456789101112&lt;!--文件上传--&gt;&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.3&lt;/version&gt;&lt;/dependency&gt;&lt;!--servlet-api导入高版本的--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt;&lt;/dependency&gt; 配置bean：multipartResolver 【注意！！！这个bena的id必须为：multipartResolver ， 否则上传文件会报400的错误！在这里栽过坑,教训！】 123456789&lt;!--文件上传配置--&gt;&lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;!-- 请求的编码格式，必须和jSP的pageEncoding属性一致，以便正确读取表单的内容，默认为ISO-8859-1 --&gt; &lt;property name=\"defaultEncoding\" value=\"utf-8\"/&gt; &lt;!-- 上传文件大小上限，单位为字节（10485760=10M） --&gt; &lt;property name=\"maxUploadSize\" value=\"10485760\"/&gt; &lt;property name=\"maxInMemorySize\" value=\"40960\"/&gt;&lt;/bean&gt; CommonsMultipartFile 的 常用方法： String getOriginalFilename()：获取上传文件的原名 InputStream getInputStream()：获取文件流 void transferTo(File dest)：将上传文件保存到一个目录文件中 编写前端页面 1234&lt;form action=\"/upload\" enctype=\"multipart/form-data\" method=\"post\"&gt; &lt;input type=\"file\" name=\"file\"/&gt; &lt;input type=\"submit\" value=\"upload\"&gt;&lt;/form&gt; Controller 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package cn.com.codingce.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.multipart.commons.CommonsMultipartFile;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.URLEncoder;@Controllerpublic class FileController &#123; //@RequestParam(\"file\") 将name=file控件得到的文件封装成CommonsMultipartFile 对象 //批量上传CommonsMultipartFile则为数组即可 @RequestMapping(\"/upload\") public String fileUpload(@RequestParam(\"file\") CommonsMultipartFile file , HttpServletRequest request) throws IOException &#123; //获取文件名 : file.getOriginalFilename(); String uploadFileName = file.getOriginalFilename(); //如果文件名为空，直接回到首页！ if (\"\".equals(uploadFileName))&#123; return \"redirect:/index.jsp\"; &#125; System.out.println(\"上传文件名 : \"+uploadFileName); //上传路径保存设置 String path = request.getServletContext().getRealPath(\"/upload\"); //如果路径不存在，创建一个 File realPath = new File(path); if (!realPath.exists())&#123; realPath.mkdir(); &#125; System.out.println(\"上传文件保存地址：\"+realPath); InputStream is = file.getInputStream(); //文件输入流 OutputStream os = new FileOutputStream(new File(realPath,uploadFileName)); //文件输出流 //读取写出 int len=0; byte[] buffer = new byte[1024]; while ((len=is.read(buffer))!=-1)&#123; os.write(buffer,0,len); os.flush(); &#125; os.close(); is.close(); return \"redirect:/index.jsp\"; &#125;&#125; 采用file.Transto 来保存上传的文件 编写Controller 1234567891011121314151617181920/* * 采用file.Transto 来保存上传的文件 */ @RequestMapping(\"/upload2\") public String fileUpload2(@RequestParam(\"file\") CommonsMultipartFile file, HttpServletRequest request) throws IOException &#123; //上传路径保存设置 String path = request.getServletContext().getRealPath(\"/upload\"); File realPath = new File(path); if (!realPath.exists())&#123; realPath.mkdir(); &#125; //上传文件地址 System.out.println(\"上传文件保存地址：\"+realPath); //通过CommonsMultipartFile的方法直接写文件（注意这个时候） file.transferTo(new File(realPath +\"/\"+ file.getOriginalFilename())); return \"redirect:/index.jsp\"; &#125; 前端表单提交地址修改 访问提交测试，OK！ 文件下载 文件下载步骤： 设置 response 响应头 读取文件 – InputStream 写出文件 – OutputStream 执行操作 关闭流 （先开后关） 代码实现： 12345678910111213141516171819202122232425262728293031@RequestMapping(value=\"/download\") public String downloads(HttpServletResponse response , HttpServletRequest request) throws Exception&#123; //要下载的图片地址 String path = request.getServletContext().getRealPath(\"/upload\"); String fileName = \"1.jpg\"; //1、设置response 响应头 response.reset(); //设置页面不缓存,清空buffer response.setCharacterEncoding(\"UTF-8\"); //字符编码 response.setContentType(\"multipart/form-data\"); //二进制传输数据 //设置响应头 response.setHeader(\"Content-Disposition\", \"attachment;fileName=\"+ URLEncoder.encode(fileName, \"UTF-8\")); File file = new File(path,fileName); //2、 读取文件--输入流 InputStream input=new FileInputStream(file); //3、 写出文件--输出流 OutputStream out = response.getOutputStream(); byte[] buff =new byte[1024]; int index=0; //4、执行 写出操作 while((index= input.read(buff))!= -1)&#123; out.write(buff, 0, index); out.flush(); &#125; out.close(); input.close(); return null; &#125; 前端 1&lt;a href=\"/download\"&gt;点击下载&lt;/a&gt;","categories":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://i.codingce.com.cn/categories/SpringMVC/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://i.codingce.com.cn/tags/SpringMVC/"}]},{"title":"Ajax研究","slug":"Ajax研究","date":"2020-08-06T05:13:06.000Z","updated":"2020-12-13T04:41:40.422Z","comments":true,"path":"2020/08/06/Ajax研究/","link":"","permalink":"http://i.codingce.com.cn/2020/08/06/Ajax%E7%A0%94%E7%A9%B6/","excerpt":"","text":"简介 AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。 AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 Ajax 不是一种新的编程语言，而是一种用于创建更好更快以及交互性更强的Web应用程序的技术。 在 2005 年，Google 通过其 Google Suggest 使 AJAX 变得流行起来。Google Suggest能够自动帮你完成搜索单词。 Google Suggest 使用 AJAX 创造出动态性极强的 web 界面：当您在谷歌的搜索框输入关键字时，JavaScript 会把这些字符发送到服务器，然后服务器会返回一个搜索建议的列表。 就和国内百度的搜索框一样! 传统的网页(即不用ajax技术的网页)，想要更新内容或者提交一个表单，都需要重新加载整个网页。 使用ajax技术的网页，通过在后台服务器进行少量的数据交换，就可以实现异步局部更新。 使用Ajax，用户可以创建接近本地桌面应用的直接、高可用、更丰富、更动态的Web用户界面。 伪造Ajax 我们可以使用前端的一个标签来伪造一个ajax的样子。iframe标签 新建一个module ：sspringmvc-06-ajax ， 导入web支持！ 编写一个 ajax-frame.html 使用 iframe 测试，感受下效果 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;掌上编程&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=\"text/javascript\"&gt; window.onload = function()&#123; var myDate = new Date(); document.getElementById('currentTime').innerText = myDate.getTime(); &#125;; function LoadPage()&#123; var targetUrl = document.getElementById('url').value; console.log(targetUrl); document.getElementById(\"iframePosition\").src = targetUrl; &#125;&lt;/script&gt;&lt;div&gt; &lt;p&gt;请输入要加载的地址：&lt;span id=\"currentTime\"&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt; &lt;input id=\"url\" type=\"text\" value=\"https://www.baidu.com/\"/&gt; &lt;input type=\"button\" value=\"提交\" onclick=\"LoadPage()\"&gt; &lt;/p&gt;&lt;/div&gt;&lt;div&gt; &lt;h3&gt;加载页面位置：&lt;/h3&gt; &lt;iframe id=\"iframePosition\" style=\"width: 100%;height: 500px;\"&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 使用IDEA开浏览器测试一下！ 利用AJAX可以做： 注册时，输入用户名自动检测用户是否已经存在。 登陆时，提示用户名密码错误 删除数据行时，将行ID发送到后台，后台在数据库中删除，数据库删除成功后，在页面DOM中将数据行也删除。 …等等 jQuery.ajax 纯JS原生实现Ajax， 直接使用jquery提供的 Ajax的核心是XMLHttpRequest对象(XHR)。XHR为向服务器发送请求和解析服务器响应提供了接口。能够以异步方式从服务器获取新数据。 jQuery 提供多个与 AJAX 有关的方法。 通过 jQuery AJAX 方法，您能够使用 HTTP Get 和 HTTP Post 从远程服务器上请求文本、HTML、XML 或 JSON – 同时您能够把这些外部数据直接载入网页的被选元素中。 jQuery 不是生产者，而是大自然搬运工。 jQuery Ajax本质就是 XMLHttpRequest，对他进行了封装，方便调用！ 123456789101112131415161718192021jQuery.ajax(...) 部分参数： url：请求地址 type：请求方式，GET、POST（1.9.0之后用method） headers：请求头 data：要发送的数据 contentType：即将发送信息至服务器的内容编码类型(默认: \"application/x-www-form-urlencoded; charset=UTF-8\") async：是否异步 timeout：设置请求超时时间（毫秒） beforeSend：发送请求前执行的函数(全局) complete：完成之后执行的回调函数(全局) success：成功之后执行的回调函数(全局) error：失败之后执行的回调函数(全局) accepts：通过请求头发送给服务器，告诉服务器当前客户端可接受的数据类型 dataType：将服务器端返回的数据转换成指定类型 \"xml\": 将服务器端返回的内容转换成xml格式 \"text\": 将服务器端返回的内容转换成普通文本格式 \"html\": 将服务器端返回的内容转换成普通文本格式，在插入DOM中时，如果包含JavaScript标签，则会尝试去执行。 \"script\": 尝试将返回值当作JavaScript去执行，然后再将服务器端返回的内容转换成普通文本格式 \"json\": 将服务器端返回的内容转换成相应的JavaScript对象 \"jsonp\": JSONP 格式使用 JSONP 形式调用函数时，如 \"myurl?callback=?\" jQuery 将自动替换 ? 为正确的函数名，以执行回调函数 我们来个简单的测试，使用最原始的HttpServletResponse处理 , .最简单 , 最通用 配置web.xml 和 springmvc的配置文件，复制上面案例的即可 【记得静态资源过滤和注解驱动配置上】 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;/web-app&gt; 编写一个AjaxController 1234567891011121314151617181920212223242526272829303132package cn.com.codingce.controller;import cn.com.codingce.pojo.User;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.ArrayList;import java.util.List;@RestControllerpublic class AjaxController &#123; @RequestMapping(\"/t1\") public String test1(Model model) &#123; model.addAttribute(\"msg\", \"hello\"); return \"hello\"; &#125; @RequestMapping(\"a1\") public void a1(String name, HttpServletResponse response) throws IOException &#123; System.out.println(\"a1:param=&gt;\" + name); if (\"掌上\".equals(name)) &#123; response.getWriter().print(true); &#125; else &#123; response.getWriter().print(false); &#125; &#125;&#125; 编写index.jsp测试 1234567891011121314151617181920212223242526272829303132&lt;%-- Created by IntelliJ IDEA. User: xzMa Date: 2020/8/6 Time: 13:39 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;%--&lt;script src=\"https://code.jquery.com/jquery-3.1.1.min.js\"&gt;&lt;/script&gt;--%&gt; &lt;script src=\"$&#123;pageContext.request.contextPath&#125;/statics/js/jquery-3.5.1.js\"&gt;&lt;/script&gt; &lt;script&gt; function a1()&#123; $.post(&#123; url:\"$&#123;pageContext.request.contextPath&#125;/a1\", data:&#123;'name':$(\"#txtName\").val()&#125;, success:function (data, status) &#123; alert(data); alert(status); &#125; &#125;); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;%--失去焦点的时候, 发起一个请求(携带信息)到后台--%&gt; &lt;%--onblur：失去焦点触发事件--%&gt; 用户名:&lt;input type=\"text\" id=\"txtName\" onblur=\"a1()\"/&gt; &lt;/body&gt;&lt;/html&gt; 启动tomcat测试！打开浏览器的控制台，当我们鼠标离开输入框的时候，可以看到发出了一个ajax的请求！是后台返回给我们的结果！测试成功！ Springmvc实现 实体类user 1234567891011package cn.com.codingce.pojo;public class User &#123; private String name; private int age; private String sex; public User() &#123; &#125;&#125; 我们来获取一个集合对象，展示到前端页面 1234567891011@RequestMapping(\"/a2\")public List&lt;User&gt; a2() &#123; ArrayList&lt;User&gt; list = new ArrayList&lt;User&gt;(); //添加数据 list.add(new User(\"掌上编程\", 1, \"男\")); list.add(new User(\"掌上编程\", 2, \"男\")); list.add(new User(\"掌上编程\", 3, \"男\")); list.add(new User(\"掌上编程\", 4, \"男\")); list.add(new User(\"掌上编程\", 5, \"男\")); return list;&#125; 前端页面 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;%-- Created by IntelliJ IDEA. User: xzMa Date: 2020/8/6 Time: 18:31 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"$&#123;pageContext.request.contextPath&#125;/statics/js/jquery-3.5.1.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; $(\"#btn\").click(function () &#123; $.post(\"$&#123;pageContext.request.contextPath&#125;/a2\",function (data) &#123; console.log(data) var html=\"\"; for (var i = 0; i &lt;data.length ; i++) &#123; html+= \"&lt;tr&gt;\" + \"&lt;td&gt;\" + data[i].name + \"&lt;/td&gt;\" + \"&lt;td&gt;\" + data[i].age + \"&lt;/td&gt;\" + \"&lt;td&gt;\" + data[i].sex + \"&lt;/td&gt;\" + \"&lt;/tr&gt;\" &#125; $(\"#content\").html(html); &#125;); &#125;) &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=\"button\" id=\"btn\" value=\"获取数据\"/&gt;&lt;table width=\"80%\" align=\"center\"&gt; &lt;tr&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;td&gt;性别&lt;/td&gt; &lt;/tr&gt; &lt;tbody id=\"content\"&gt; &lt;/tbody&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 成功实现了数据回显！可以体会一下Ajax的好处！ 注册提示效果 Controller 1234567891011121314151617181920@RequestMapping(\"/a3\")public String ajax3(String name,String pwd)&#123; String msg = \"\"; //模拟数据库中存在数据 if (name!=null)&#123; if (\"admin\".equals(name))&#123; msg = \"OK\"; &#125;else &#123; msg = \"用户名输入错误\"; &#125; &#125; if (pwd!=null)&#123; if (\"123456\".equals(pwd))&#123; msg = \"OK\"; &#125;else &#123; msg = \"密码输入有误\"; &#125; &#125; return msg; //由于@RestController注解，将msg转成json格式返回&#125; 前端页面 login.jsp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;ajax&lt;/title&gt; &lt;script src=\"$&#123;pageContext.request.contextPath&#125;/statics/js/jquery-3.1.1.min.js\"&gt;&lt;/script&gt; &lt;script&gt; function a1()&#123; $.post(&#123; url:\"$&#123;pageContext.request.contextPath&#125;/a3\", data:&#123;'name':$(\"#name\").val()&#125;, success:function (data) &#123; if (data.toString()=='OK')&#123; $(\"#userInfo\").css(\"color\",\"green\"); &#125;else &#123; $(\"#userInfo\").css(\"color\",\"red\"); &#125; $(\"#userInfo\").html(data); &#125; &#125;); &#125; function a2()&#123; $.post(&#123; url:\"$&#123;pageContext.request.contextPath&#125;/a3\", data:&#123;'pwd':$(\"#pwd\").val()&#125;, success:function (data) &#123; if (data.toString()=='OK')&#123; $(\"#pwdInfo\").css(\"color\",\"green\"); &#125;else &#123; $(\"#pwdInfo\").css(\"color\",\"red\"); &#125; $(\"#pwdInfo\").html(data); &#125; &#125;); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt; 用户名:&lt;input type=\"text\" id=\"name\" onblur=\"a1()\"/&gt; &lt;span id=\"userInfo\"&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt; 密码:&lt;input type=\"text\" id=\"pwd\" onblur=\"a2()\"/&gt; &lt;span id=\"pwdInfo\"&gt;&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://i.codingce.com.cn/categories/SpringMVC/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://i.codingce.com.cn/tags/SpringMVC/"}]},{"title":"杀死一只知更鸟","slug":"杀死一只知更鸟","date":"2020-08-06T03:58:29.000Z","updated":"2020-12-13T04:41:40.453Z","comments":true,"path":"2020/08/06/杀死一只知更鸟/","link":"","permalink":"http://i.codingce.com.cn/2020/08/06/%E6%9D%80%E6%AD%BB%E4%B8%80%E5%8F%AA%E7%9F%A5%E6%9B%B4%E9%B8%9F/","excerpt":"","text":"纵观历史，社会总是对新兴而不同的事物感到排斥。《杀死一只知更鸟》向我们展示了一个鲜明的例子，仅仅因为那个人是不同的黑人，社会就可以对一个无辜者使用各种残忍的手段无所而不用其极。故事发生在虚构的Alabama州小镇Maycomb。本书讨论了美国司法以及社会的不公正和种族偏见的问题。 Maycomb镇让人想起那些人们过着心满意足的生活的古老小镇，那里的人们过着一种平静得令人不安的生活。故事发生在一个从种族歧视艰难走向种族平等的社会。白人社区在政治上主导着这个城市，他们有着严格的种族区分和社会政治等级制度。 令人可笑的是，甚至房屋在城镇中的位置本身就能说明一个家庭在社会阶层中的地位。镇上最富有的人拥有高耸在山顶的豪宅，而最穷的人则住在山下。即使这样，哪怕是有体面的工作的非洲裔美国人，也只能住在城镇的底层。 根据书中的描写，Maycomb镇的普世道德观念深深植根于市民对非典型事物的偏见中。因此，Boo Radley虽然是白种人，却因打破常规的世俗性格而遭受着小镇群体偏见的折磨。Boo Radley，这个与众不同的邻居几乎从不从他破旧的房子里出来。主人公Scout讲述了年轻的Boo Radley因触犯法律而被父亲监禁的故事。直到15年后他刺伤了他的父亲，人们才再一次听到他的名字。从那以后，他好似陶渊明一样独来独往于世间，意欲远离一切社会的虚伪。 Tom Robinson，很不幸的是，他生来就是黑皮肤，一生中大部分时间都在农场帮工，付出了极高的劳动成本，但生活条件却毫无改善。另一方面，Bob Ewell总是喝得醉醺醺的，给家人干活几乎不动一根手指头。他属于当地最穷的一个家庭。他们代表着受压迫和无知的人。 Maycomb是当时美国社会乃至整个人类世界社会的一个缩影，特别是在美国南方各州。Harper Lee来自阿拉巴马州。和故事的主人公Jean Louise以及Scout Finch一样，Lee的父亲也是一名律师。然而，Lee却在一个访谈中强调，书中的事件完全是虚构的，书中人物的灵感都来自自己生活中的朋友们。 这个故事备受关注的焦点——Tom Robinson的案件与1931年的Scottsboro案件有相似之处。该案9名非裔美国人被指控强奸了两名白人女性。尽管法官怀疑原告在每一次上诉中都在其含糊其辞的陈述中撒谎，但是9名被告中仍有5人被判监禁。 作者试图通过Scout的纯真来拷问镇上的种族主义思维，探讨其对于非普遍族群的伤害。所以我们看到了Scout也在试图寻找为什么有些人会被区别对待以及为什么镇上的人从来没有试图改变现状的原因。 以一种和平、理性、非暴力的方式在不对抗的情况下增强白人群体的平等意识是让美国社会开始发生改变的一种微妙的方式。然而，正如书中所言，至关重要的是，一个人必须要学会克服社会范式并且树立不完全一致的价值观念，因为不同往往意味着坚持变革。 One must learn to overcome social norms and decide to be different because being different might mean standing up for change. 《杀死一只知更鸟》生动地表现了种族偏见的时代的大背景以及孩子们的天真烂漫，它既融合了幼稚天真的写作风格又体现了有别于小孩子的成熟洞察，同时基于作者的生活经历，也表达了对美国南方小镇生活的一种怀恋。最终达到的艺术结果则是：小说在一个特殊而且独特的时间与地点通过一系列令人印象深刻的事情来描述令人深爱的童年记忆以及主人公对世间邪恶的首次认识过程来研究公平公正的意义和无辜的沦丧。","categories":[{"name":"随记","slug":"随记","permalink":"http://i.codingce.com.cn/categories/%E9%9A%8F%E8%AE%B0/"}],"tags":[{"name":"随记","slug":"随记","permalink":"http://i.codingce.com.cn/tags/%E9%9A%8F%E8%AE%B0/"}]},{"title":"SSM整合","slug":"SSM整合","date":"2020-08-05T08:35:54.000Z","updated":"2020-12-13T04:41:40.422Z","comments":true,"path":"2020/08/05/SSM整合/","link":"","permalink":"http://i.codingce.com.cn/2020/08/05/SSM%E6%95%B4%E5%90%88/","excerpt":"","text":"整合SSM 环境要求 环境： IDEA MySQL 5.7.19 Tomcat 9 Maven 3.6 要求： 需要熟练掌握MySQL数据库，Spring，JavaWeb及MyBatis知识，简单的前端知识 数据库环境 创建一个存放书籍数据的数据库表 123456789101112131415161718CREATE DATABASE `ssmbuild`;USE `ssmbuild`;DROP TABLE IF EXISTS `books`;CREATE TABLE `books` (`bookID` INT(10) NOT NULL AUTO_INCREMENT COMMENT '书id',`bookName` VARCHAR(100) NOT NULL COMMENT '书名',`bookCounts` INT(11) NOT NULL COMMENT '数量',`detail` VARCHAR(200) NOT NULL COMMENT '描述',KEY `bookID` (`bookID`)) ENGINE=INNODB DEFAULT CHARSET=utf8INSERT INTO `books`(`bookID`,`bookName`,`bookCounts`,`detail`)VALUES(1,'Java',1,'从入门到放弃'),(2,'MySQL',10,'从删库到跑路'),(3,'Linux',5,'从进门到进牢'); 基本环境搭建 新建一Maven项目！ssmbuild ， 添加web的支持 导入相关的pom依赖！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;dependencies&gt; &lt;!--Junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;!--数据库驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--Servlet - JSP --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--Mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--Spring--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; Maven资源过滤设置 1234567891011121314151617181920&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 建立基本结构和配置框架！ cn.com.codingce.pojo cn.com.codingce.dao cn.com.codingce.service cn.com.codingce.controller mybatis-config.xml 1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt;&lt;/configuration&gt; applicationContext.xml 1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;&lt;/beans&gt; Mybatis层编写 数据库配置文件 database.properties 1234jdbc.driver=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql://cdb-q9atzwrq.bj.tencentcdb.com:10167/ssmbuild?useSSL=true&amp;useUnicode=truejdbc.username=rootjdbc.password=123456 编写MyBatis的核心配置文件 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!--配置数据源. 交给Spring去做--&gt; &lt;typeAliases&gt; &lt;package name=\"cn.com.codingce.pojo\"/&gt; &lt;/typeAliases&gt;&lt;/configuration&gt; 编写数据库对应的实体类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package cn.com.codingce.pojo;public class Books &#123; private int bookID; private String bookName; private int bookCounts; private String detail; public Books() &#123; &#125; public Books(int bookID, String bookName, int bookCounts, String detail) &#123; this.bookID = bookID; this.bookName = bookName; this.bookCounts = bookCounts; this.detail = detail; &#125; public int getBookID() &#123; return bookID; &#125; public void setBookID(int bookID) &#123; this.bookID = bookID; &#125; public String getBookName() &#123; return bookName; &#125; public void setBookName(String bookName) &#123; this.bookName = bookName; &#125; public int getBookCounts() &#123; return bookCounts; &#125; public void setBookCounts(int bookCounts) &#123; this.bookCounts = bookCounts; &#125; public String getDetail() &#123; return detail; &#125; public void setDetail(String detail) &#123; this.detail = detail; &#125; @Override public String toString() &#123; return \"Books&#123;\" + \"bookID=\" + bookID + \", bookName='\" + bookName + '\\'' + \", bookCounts=\" + bookCounts + \", detail='\" + detail + '\\'' + '&#125;'; &#125;&#125; 编写Dao层的 Mapper接口！ 1234567891011121314151617181920212223package cn.com.codingce.dao;import cn.com.codingce.pojo.Books;import java.util.List;public interface BookMapper &#123; //增加一个Book int addBook(Books book); //根据id删除一个Book int deleteBookById(int id); //更新Book int updateBook(Books books); //根据id查询,返回一个Book Books queryBookById(int id); //查询全部Book,返回list集合 List&lt;Books&gt; queryAllBook();&#125; 编写接口对应的 Mapper.xml 文件。需要导入MyBatis的包； 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.kuang.dao.BookMapper\"&gt; &lt;!--增加一个Book--&gt; &lt;insert id=\"addBook\" parameterType=\"Books\"&gt; insert into ssmbuild.books(bookName,bookCounts,detail) values (#&#123;bookName&#125;, #&#123;bookCounts&#125;, #&#123;detail&#125;) &lt;/insert&gt; &lt;!--根据id删除一个Book--&gt; &lt;delete id=\"deleteBookById\" parameterType=\"int\"&gt; delete from ssmbuild.books where bookID=#&#123;bookID&#125; &lt;/delete&gt; &lt;!--更新Book--&gt; &lt;update id=\"updateBook\" parameterType=\"Books\"&gt; update ssmbuild.books set bookName = #&#123;bookName&#125;,bookCounts = #&#123;bookCounts&#125;,detail = #&#123;detail&#125; where bookID = #&#123;bookID&#125; &lt;/update&gt; &lt;!--根据id查询,返回一个Book--&gt; &lt;select id=\"queryBookById\" resultType=\"Books\"&gt; select * from ssmbuild.books where bookID = #&#123;bookID&#125; &lt;/select&gt; &lt;!--查询全部Book--&gt; &lt;select id=\"queryAllBook\" resultType=\"Books\"&gt; SELECT * from ssmbuild.books &lt;/select&gt;&lt;/mapper&gt; 编写Service层的接口和实现类 接口： 12345678910111213141516171819package cn.com.codingce.service;import cn.com.codingce.pojo.Books;import java.util.List;//BookService:底下需要去实现,调用dao层public interface BookService &#123; //增加一个Book int addBook(Books book); //根据id删除一个Book int deleteBookById(int id); //更新Book int updateBook(Books books); //根据id查询,返回一个Book Books queryBookById(int id); //查询全部Book,返回list集合 List&lt;Books&gt; queryAllBook();&#125; 实现类： 123456789101112131415161718192021222324252627282930313233343536package cn.com.codingce.service;import cn.com.codingce.dao.BookMapper;import cn.com.codingce.pojo.Books;import java.util.List;public class BookServiceImpl implements BookService &#123; //调用dao层的操作，设置一个set接口，方便Spring管理 private BookMapper bookMapper; public void setBookMapper(BookMapper bookMapper) &#123; this.bookMapper = bookMapper; &#125; public int addBook(Books book) &#123; return bookMapper.addBook(book); &#125; public int deleteBookById(int id) &#123; return bookMapper.deleteBookById(id); &#125; public int updateBook(Books books) &#123; return bookMapper.updateBook(books); &#125; public Books queryBookById(int id) &#123; return bookMapper.queryBookById(id); &#125; public List&lt;Books&gt; queryAllBook() &#123; return bookMapper.queryAllBook(); &#125;&#125; OK，到此，底层需求操作编写完毕！ Spring层 配置Spring整合MyBatis，我们这里数据源使用c3p0连接池； 我们去编写Spring整合Mybatis的相关的配置文件；spring-dao.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 配置整合mybatis --&gt; &lt;!-- 1.关联数据库文件 --&gt; &lt;context:property-placeholder location=\"classpath:database.properties\"/&gt; &lt;!-- 2.数据库连接池 --&gt; &lt;!--数据库连接池 dbcp 半自动化操作 不能自动连接 c3p0 自动化操作（自动的加载配置文件 并且设置到对象里面） --&gt; &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;!-- 配置连接池属性 --&gt; &lt;property name=\"driverClass\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;property name=\"jdbcUrl\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"user\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt; &lt;!-- c3p0连接池的私有属性 --&gt; &lt;property name=\"maxPoolSize\" value=\"30\"/&gt; &lt;property name=\"minPoolSize\" value=\"10\"/&gt; &lt;!-- 关闭连接后不自动commit --&gt; &lt;property name=\"autoCommitOnClose\" value=\"false\"/&gt; &lt;!-- 获取连接超时时间 --&gt; &lt;property name=\"checkoutTimeout\" value=\"10000\"/&gt; &lt;!-- 当获取连接失败重试次数 --&gt; &lt;property name=\"acquireRetryAttempts\" value=\"2\"/&gt; &lt;/bean&gt; &lt;!-- 3.配置SqlSessionFactory对象 --&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;!-- 配置MyBaties全局配置文件:mybatis-config.xml --&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/&gt; &lt;/bean&gt; &lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口注入到spring容器中 --&gt; &lt;!--解释 ：https://www.cnblogs.com/jpfss/p/7799806.html--&gt; &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;!-- 注入sqlSessionFactory --&gt; &lt;property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"/&gt; &lt;!-- 给出需要扫描Dao接口包 --&gt; &lt;property name=\"basePackage\" value=\"com.kuang.dao\"/&gt; &lt;/bean&gt;&lt;/beans&gt; Spring整合service层 123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 扫描service相关的bean --&gt; &lt;context:component-scan base-package=\"cn.com.codingce.service\" /&gt; &lt;!--BookServiceImpl注入到IOC容器中--&gt; &lt;bean id=\"BookServiceImpl\" class=\"cn.com.codingce.service.BookServiceImpl\"&gt; &lt;property name=\"bookMapper\" ref=\"bookMapper\"/&gt; &lt;/bean&gt; &lt;!-- 配置事务管理器 --&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;/bean&gt;&lt;/beans&gt; Spring层搞定！再次理解一下，Spring就是一个大杂烩，一个容器！对吧！ SpringMVC层 web.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;!--DispatcherServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!--一定要注意:我们这里加载的是总的配置文件，之前被这里坑了！--&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--encodingFilter--&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt; org.springframework.web.filter.CharacterEncodingFilter &lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!--Session过期时间--&gt; &lt;session-config&gt; &lt;session-timeout&gt;15&lt;/session-timeout&gt; &lt;/session-config&gt;&lt;/web-app&gt; spring-mvc.xml 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!-- 配置SpringMVC --&gt; &lt;!-- 1.开启SpringMVC注解驱动 --&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 2.静态资源默认servlet配置--&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!-- 3.配置jsp 显示ViewResolver视图解析器 --&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"viewClass\" value=\"org.springframework.web.servlet.view.JstlView\" /&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\" /&gt; &lt;property name=\"suffix\" value=\".jsp\" /&gt; &lt;/bean&gt; &lt;!-- 4.扫描web相关的bean --&gt; &lt;context:component-scan base-package=\"cn.com.codingce.controller\" /&gt;&lt;/beans&gt; Spring配置整合文件，applicationContext.xml 1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;import resource=\"spring-dao.xml\"/&gt; &lt;import resource=\"spring-service.xml\"/&gt; &lt;import resource=\"spring-mvc.xml\"/&gt; &lt;/beans&gt; 配置文件，暂时结束！ Controller 和 视图层编写 BookController 类编写 ， 方法一：查询全部书籍 12345678910111213141516171819202122232425262728293031package cn.com.codingce.controller;import cn.com.codingce.pojo.Books;import cn.com.codingce.service.BookService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import java.util.List;@Controller@RequestMapping(\"/book\")public class BookController &#123; //Controller调Service层 @Autowired @Qualifier(\"BookServiceImpl\") private BookService bookService; //查询全部书籍, 并且返回一个书籍展示页面 @RequestMapping(\"/allBook\") public String list(Model model) &#123; List&lt;Books&gt; books = bookService.queryAllBook(); model.addAttribute(\"list\", books); return \"allBook\"; &#125;&#125; 编写首页 index.jsp 1234567891011121314151617181920212223242526272829&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\" %&gt;&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;首页&lt;/title&gt; &lt;style type=\"text/css\"&gt; a &#123; text-decoration: none; color: black; font-size: 18px; &#125; h3 &#123; width: 180px; height: 38px; margin: 100px auto; text-align: center; line-height: 38px; background: deepskyblue; border-radius: 4px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt; &lt;a href=\"$&#123;pageContext.request.contextPath&#125;/book/allBook\"&gt;点击进入列表页&lt;/a&gt;&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; 书籍列表页面 allbook.jsp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;书籍列表&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;!-- 引入 Bootstrap --&gt; &lt;link href=\"https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css\" rel=\"stylesheet\"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt; &lt;div class=\"row clearfix\"&gt; &lt;div class=\"col-md-12 column\"&gt; &lt;div class=\"page-header\"&gt; &lt;h1&gt; &lt;small&gt;书籍列表 —— 显示所有书籍&lt;/small&gt; &lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-4 column\"&gt; &lt;a class=\"btn btn-primary\" href=\"$&#123;pageContext.request.contextPath&#125;/book/toAddBook\"&gt;新增&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"row clearfix\"&gt; &lt;div class=\"col-md-12 column\"&gt; &lt;table class=\"table table-hover table-striped\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;书籍编号&lt;/th&gt; &lt;th&gt;书籍名字&lt;/th&gt; &lt;th&gt;书籍数量&lt;/th&gt; &lt;th&gt;书籍详情&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;c:forEach var=\"book\" items=\"$&#123;requestScope.get('list')&#125;\"&gt; &lt;tr&gt; &lt;td&gt;$&#123;book.getBookID()&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.getBookName()&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.getBookCounts()&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.getDetail()&#125;&lt;/td&gt; &lt;td&gt; &lt;a href=\"$&#123;pageContext.request.contextPath&#125;/book/toUpdateBook?id=$&#123;book.getBookID()&#125;\"&gt;更改&lt;/a&gt; | &lt;a href=\"$&#123;pageContext.request.contextPath&#125;/book/del/$&#123;book.getBookID()&#125;\"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; BookController 类编写 ， 方法二：添加书籍 1234567891011@RequestMapping(\"/toAddBook\")public String toAddPaper() &#123; return \"addBook\";&#125;@RequestMapping(\"/addBook\")public String addPaper(Books books) &#123; System.out.println(books); bookService.addBook(books); return \"redirect:/book/allBook\";&#125; 添加书籍页面：addBook.jsp 12345678910111213141516171819202122232425262728293031323334353637&lt;%-- Created by IntelliJ IDEA. User: xzMa Date: 2020/8/6 Time: 8:16 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;新增书籍&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;!-- 引入 Bootstrap --&gt; &lt;link href=\"https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css\" rel=\"stylesheet\"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt; &lt;div class=\"row clearfix\"&gt; &lt;div class=\"col-md-12 column\"&gt; &lt;div class=\"page-header\"&gt; &lt;h1&gt; &lt;small&gt;新增书籍&lt;/small&gt; &lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;form action=\"$&#123;pageContext.request.contextPath&#125;/book/addBook\" method=\"post\"&gt; 书籍名称：&lt;input type=\"text\" name=\"bookName\"&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; 书籍数量：&lt;input type=\"text\" name=\"bookCounts\"&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; 书籍详情：&lt;input type=\"text\" name=\"detail\"&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"添加\"&gt; &lt;/form&gt;&lt;/div&gt; BookController 类编写 ， 方法三：修改书籍 12345678910111213141516@RequestMapping(\"/toUpdateBook\") public String toUpdateBook(Model model, int id) &#123; Books books = bookService.queryBookById(id); System.out.println(books); model.addAttribute(\"book\",books ); return \"updateBook\"; &#125; @RequestMapping(\"/updateBook\") public String updateBook(Model model, Books book) &#123; System.out.println(book); bookService.updateBook(book); Books books = bookService.queryBookById(book.getBookID()); model.addAttribute(\"books\", books); return \"redirect:/book/allBook\"; &#125; 修改书籍页面 updateBook.jsp 1234567891011121314151617181920212223242526272829303132333435363738&lt;%-- Created by IntelliJ IDEA. User: xzMa Date: 2020/8/6 Time: 8:18 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;修改信息&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;!-- 引入 Bootstrap --&gt; &lt;link href=\"https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css\" rel=\"stylesheet\"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt; &lt;div class=\"row clearfix\"&gt; &lt;div class=\"col-md-12 column\"&gt; &lt;div class=\"page-header\"&gt; &lt;h1&gt; &lt;small&gt;修改信息&lt;/small&gt; &lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;form action=\"$&#123;pageContext.request.contextPath&#125;/book/updateBook\" method=\"post\"&gt; &lt;input type=\"hidden\" name=\"bookID\" value=\"$&#123;book.getBookID()&#125;\"/&gt; 书籍名称：&lt;input type=\"text\" name=\"bookName\" value=\"$&#123;book.getBookName()&#125;\"/&gt; 书籍数量：&lt;input type=\"text\" name=\"bookCounts\" value=\"$&#123;book.getBookCounts()&#125;\"/&gt; 书籍详情：&lt;input type=\"text\" name=\"detail\" value=\"$&#123;book.getDetail() &#125;\"/&gt; &lt;input type=\"submit\" value=\"提交\"/&gt; &lt;/form&gt;&lt;/div&gt; BookController 类编写 ， 方法四：删除书籍 12345@RequestMapping(\"/del/&#123;bookId&#125;\")public String deleteBook(@PathVariable(\"bookId\") int id) &#123; bookService.deleteBookById(id); return \"redirect:/book/allBook\";&#125; 实现查询 123456789101112//查询书籍@RequestMapping(\"/queryBook\")public String queryBook(String queryBookName, Model model) &#123; System.out.println(queryBookName); Books books = bookService.queryBookName(queryBookName); List&lt;Books&gt; list = new ArrayList&lt;Books&gt;(); list.add(books); if (books == null) list = bookService.queryAllBook(); model.addAttribute(\"list\", list); return \"allBook\";&#125; 实现查询页面 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;书籍列表&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;!-- 引入 Bootstrap --&gt; &lt;link href=\"https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css\" rel=\"stylesheet\"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt; &lt;div class=\"row clearfix\"&gt; &lt;div class=\"col-md-12 column\"&gt; &lt;div class=\"page-header\"&gt; &lt;h1&gt; &lt;small&gt;书籍列表 —— 显示所有书籍&lt;/small&gt; &lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-4 column\"&gt; &lt;a class=\"btn btn-primary\" href=\"$&#123;pageContext.request.contextPath&#125;/book/toAddBook\"&gt;新增&lt;/a&gt; &lt;a class=\"btn btn-primary\" href=\"$&#123;pageContext.request.contextPath&#125;/book/allBook\"&gt;显示全部数据&lt;/a&gt; &lt;/div&gt; &lt;div class=\"col-md-8 column\"&gt; &lt;%--查询书籍--%&gt; &lt;form class=\"form-inline\" action=\"/book/queryBook\" method=\"post\" style=\"float: right\"&gt; &lt;span style=\"color: red; font-weight: bold\"&gt;$&#123;error&#125;&lt;/span&gt; &lt;input type=\"text\" name=\"queryBookName\" class=\"form-control\" placeholder=\"请输入要查询的书籍\"&gt; &lt;input type=\"submit\" value=\"查询\" class=\"btn btn-primary\"&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"row clearfix\"&gt; &lt;div class=\"col-md-12 column\"&gt; &lt;table class=\"table table-hover table-striped\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;书籍编号&lt;/th&gt; &lt;th&gt;书籍名字&lt;/th&gt; &lt;th&gt;书籍数量&lt;/th&gt; &lt;th&gt;书籍详情&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;c:forEach var=\"book\" items=\"$&#123;requestScope.get('list')&#125;\"&gt; &lt;tr&gt; &lt;td&gt;$&#123;book.getBookID()&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.getBookName()&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.getBookCounts()&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.getDetail()&#125;&lt;/td&gt; &lt;td&gt; &lt;a href=\"$&#123;pageContext.request.contextPath&#125;/book/toUpdateBook?id=$&#123;book.getBookID()&#125;\"&gt;更改&lt;/a&gt; | &lt;a href=\"$&#123;pageContext.request.contextPath&#125;/book/del/$&#123;book.getBookID()&#125;\"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 配置Tomcat，进行运行！ 到目前为止，这个SSM项目整合已经完全的OK了，可以直接运行进行测试！这个练习十分的重要，需要保证，不看任何东西，自己也可以完整的实现出来！ 项目结构图","categories":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://i.codingce.com.cn/categories/SpringMVC/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://i.codingce.com.cn/tags/SpringMVC/"}]},{"title":"JSON","slug":"json","date":"2020-08-04T10:44:16.000Z","updated":"2020-12-13T04:41:40.438Z","comments":true,"path":"2020/08/04/json/","link":"","permalink":"http://i.codingce.com.cn/2020/08/04/json/","excerpt":"","text":"什么是JSON？ JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式，目前使用特别广泛。 采用完全独立于编程语言的文本格式来存储和表示数据。 简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。 在 JavaScript 语言中，一切都是对象。因此，任何JavaScript 支持的类型都可以通过 JSON 来表示，例如字符串、数字、对象、数组等。看看他的要求和语法格式： 对象表示为键值对，数据由逗号分隔 花括号保存对象 方括号保存数组 JSON 键值对是用来保存 JavaScript 对象的一种方式，和 JavaScript 对象的写法也大同小异，键/值对组合中的键名写在前面并用双引号 “” 包裹，使用冒号 : 分隔，然后紧接着值： 123&#123;\"name\": \"掌上编程\"&#125;&#123;\"age\": \"3\"&#125;&#123;\"sex\": \"男\"&#125; 很多人搞不清楚 JSON 和 JavaScript 对象的关系，甚至连谁是谁都不清楚。其实，可以这么理解： JSON 是 JavaScript 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。 12var obj = &#123;a: 'Hello', b: 'World'&#125;; //这是一个对象，注意键名也是可以使用引号包裹的var json = '&#123;\"a\": \"Hello\", \"b\": \"World\"&#125;'; //这是一个 JSON 字符串，本质是一个字符串 JSON 和 JavaScript 对象互转 要实现从JSON字符串转换为JavaScript 对象，使用 JSON.parse() 方法： 12var obj = JSON.parse('&#123;\"a\": \"Hello\", \"b\": \"World\"&#125;');//结果是 &#123;a: 'Hello', b: 'World'&#125; 要实现从JavaScript 对象转换为JSON字符串，使用 JSON.stringify() 方法： 12var json = JSON.stringify(&#123;a: 'Hello', b: 'World'&#125;);//结果是 '&#123;\"a\": \"Hello\", \"b\": \"World\"&#125;' 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; //编写一个javascript var user = &#123; name : \"掌上编程\", age : 3, sex : \"男\" &#125; console.log(user); console.log(\"=============================\"); //将js对象转换为json对象 var json = JSON.stringify(user); console.log(json); console.log(\"=============================\"); //将JSON对象转化为JavaScript对象 var obj = JSON.parse(json); console.log(obj); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; Controller返回JSON数据 Jackson应该是目前比较好的json解析工具了 当然工具不止这一个，比如还有阿里巴巴的 fastjson 等等。 我们这里使用Jackson，使用它需要导入它的jar包； 123456&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.8&lt;/version&gt;&lt;/dependency&gt; 配置SpringMVC需要的配置 web.xml 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;!--1.注册servlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动顺序，数字越小，启动越早 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--所有请求都会被springmvc拦截 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; springmvc-servlet.xml 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt; &lt;context:component-scan base-package=\"cn.com.codingce.controller\"/&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"internalResourceViewResolver\"&gt; &lt;!-- 前缀 --&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\" /&gt; &lt;!-- 后缀 --&gt; &lt;property name=\"suffix\" value=\".jsp\" /&gt; &lt;/bean&gt;&lt;/beans&gt; 我们随便编写一个User的实体类，然后我们去编写我们的测试Controller; 发现出现了乱码问题，我们需要设置一下他的编码格式为utf-8，以及它返回的类型； 通过@RequestMaping的produces属性来实现，修改下代码 12//produces:指定响应体返回类型和编码@RequestMapping(value = \"/json1\",produces = \"application/json;charset=utf-8\") 代码优化 乱码统一解决 上一种方法比较麻烦，如果项目中有许多请求则每一个都要添加，可以通过Spring配置统一指定，这样就不用每次都去处理了！ 我们可以在springmvc的配置文件上添加一段消息StringHttpMessageConverter转换配置！ 1234567891011121314&lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults=\"true\"&gt; &lt;bean class=\"org.springframework.http.converter.StringHttpMessageConverter\"&gt; &lt;constructor-arg value=\"UTF-8\"/&gt; &lt;/bean&gt; &lt;bean class=\"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\"&gt; &lt;property name=\"objectMapper\"&gt; &lt;bean class=\"org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean\"&gt; &lt;property name=\"failOnEmptyBeans\" value=\"false\"/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt; 返回json字符串统一解决 在类上直接使用 @RestController ，这样子，里面所有的方法都只会返回 json 字符串了，不用再每一个都添加@ResponseBody ！我们在前后端分离开发中，一般都使用 @RestController ，十分便捷！ 测试集合输出 增加一个新的方法 1234567891011@RequestMapping(\"/json3\")public String json3() throws JsonProcessingException &#123; ObjectMapper mapper = new ObjectMapper(); //创建时间一个对象，java.util.Date Date date = new Date(); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(date); return str;&#125; 默认日期格式会变成一个数字，是1970年1月1日到当前日期的毫秒数！ Jackson 默认是会把时间转成timestamps形式 解决方案：取消timestamps形式 ， 自定义时间格式 1234567891011121314151617@RequestMapping(\"/json4\")public String json4() throws JsonProcessingException &#123; ObjectMapper mapper = new ObjectMapper(); //不使用时间戳的方式 mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); //自定义日期格式对象 SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); //指定日期格式 mapper.setDateFormat(sdf); Date date = new Date(); String str = mapper.writeValueAsString(date); return str;&#125; 运行结果 : 成功的输出了时间！ 抽取为工具类 如果要经常使用的话，这样是比较麻烦的，我们可以将这些代码封装到一个工具类中；我们去编写下 123456789101112131415161718192021222324252627282930package cn.com.codingce.utils;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.SerializationFeature;import java.text.SimpleDateFormat;public class JsonUtils &#123; public static String getJson(Object object) &#123; return getJson(object,\"yyyy-MM-dd HH:mm:ss\"); &#125; public static String getJson(Object object,String dateFormat) &#123; ObjectMapper mapper = new ObjectMapper(); //不使用时间差的方式 mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); //自定义日期格式对象 SimpleDateFormat sdf = new SimpleDateFormat(dateFormat); //指定日期格式 mapper.setDateFormat(sdf); try &#123; return mapper.writeValueAsString(object); &#125; catch (JsonProcessingException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 我们使用工具类，代码就更加简洁了！ 1234567@ResponseBody@RequestMapping(\"/json5\")public String json5() throws JsonProcessingException &#123; Date date = new Date(); String json = JsonUtils.getJson(date); return json;&#125; FastJson fastjson.jar是阿里开发的一款专门用于Java开发的包，可以方便的实现json对象与JavaBean对象的转换，实现JavaBean对象与json字符串的转换，实现json对象与json字符串的转换。实现json的转换方法很多，最后的实现结果都是一样的。 fastjson 的 pom依赖！ 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.60&lt;/version&gt;&lt;/dependency&gt; fastjson 三个主要的类： JSONObject 代表 json 对象 JSONObject实现了Map接口, 猜想 JSONObject底层操作是由Map实现的。 JSONObject对应json对象，通过各种形式的get()方法可以获取json对象中的数据，也可利用诸如size()，isEmpty()等方法获取&quot;键：值&quot;对的个数和判断是否为空。其本质是通过实现Map接口并调用接口中的方法完成的。 JSONArray 代表 json 对象数组 内部是有List接口中的方法来完成操作的。 JSON代表 JSONObject和JSONArray的转化 JSON类源码分析与使用 仔细观察这些方法，主要是实现json对象，json对象数组，javabean对象，json字符串之间的相互转化。 代码测试，我们新建一个FastJsonDemo 类 1234567891011121314151617181920212223242526272829303132333435363738394041package cn.com.codingce.controller;import cn.com.codingce.pojo.User;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;import java.util.ArrayList;import java.util.List;public class FastJsonDemo &#123; public static void main(String[] args) &#123; //创建一个对象 User user1 = new User(\"掌上编程\", 3, \"男\"); User user2 = new User(\"掌上编程2\", 3, \"男\"); User user3 = new User(\"掌上编程3\", 3, \"男\"); User user4 = new User(\"掌上编程4\", 3, \"男\"); List&lt;User&gt; list = new ArrayList&lt;User&gt;(); list.add(user1); list.add(user2); list.add(user3); list.add(user4); System.out.println(\"*******Java对象 转 JSON字符串*******\"); String str1 = JSON.toJSONString(list); System.out.println(\"JSON.toJSONString(list)==&gt;\"+str1); String str2 = JSON.toJSONString(user1); System.out.println(\"JSON.toJSONString(user1)==&gt;\"+str2); System.out.println(\"\\n****** JSON字符串 转 Java对象*******\"); User jp_user1=JSON.parseObject(str2,User.class); System.out.println(\"JSON.parseObject(str2,User.class)==&gt;\"+jp_user1); System.out.println(\"\\n****** Java对象 转 JSON对象 ******\"); JSONObject jsonObject1 = (JSONObject) JSON.toJSON(user2); System.out.println(\"(JSONObject) JSON.toJSON(user2)==&gt;\"+jsonObject1.getString(\"name\")); System.out.println(\"\\n****** JSON对象 转 Java对象 ******\"); User to_java_user = JSON.toJavaObject(jsonObject1, User.class); System.out.println(\"JSON.toJavaObject(jsonObject1, User.class)==&gt;\"+to_java_user); &#125;&#125; 这种工具类，我们只需要掌握使用就好了，在使用的时候在根据具体的业务去找对应的实现。和以前的commons-io那种工具包一样，拿来用就好了！","categories":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://i.codingce.com.cn/categories/SpringMVC/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://i.codingce.com.cn/tags/SpringMVC/"}]},{"title":"算法与数据结构（2）图的表示法与常用的转化算法","slug":"算法与数据结构（2）图的表示法与常用的转化算法","date":"2020-08-04T04:05:36.000Z","updated":"2020-12-13T04:41:40.453Z","comments":true,"path":"2020/08/04/算法与数据结构（2）图的表示法与常用的转化算法/","link":"","permalink":"http://i.codingce.com.cn/2020/08/04/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%882%EF%BC%89%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%B3%95%E4%B8%8E%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AC%E5%8C%96%E7%AE%97%E6%B3%95/","excerpt":"","text":"《图的表示方法》 邻接矩阵表示法，如图： 也就是说，如果两节点之间有一条弧，则邻接矩阵中对应的元素为1；否则为0。可以看出，这种表示法非常简单、直接。但是，在邻接矩阵的所有 个元素中，只有 个为非零元。如果网络比较稀疏，这种表示法浪费大量的存储空间，从而增加了在网络中查找弧的时间。 同样，对于网络中的权，也可以用类似邻接矩阵的 矩阵表示。只是此时一条弧所对应的元素不再是1，而是相应的权而已。如果网络中每条弧赋有多种权，则可以用多个矩阵表示这些权。 关联矩阵表示法 也就是说，在关联矩阵中，每行对应于图的一个节点，每列对应于图的一条弧。如果一个节点是一条弧的起点，则关联矩阵中对应的元素为1；如果一个节点是一条弧的终点，则关联矩阵中对应的元素为 -1；如果一个节点与一条弧不关联，则关联矩阵中对应的元素为0。对于简单图，关联矩阵每列只含有两个非零元（一个 1，一个-1）可以看出，这种表示法也非常简单、直接。但是，在关联矩阵的所有mn 个元素中，只有 2m个为非零元。如果网络比较稀疏，这种表示法也会浪费大量的存储空间。但由于关联矩阵有许多特别重要的理论性质，因此它在网络优化中是非常重要的概念 同样，对于网络中的权，也可以通过对关联矩阵的扩展来表示。例如，如果网络中每条弧有一个权，我们可以把关联矩阵增加一行，把每一条弧所对应的权存储在增加的行中。如果网络中每条弧赋有多个权，我们可以把关联矩阵增加相应的行数，把每一条弧所对应的权存储在增加的行中。 弧表示法 例如，例7所示的图，假设弧(1,2)，(1,3)，(2,4)，(3,2)，(4,3)，(4,5)，(5,3)和(5,4)上的权分别为8，9，6，4，0，3，6和7，则弧表表示如上： 为了便于检索，一般按照起点、终点的字典序顺序存储弧表，如上面的弧表就是按照这样的顺序存储的。 邻接表表示法 邻接表表示法将图以邻接表（adjacency lists）的形式存储在计算机中。所谓图的邻接表，也就是图的所有节点的邻接表的集合；而对每个节点，它的邻接表就是它的所有出弧。邻接表表示法就是对图的每个节点，用一个单向链表列出从该节点出发的所有弧，链表中每个单元对应于一条出弧。为了记录弧上的权，链表中每个单元除列出弧的另一个端点外，还可以包含弧上的权等作为数据域。图的整个邻接表可以用一个指针数组表示。例如，例7所示的图，邻接表表示为 星形表示法 星形（star）表示法的思想与邻接表表示法的思想有一定的相似之处。对每个节点，它也是记录从该节点出发的所有弧，但它不是采用单向链表而是采用一个单一的数组表示。也就是说，在该数组中首先存放从节点1出发的所有弧，然后接着存放从节点2出发的所有孤，依此类推，最后存放从节点 出发的所有孤。对每条弧，要依次存放其起点、终点、权的数值等有关信息。这实际上相当于对所有弧给出了一个顺序和编号，只是从同一节点出发的弧的顺序可以任意排列。此外，为了能够快速检索从每个节点出发的所有弧，我们一般还用一个数组记录每个节点出发的弧的起始地址（即弧的编号）。在这种表示法中，可以快速检索从每个节点出发的所有弧，这种星形表示法称为前向星形（forward star）表示法。 例如，在例7所示的图中，仍然假设弧（1,2），（l,3），（2,4），（3,2），（4,3），（4,5），（5,3）和（5,4）上的权分别为8，9，6，4，0，3，6和7。此时该网络图可以用前向星形表示法表示如下： 《星形表示法详解及其转化算法》 注意：上面的第一张表实际上有个错误，仔细看的童鞋应该能发现，起始地址point(i) : 1 , 3 , 4 , 5 , 7 , 9 ,那个6应该是5 通常情况下会设置一个st[i] 数组，和STL类似， [st[i],st[i+1]) 恰好为以结点i开头的边下标。对应于上个例子的第一张表，则该数组为： st[6]={1,3,4,5,7,9}; 还会有一个数组对应于第二张表，主要使用第三行数据， v[8]={2,3,4,2,3,5,3,4}; 下面的程序把树的前向星表示转化成左儿子-右兄弟表示，以方便后续算法实现。 1234567891011void star2lsrs () &#123; memset (son , 0 , sizeof (son )); /*清零， 为零代表链表为空son */ for(i = 1; i &lt;= n; i ++) /*按逆序考虑各个结点，则最后的链表是顺序的*/ for(j = st[i +1] -1; j &gt;= st[i ]; j --) &#123; bro[j ] = son[i]; son[i ] = v[j ]; /*插到链表首部*/ &#125;&#125; 图最常用的表示法是邻接矩阵和邻接表。对于静态图（建图完毕后不再修改图的结构）往往用前向星来代替邻接表，节省空间和时间。 邻接矩阵不管输入格式如何，总是很容易得到邻接矩阵，只需要注意平行边的情况。 前向星邻接矩阵本身就包含了顶点序，因此很容易转化为前向星： 把邻接矩阵转换为前向星表示法： 1234567891011121314151617void matrix2star ()&#123; /*上一条的第一端点初始化为（表示未出现），边数初始化为u0m0 */ u = m = 0; for(i = 1; i &lt;= n; i ++) for(j = 1; j &lt;= n; j ++) &#123; if(a[i][j]) &#123; v[++m ] = j; while (u &lt; i) st [++u ] = m; &#125; &#125;&#125;/*在程序中，u代表上一条边的第一个顶点编号，当u &lt; i时代表这条边的第一端点还没有出现过，设置st[u + 1] : : : st[i]为m。*/ 把边列表转化成前向星的方法类似，只需要把第一顶点相同的结点串成链表，用计数器法进行结点编号分配，和前向星转化成左儿子-右兄弟一样每次插入到链表首部，在O(m)时间内可以建立前向星表示。当然，也可以按第一顶点为关键字直接进行快速排序，不过速度稍微慢一些 原文地址:https://www.cnblogs.com/liushang0419/archive/2011/05/06/2039386.html 207. 课程表 题目 你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1 。 在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1] 给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？ 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/course-schedule 示例 1: 输入: 2, [[1,0]] 输出: true 解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。 示例 2: 输入: 2, [[1,0],[0,1]] 输出: false 解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。 提示： 输入的先决条件是由 边缘列表 表示的图形，而不是 邻接矩阵 。详情请参见上文。 你可以假定输入的先决条件中没有重复的边。 1 &lt;= numCourses &lt;= 10^5 方法一：入度表（广度优先遍历） 算法流程： 统计课程安排图中每个节点的入度，生成 入度表 indegrees。 借助一个队列 queue，将所有入度为 00 的节点入队。 当 queue 非空时，依次将队首节点出队，在课程安排图中删除此节点 pre： 并不是真正从邻接表中删除此节点 pre，而是将此节点对应所有邻接节点 cur 的入度 -1−1，即 indegrees[cur] -= 1。 当入度 -1−1后邻接节点 cur 的入度为 00，说明 cur 所有的前驱节点已经被 “删除”，此时将 cur 入队。 在每次 pre 出队时，执行 numCourses–； 若整个课程安排图是有向无环图（即可以安排），则所有节点一定都入队并出队过，即完成拓扑排序。换个角度说，若课程安排图中存在环，一定有节点的入度始终不为 00。 因此，拓扑排序出队次数等于课程个数，返回 numCourses == 0 判断课程是否可以成功安排。 复杂度分析： 时间复杂度 O(N + M)O(N+M)： 遍历一个图需要访问所有节点和所有临边，NN 和 MM 分别为节点数量和临边数量； 空间复杂度 O(N + M)O(N+M)： 为建立邻接表所需额外空间，adjacency 长度为 NN ，并存储 MM 条临边的数据。 Java实现 12345678910111213141516171819202122232425class Solution &#123; public boolean canFinish(int numCourses, int[][] prerequisites) &#123; int[] indegrees = new int[numCourses]; List&lt;List&lt;Integer&gt;&gt; adjacency = new ArrayList&lt;&gt;(); Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for(int i = 0; i &lt; numCourses; i++) adjacency.add(new ArrayList&lt;&gt;()); // Get the indegree and adjacency of every course. for(int[] cp : prerequisites) &#123; indegrees[cp[0]]++; adjacency.get(cp[1]).add(cp[0]); &#125; // Get all the courses with the indegree of 0. for(int i = 0; i &lt; numCourses; i++) if(indegrees[i] == 0) queue.add(i); // BFS TopSort. while(!queue.isEmpty()) &#123; int pre = queue.poll(); numCourses--; for(int cur : adjacency.get(pre)) if(--indegrees[cur] == 0) queue.add(cur); &#125; return numCourses == 0; &#125;&#125; 方法二：深度优先遍历 原理是通过 DFS 判断图中是否有环。 借助一个标志列表 flags，用于判断每个节点 i （课程）的状态： 未被 DFS 访问：i == 0； 已被其他节点启动的 DFS 访问：i == -1； 已被当前节点启动的 DFS 访问：i == 1。 对 numCourses 个节点依次执行 DFS，判断每个节点起步 DFS 是否存在环，若存在环直接返回 FalseFalse。DFS 流程； 终止条件： 当 flag[i] == -1，说明当前访问节点已被其他节点启动的 DFS 访问，无需再重复搜索，直接返回 TrueTrue。 当 flag[i] == 1，说明在本轮 DFS 搜索中节点 i 被第 22 次访问，即 课程安排图有环 ，直接返回 FalseFalse。 将当前访问节点 i 对应 flag[i] 置 11，即标记其被本轮 DFS 访问过； 递归访问当前节点 i 的所有邻接节点 j，当发现环直接返回 FalseFalse； 当前节点所有邻接节点已被遍历，并没有发现环，则将当前节点 flag 置为 -1−1 并返回 TrueTrue。 若整个图 DFS 结束并未发现环，返回 TrueTrue。 复杂度分析： 时间复杂度 O(N + M)O(N+M)： 遍历一个图需要访问所有节点和所有临边，NN 和 MM 分别为节点数量和临边数量； 空间复杂度 O(N + M)O(N+M)： 为建立邻接表所需额外空间，adjacency 长度为 NN ，并存储 MM 条临边的数据。 12345678910111213141516171819202122class Solution &#123; public boolean canFinish(int numCourses, int[][] prerequisites) &#123; List&lt;List&lt;Integer&gt;&gt; adjacency = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; numCourses; i++) adjacency.add(new ArrayList&lt;&gt;()); int[] flags = new int[numCourses]; for(int[] cp : prerequisites) adjacency.get(cp[1]).add(cp[0]); for(int i = 0; i &lt; numCourses; i++) if(!dfs(adjacency, flags, i)) return false; return true; &#125; private boolean dfs(List&lt;List&lt;Integer&gt;&gt; adjacency, int[] flags, int i) &#123; if(flags[i] == 1) return false; if(flags[i] == -1) return true; flags[i] = 1; for(Integer j : adjacency.get(i)) if(!dfs(adjacency, flags, j)) return false; flags[i] = -1; return true; &#125;&#125;","categories":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://i.codingce.com.cn/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://i.codingce.com.cn/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"重定向和转发|数据处理|乱码问题","slug":"重定向和转发","date":"2020-08-04T03:41:19.000Z","updated":"2020-12-13T04:41:40.453Z","comments":true,"path":"2020/08/04/重定向和转发/","link":"","permalink":"http://i.codingce.com.cn/2020/08/04/%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E8%BD%AC%E5%8F%91/","excerpt":"","text":"结果跳转方式 ModelAndView 设置ModelAndView对象 , 根据view的名称 , 和视图解析器跳到指定的页面 . 页面 : {视图解析器前缀} + viewName +{视图解析器后缀} 12345678&lt;!-- 视图解析器 --&gt;&lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"internalResourceViewResolver\"&gt; &lt;!-- 前缀 --&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\" /&gt; &lt;!-- 后缀 --&gt; &lt;property name=\"suffix\" value=\".jsp\" /&gt;&lt;/bean&gt; 对应的controller类 12345678910public class ControllerTest1 implements Controller &#123; public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123; //返回一个模型视图对象 ModelAndView mv = new ModelAndView(); mv.addObject(\"msg\",\"ControllerTest1\"); mv.setViewName(\"test\"); return mv; &#125;&#125; ServletAPI 通过设置ServletAPI , 不需要视图解析器 . 通过HttpServletResponse进行输出 通过HttpServletResponse实现重定向 通过HttpServletResponse实现转发 123456789101112131415161718192021@Controllerpublic class ResultGo &#123; @RequestMapping(\"/result/t1\") public void test1(HttpServletRequest req, HttpServletResponse rsp) throws IOException &#123; rsp.getWriter().println(\"Hello,Spring BY servlet API\"); &#125; @RequestMapping(\"/result/t2\") public void test2(HttpServletRequest req, HttpServletResponse rsp) throws IOException &#123; rsp.sendRedirect(\"/index.jsp\"); &#125; @RequestMapping(\"/result/t3\") public void test3(HttpServletRequest req, HttpServletResponse rsp) throws Exception &#123; //转发 req.setAttribute(\"msg\",\"/result/t3\"); req.getRequestDispatcher(\"/WEB-INF/jsp/test.jsp\").forward(req,rsp); &#125;&#125; SpringMVC 通过SpringMVC来实现转发和重定向 - 无需视图解析器； 测试前，需要将视图解析器注释掉 1234567891011121314151617181920@Controllerpublic class ResultSpringMVC &#123; @RequestMapping(\"/rsm/t1\") public String test1()&#123; //转发 return \"/index.jsp\"; &#125; @RequestMapping(\"/rsm/t2\") public String test2()&#123; //转发二 return \"forward:/index.jsp\"; &#125; @RequestMapping(\"/rsm/t3\") public String test3()&#123; //重定向 return \"redirect:/index.jsp\"; &#125;&#125; 通过SpringMVC来实现转发和重定向 - 有视图解析器； 重定向 , 不需要视图解析器 , 本质就是重新请求一个新地方嘛 , 所以注意路径问题. 可以重定向到另外一个请求实现 . 1234567891011121314151617@Controllerpublic class ResultSpringMVC2 &#123; //转发 @RequestMapping(\"m1/t2\") public String test2(Model model) &#123; model.addAttribute(\"msg\", \"ModelTest1\"); return \"test\"; &#125; //重定向 @RequestMapping(\"m1/t3\") public String test3(Model model) &#123; model.addAttribute(\"msg\", \"ModelTest1\"); return \"redirect:/index.jsp\"; &#125;&#125; 数据处理 处理提交数据 提交的域名称和处理方法的参数名一致 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package cn.com.codingce.controller;import cn.com.codingce.pojo.User;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;@Controller@RequestMapping(\"user\")public class UserController &#123; //localhost:8080/user/t1?name=xxx @GetMapping(\"/t1\") public String test1(String name, Model model) &#123; //接收前端参数 System.out.println(\"接受前端参数为\" + name); //将返回的结果传递给前端 Model model.addAttribute(\"msg\", name); //视图跳转 return \"test\"; &#125; //@RequestParam @GetMapping(\"/t2\") public String test2(@RequestParam(\"username\") String name, Model model) &#123; //接收前端参数 System.out.println(\"接受前端参数为\" + name); //将返回的结果传递给前端 Model model.addAttribute(\"msg\", name); //视图跳转 return \"test\"; &#125; /** * 1.接收前端用户传递的参数, 判断参数的名字, 假设名字直接在方法上, 可以直接使用 * 2.假设传递的是一个对象, 陪陪User对象中的字段名, 如果名字一致ok, 否则匹配不到 * @param user * @return */ @GetMapping(\"/t3\") public String test3(User user) &#123; //接收前端参数 System.out.println(\"接受前端参数为\" + user.getName() + user.getPwd()); //将返回的结果传递给前端 Model //视图跳转 return \"test\"; &#125;&#125; 数据显示到前端 第一种 : 通过ModelAndView ModelAndView 12345678910public class ControllerTest1 implements Controller &#123; public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123; //返回一个模型视图对象 ModelAndView mv = new ModelAndView(); mv.addObject(\"msg\",\"ControllerTest1\"); mv.setViewName(\"test\"); return mv; &#125;&#125; 第二种 : 通过ModelMap ModelMap 12345678@RequestMapping(\"/hello\")public String hello(@RequestParam(\"username\") String name, ModelMap model)&#123; //封装要显示到视图中的数据 //相当于req.setAttribute(\"name\",name); model.addAttribute(\"name\",name); System.out.println(name); return \"hello\";&#125; 第三种 : 通过Model Model 12345678@RequestMapping(\"/ct2/hello\")public String hello(@RequestParam(\"username\") String name, Model model)&#123; //封装要显示到视图中的数据 //相当于req.setAttribute(\"name\",name); model.addAttribute(\"msg\",name); System.out.println(name); return \"test\";&#125; 对比 Model 只有寥寥几个方法只适合用于储存数据，简化了新手对于Model对象的操作和理解； ModelMap 继承了 LinkedMap ，除了实现了自身的一些方法，同样的继承 LinkedMap 的方法和特性； ModelAndView 可以在储存数据的同时，可以进行设置返回的逻辑视图，进行控制展示层的跳转。 当然更多的以后开发考虑的更多的是性能和优化，就不能单单仅限于此的了解。 请使用80%的时间打好扎实的基础，剩下18%的时间研究框架，2%的时间去学点英文，框架的官方文档永远是最好的教程。 乱码问题 测试步骤： 我们可以在首页编写一个提交的表单 1234&lt;form action=\"/e/t\" method=\"post\"&gt; &lt;input type=\"text\" name=\"name\"&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt; 后台编写对应的处理类 123456789@Controllerpublic class Encoding &#123; @RequestMapping(\"/e/t\") public String test(Model model,String name)&#123; //传到这的数据就已经乱码, 说明解析时就已经乱码 model.addAttribute(\"msg\",name); //获取表单提交的值 return \"test\"; //跳转到test页面显示输入的值 &#125;&#125; 表单页面输入中文测试，发现乱码 不得不说，乱码问题是在我们开发中十分常见的问题，也是让我们程序猿比较头大的问题！ 以前乱码问题通过过滤器解决 , 而SpringMVC给我们提供了一个过滤器 , 可以在web.xml中配置 . 修改了xml文件需要重启服务器！ 123456789101112&lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 但是我们发现 , 有些极端情况下.这个过滤器对get的支持不好 . 处理方法 : 修改tomcat配置文件 ：设置编码！ 123&lt;Connector URIEncoding=\"utf-8\" port=\"8080\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" /&gt; 自定义过滤器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110package cn.com.codingce.filter;import javax.servlet.Filter;import javax.servlet.FilterChain;import javax.servlet.FilterConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletRequestWrapper;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.UnsupportedEncodingException;import java.util.Map;/** * 解决get和post请求 全部乱码的过滤器 */public class GenericEncodingFilter implements Filter &#123; public void destroy() &#123; &#125; public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; //处理response的字符编码 HttpServletResponse myResponse=(HttpServletResponse) response; myResponse.setContentType(\"text/html;charset=UTF-8\"); // 转型为与协议相关对象 HttpServletRequest httpServletRequest = (HttpServletRequest) request; // 对request包装增强 HttpServletRequest myrequest = new MyRequest(httpServletRequest); chain.doFilter(myrequest, response); &#125; public void init(FilterConfig filterConfig) throws ServletException &#123; &#125;&#125;//自定义request对象，HttpServletRequest的包装类class MyRequest extends HttpServletRequestWrapper &#123; private HttpServletRequest request; //是否编码的标记 private boolean hasEncode; //定义一个可以传入HttpServletRequest对象的构造函数，以便对其进行装饰 public MyRequest(HttpServletRequest request) &#123; super(request);// super必须写 this.request = request; &#125; // 对需要增强方法 进行覆盖 @Override public Map getParameterMap() &#123; // 先获得请求方式 String method = request.getMethod(); if (method.equalsIgnoreCase(\"post\")) &#123; // post请求 try &#123; // 处理post乱码 request.setCharacterEncoding(\"utf-8\"); return request.getParameterMap(); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; &#125; else if (method.equalsIgnoreCase(\"get\")) &#123; // get请求 Map&lt;String, String[]&gt; parameterMap = request.getParameterMap(); if (!hasEncode) &#123; // 确保get手动编码逻辑只运行一次 for (String parameterName : parameterMap.keySet()) &#123; String[] values = parameterMap.get(parameterName); if (values != null) &#123; for (int i = 0; i &lt; values.length; i++) &#123; try &#123; // 处理get乱码 values[i] = new String(values[i] .getBytes(\"ISO-8859-1\"), \"utf-8\"); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; hasEncode = true; &#125; return parameterMap; &#125; return super.getParameterMap(); &#125; //取一个值 @Override public String getParameter(String name) &#123; Map&lt;String, String[]&gt; parameterMap = getParameterMap(); String[] values = parameterMap.get(name); if (values == null) &#123; return null; &#125; return values[0]; // 取回参数的第一个值 &#125; //取所有值 @Override public String[] getParameterValues(String name) &#123; Map&lt;String, String[]&gt; parameterMap = getParameterMap(); String[] values = parameterMap.get(name); return values; &#125;&#125; 然后在web.xml中配置这个过滤器即可！ 乱码问题，需要平时多注意，在尽可能能设置编码的地方，都设置为统一编码 UTF-8！","categories":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://i.codingce.com.cn/categories/SpringMVC/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://i.codingce.com.cn/tags/SpringMVC/"}]},{"title":"21考研计算机考研择校","slug":"21考研计算机考研择校","date":"2020-08-03T23:22:32.000Z","updated":"2020-12-13T04:41:40.422Z","comments":true,"path":"2020/08/04/21考研计算机考研择校/","link":"","permalink":"http://i.codingce.com.cn/2020/08/04/21%E8%80%83%E7%A0%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%80%83%E7%A0%94%E6%8B%A9%E6%A0%A1/","excerpt":"","text":"【21考研】计算机考研择校 考研应该如何选择院校？ 选择报考985，211，或者是双非院校？ 学硕还是专硕？ 全日制还是非全日制？ 选什么专业？ 计算机OR软工OR网安OR人工智能OR大数据？ 都快11月份了，相信这个问题依然让不少小皮皮头疼。 考研，绝大多数情况下选择大于努力。 选对了学校，选对了专业，300分可以上985。 反之，400分也可能会被刷掉。 选对学校很重要！ 但是，【择校】这个问题也非常难回答。 每个人的基础不一样，考研的目的不一样。 不能一概而论 有的人却想考学硕继续读博深造。 只有自己才能决定自己的命运。 择校攻略总览 1.评估自身实力 先问问自己这么几个问题 1.你是一个什么样的人？ 2.你为什么要考研？ 【群友1】研究生有很多帅气的小哥哥，又能干还会让着人家。考上后还顺便可以解决下人生大事，喵呜帕斯~ 【群友2】为了给女朋友更好的生活，能赚更多的钱让女朋友随便挥霍。当然也有为了能够从事自己相对比较感兴趣专业的工作而努力的动机，实在是不想做电气方面的，还能有两三年时间能够再学习学习，再当两三年的学生（笑着哭） 【群友3】主要是扩展在学术圈的人脉，单论就业 读研不划算。 【群友4】首先，是有过老师还有亲戚建议我去考研。然后，就是当时感觉大学被荒废过去了，但觉得自己还是能捞一哈的。所以就决定考研了，一是提升下学历（渣渣双非），二是继续学习提升下自己。 【群友5】当初选的是机械专业，读了四年之后发现“就业前景”虽好，但是实际上要熬很多年的工作资历。还有就是对自己的本科学校不甘心吧，高考发挥失常的我在大一的时候就已经下定决心考研了，凭借自己的努力能够让自己的学历更上一层楼，完成自己的一个梦想。再其他的，就是家庭的一些压力吧 3.你是跨考吗？ 4.你的本科院校实力怎么样？ 5.你的本科成绩怎么样？ 6.你有没有实际的项目经验？ 7.四六级过了没有？考过托福雅思吗？ 8.ACM成绩怎么样？ 9.对于考研，你能付出多大的努力？ 理清楚这些问题，之后的选择也就有了。 不要盲目挑战名校 虽然每年双非都有考上的同学 但更多的是没有考上的 参考知乎：考研失败是种怎样的体验？ 同时也不要过分保守 本科情况只代表过去 但占比一般不会太高 2.确定目标专业 计算机类考研主要分下面几类大项： 1.计算机科学与技x术 2.计算机技术 3.软件工程 4.人工智能 5.网络安全 3.学硕OR专硕 读博科研：建议学硕优先，可以直博。 工作就业：专硕优先，就业方面相较于学硕，基本没有区别。学习年限相对较短，可以更早的踏入社会，你可以比考学硕的同学多一年的工作经验，对未来的工作发展很有优势。 4.全日制OR非全日制 非全日制难度比全日制难度略低，基本上是过线就录。 21考研非全日制仅招生定向考生【有工作的】 选择非全日制需要注意的几点： 1.学校是否会帮忙解决住宿问题。 P.S：一般学校不会安排住宿，但是少部分学校会安排非全日制学生统一在学校外面住宿。 2.毕业时是否有派遣证OR报到证？ P.S:《就业报到证》是应届普通全日制高校毕业生到就业单位报到的凭证，也是毕业生参加工作时间的初始记载和凭证。 3.学费与奖学金问题 P.S非全日制费用高昂，奖学金较少。 国家助学金6000每年，非全日制不享受。 4.非全日制毕业后的社会认可度 P.S非全日制录取难度降低带来的负面影响 5.上课方式 P.S由于部分学校师资不足，实际上非全日制是和全日制是一起上课的。 具体需要咨询校方。 6.定向招生 P.S21考研非全日制只招生定向生。 定向生是指单位委托培养 5.你想考去哪个城市？ 决定了你想考去哪个城市，也就确定了你的卷子会送去哪里改卷。 网络上一直流传着改卷地区差异的说法，也就是熟称的【旱区】【水区】，越旱的地区改卷越紧。 其实改卷松紧对于考生没有太大的影响，你的竞争对手面对的是同一套评判标准。但是对于调剂有影响，水区容易混到高分，而调剂一般只会看分数。 最旱的地区：北京、上海、浙江 6.筛选与确定学校 请根据以下信息筛选与确定出你的目标院校。 （1）查专业排名 （2）查20招生简章信息 （3）查专业课考试信息 （4）查历年录取信息，确定目标院校难度","categories":[{"name":"考研","slug":"考研","permalink":"http://i.codingce.com.cn/categories/%E8%80%83%E7%A0%94/"}],"tags":[{"name":"考研","slug":"考研","permalink":"http://i.codingce.com.cn/tags/%E8%80%83%E7%A0%94/"}]},{"title":"RestFul和控制器","slug":"RestFul和控制器","date":"2020-08-03T07:28:46.000Z","updated":"2020-12-13T04:41:40.422Z","comments":true,"path":"2020/08/03/RestFul和控制器/","link":"","permalink":"http://i.codingce.com.cn/2020/08/03/RestFul%E5%92%8C%E6%8E%A7%E5%88%B6%E5%99%A8/","excerpt":"","text":"RestFul和控制器 控制器Controller 控制器复杂提供访问应用程序的行为，通常通过接口定义或注解定义两种方法实现。 控制器负责解析用户的请求并将其转换为一个模型。 在Spring MVC中一个控制器类可以包含多个方法 在Spring MVC中，对于Controller的配置方式有很多种 实现Controller接口 Controller是一个接口，在org.springframework.web.servlet.mvc包下，接口中只有一个方法； 12345//实现该接口的类获得控制器功能public interface Controller &#123; //处理请求且返回一个模型与视图对象 ModelAndView handleRequest(HttpServletRequest var1, HttpServletResponse var2) throws Exception;&#125; 测试 新建一个Moudle，springmvc-04-controller 。将刚才的03 拷贝一份, 我们进行操作！ 删掉HelloController mvc的配置文件只留下 视图解析器！ 编写一个Controller类，ControllerTest1 123456789101112131415161718192021package cn.com.codingce.controller;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.mvc.Controller;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * 只要实现了Controller接口的类, 说明这就是一个控制器 * @author xzMa */public class ControllerTest1 implements Controller &#123; public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123; ModelAndView mv = new ModelAndView(); mv.addObject(\"msg\", \"实现接口方式\"); mv.setViewName(\"test\"); return mv; &#125;&#125; 编写完毕后，去Spring配置文件中注册请求的bean；name对应请求路径，class对应处理请求的类 1&lt;bean name=\"/t1\" class=\"com.kuang.controller.ControllerTest1\"/&gt; 编写前端test.jsp，注意在WEB-INF/jsp目录下编写，对应我们的视图解析器 123456789&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Kuangshen&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;msg&#125;&lt;/body&gt;&lt;/html&gt; 配置Tomcat运行测试 说明： 实现接口Controller定义控制器是较老的办法 缺点是：一个控制器中只有一个方法，如果要多个方法则需要定义多个Controller；定义的方式比较麻烦； 使用注解@Controller @Controller注解类型用于声明Spring类的实例是一个控制器（在讲IOC时还提到了另外3个注解）； Spring可以使用扫描机制来找到应用程序中所有基于注解的控制器类，为了保证Spring能找到你的控制器，需要在配置文件中声明组件扫描。 12&lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt;&lt;context:component-scan base-package=\"com.kuang.controller\"/&gt; 增加一个ControllerTest2类，使用注解实现； 12345678910111213141516package cn.com.codingce.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class ControllerTest2 &#123; @RequestMapping(\"/t2\") public String test1(Model model) &#123; model.addAttribute(\"msg\", \"注解实现\"); return \"test\"; &#125;&#125; 可以发现，我们的两个请求都可以指向一个视图，但是页面结果的结果是不一样的，从这里可以看出视图是被复用的，而控制器与视图之间是弱偶合关系。 注解方式是平时使用的最多的方式！ RequestMapping @RequestMapping @RequestMapping注解用于映射url到控制器类或一个特定的处理程序方法。可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。 为了测试结论更加准确，我们可以加上一个项目名测试 myweb 只注解在方法上面 1234567@Controllerpublic class TestController &#123; @RequestMapping(\"/h1\") public String test()&#123; return \"test\"; &#125;&#125; 访问路径：http://localhost:8080 / 项目名 / h1 同时注解类与方法 12345678@Controller@RequestMapping(\"/admin\")public class TestController &#123; @RequestMapping(\"/h1\") public String test()&#123; return \"test\"; &#125;&#125; 访问路径：http://localhost:8080 / 项目名/ admin /h1 , 需要先指定类的路径再指定方法的路径； RestFul风格讲解 概念 Restful就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。 功能 资源：互联网所有的事物都可以被抽象为资源 资源操作：使用POST、DELETE、PUT、GET，使用不同方法对资源进行操作。 分别对应 添加、 删除、修改、查询。 传统方式操作资源 ：通过不同的参数来实现不同的效果！方法单一，post 和 get http://127.0.0.1/item/queryItem.action?id=1 查询,GET http://127.0.0.1/item/saveItem.action 新增,POST http://127.0.0.1/item/updateItem.action 更新,POST http://127.0.0.1/item/deleteItem.action?id=1 删除,GET或POST 使用RESTful操作资源 ：可以通过不同的请求方式来实现不同的效果！如下：请求地址一样，但是功能可以不同！ http://127.0.0.1/item/1 查询,GET http://127.0.0.1/item 新增,POST http://127.0.0.1/item 更新,PUT http://127.0.0.1/item/1 删除,DELETE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package cn.com.codingce.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;@Controllerpublic class RestFulController &#123; //原来的: http://localhost:8080/add?a=2&amp;b=3 @RequestMapping(\"/add\") public String test1(int a, int b, Model model) &#123; int res = a + b; model.addAttribute(\"msg\", \"结果为\" + res); return \"test\"; &#125; //RestFul: http://localhost:8080/add/a/b //http://localhost:8080/add2/2/3 //在Spring MVC中可以使用 @PathVariable 注解，让方法参数的值对应绑定到一个URI模板变量上。 @RequestMapping(\"/add2/&#123;a&#125;/&#123;b&#125;\") public String test2(@PathVariable int a, @PathVariable int b, Model model) &#123; int res = a + b; model.addAttribute(\"msg\", \"结果为\" + res); return \"test\"; &#125; //http://localhost:8080/add2/2/3 //在Spring MVC中可以使用 @PathVariable 注解，让方法参数的值对应绑定到一个URI模板变量上。 @RequestMapping(value = \"/add3/&#123;a&#125;/&#123;b&#125;\", method = RequestMethod.GET) public String test3(@PathVariable int a, @PathVariable int b, Model model) &#123; int res = a + b; model.addAttribute(\"msg\", \"结果为\" + res); return \"test\"; &#125; //http://localhost:8080/add2/2/3 //在Spring MVC中可以使用 @PathVariable 注解，让方法参数的值对应绑定到一个URI模板变量上。 @GetMapping(\"/add4/&#123;a&#125;/&#123;b&#125;\") public String test4(@PathVariable int a, @PathVariable int b, Model model) &#123; int res = a + b; model.addAttribute(\"msg\", \"结果为\" + res); return \"test\"; &#125;&#125; 思考：使用路径变量的好处？ 使路径变得更加简洁； 获得参数更加方便，框架会自动进行类型转换。 通过路径变量的类型可以约束访问参数，如果类型不一样，则访问不到对应的请求方法，如这里访问是的路径是/commit/1/a，则路径与方法不匹配，而不会是参数转换失败。 我们来修改下对应的参数类型，再次测试 1234567891011//映射访问路径@RequestMapping(\"/commit/&#123;p1&#125;/&#123;p2&#125;\")public String index(@PathVariable int p1, @PathVariable String p2, Model model)&#123; String result = p1+p2; //Spring MVC会自动实例化一个Model对象用于向视图中传值 model.addAttribute(\"msg\", \"结果：\"+result); //返回视图位置 return \"test\";&#125; 使用method属性指定请求类型 用于约束请求的类型，可以收窄请求范围。指定请求谓词的类型如GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE等 小结： Spring MVC 的 @RequestMapping 注解能够处理 HTTP 请求的方法, 比如 GET, PUT, POST, DELETE 以及 PATCH。 所有的地址栏请求默认都会是 HTTP GET 类型的。 方法级别的注解变体有如下几个：组合注解 12345@GetMapping@PostMapping@PutMapping@DeleteMapping@PatchMapping @GetMapping 是一个组合注解，平时使用的会比较多！ 它所扮演的是 @RequestMapping(method =RequestMethod.GET) 的一个快捷方式。 扩展：小黄鸭调试法 场景一：我们都有过向别人（甚至可能向完全不会编程的人）提问及解释编程问题的经历，但是很多时候就在我们解释的过程中自己却想到了问题的解决方案，然后对方却一脸茫然。 场景二：你的同行跑来问你一个问题，但是当他自己把问题说完，或说到一半的时候就想出答案走了，留下一脸茫然的你。 其实上面两种场景现象就是所谓的小黄鸭调试法（Rubber Duck Debuging），又称橡皮鸭调试法，它是我们软件工程中最常使用调试方法之一。 此概念据说来自《程序员修炼之道》书中的一个故事，传说程序大师随身携带一只小黄鸭，在调试代码的时候会在桌上放上这只小黄鸭，然后详细地向鸭子解释每行代码，然后很快就将问题定位修复了。","categories":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://i.codingce.com.cn/categories/SpringMVC/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://i.codingce.com.cn/tags/SpringMVC/"}]},{"title":"两数之和","slug":"两数之和","date":"2020-08-03T02:08:39.000Z","updated":"2020-12-13T04:41:40.438Z","comments":true,"path":"2020/08/03/两数之和/","link":"","permalink":"http://i.codingce.com.cn/2020/08/03/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243package cn.com.codingce.mytest;import java.util.HashMap;import java.util.Map;/** * @author xzMa * 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 * * 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 * * 给定 nums = [2, 7, 11, 15], target = 9 * * 因为 nums[0] + nums[1] = 2 + 7 = 9 * 所以返回 [0, 1] * * 来源：力扣（LeetCode） * 链接：https://leetcode-cn.com/problems/two-sum */public class TwoSumTest &#123; public static void main(String[] args) &#123; int[] nums = &#123;11, 15, 2, 7&#125;; nums = twoSum(nums, 9); for (int i : nums) &#123; System.out.println(i); &#125; &#125; public static int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; // map是一个key和value的键值对的集合。有key和value键值对，就会有判断是否有key。这方法就是containsKey方法。 int complement = target - nums[i]; // map中的containsKey（key）方法是判断该key在map中是否有key存在。如果存在则返回true。如果不存在则返回false。 if (map.containsKey(complement)) &#123; //Java 集合类中的 Map.get() 方法返回指定键所映射的值。如果此映射不包含该键的映射关系，则返回 null。 return new int[]&#123;map.get(complement), i&#125;; &#125; map.put(nums[i], i); &#125; throw new IllegalArgumentException(\"No two sum solution\"); &#125;&#125;","categories":[{"name":"力扣","slug":"力扣","permalink":"http://i.codingce.com.cn/categories/%E5%8A%9B%E6%89%A3/"}],"tags":[{"name":"力扣","slug":"力扣","permalink":"http://i.codingce.com.cn/tags/%E5%8A%9B%E6%89%A3/"}]},{"title":"J2EE基础知识","slug":"J2EE基础知识","date":"2020-08-02T09:27:10.000Z","updated":"2020-12-13T04:41:40.422Z","comments":true,"path":"2020/08/02/J2EE基础知识/","link":"","permalink":"http://i.codingce.com.cn/2020/08/02/J2EE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"Servlet总结 阐述Servlet和CGI的区别? CGI的不足之处: Servlet的优点： Servlet接口中有哪些方法及Servlet生命周期探秘 get和post请求的区别 什么情况下调用doGet()和doPost() 转发（Forward）和重定向（Redirect）的区别 自动刷新(Refresh) Servlet与线程安全 JSP和Servlet是什么关系 JSP工作原理 JSP有哪些内置对象、作用分别是什么 Request对象的主要方法有哪些 request.getAttribute()和 request.getParameter()有何区别 include指令include的行为的区别 JSP九大内置对象，七大动作，三大指令 讲解JSP中的四种作用域 如何实现JSP或Servlet的单线程模式 实现会话跟踪的技术有哪些 Cookie和Session的的区别 Servlet总结 在Java Web程序中，Servlet主要负责接收用户请求HttpServletRequest,在doGet(),doPost()中做相应的处理，并将回应HttpServletResponse反馈给用户。Servlet可以设置初始化参数，供Servlet内部使用。一个Servlet类只会有一个实例，在它初始化时调用init()方法，销毁时调用destroy()方法。Servlet需要在web.xml中配置（MyEclipse中创建Servlet会自动配置），一个Servlet可以设置多个URL访问。Servlet不是线程安全，因此要谨慎使用类变量。 阐述Servlet和CGI的区别? CGI的不足之处: 1，需要为每个请求启动一个操作CGI程序的系统进程。如果请求频繁，这将会带来很大的开销。 2，需要为每个请求加载和运行一个CGI程序，这将带来很大的开销 3，需要重复编写处理网络协议的代码以及编码，这些工作都是非常耗时的。 Servlet的优点: 1，只需要启动一个操作系统进程以及加载一个JVM，大大降低了系统的开销 2，如果多个请求需要做同样处理的时候，这时候只需要加载一个类，这也大大降低了开销 3，所有动态加载的类可以实现对网络协议以及请求解码的共享，大大降低了工作量。 4，Servlet能直接和Web服务器交互，而普通的CGI程序不能。Servlet还能在各个程序之间共享数据，使数据库连接池之类的功能很容易实现。 补充：Sun Microsystems公司在1996年发布Servlet技术就是为了和CGI进行竞争，Servlet是一个特殊的Java程序，一个基于Java的Web应用通常包含一个或多个Servlet类。Servlet不能够自行创建并执行，它是在Servlet容器中运行的，容器将用户的请求传递给Servlet程序，并将Servlet的响应回传给用户。通常一个Servlet会关联一个或多个JSP页面。以前CGI经常因为性能开销上的问题被诟病，然而Fast CGI早就已经解决了CGI效率上的问题，所以面试的时候大可不必信口开河的诟病CGI，事实上有很多你熟悉的网站都使用了CGI技术。 参考：《javaweb整合开发王者归来》P7 Servlet接口中有哪些方法及Servlet生命周期探秘 Servlet接口定义了5个方法，其中前三个方法与Servlet生命周期相关： void init(ServletConfig config) throws ServletException void service(ServletRequest req, ServletResponse resp) throws ServletException, java.io.IOException void destory() java.lang.String getServletInfo() ServletConfig getServletConfig() 生命周期： Web容器加载Servlet并将其实例化后，Servlet生命周期开始，容器运行其init()方法进行Servlet的初始化；请求到达时调用Servlet的service()方法，service()方法会根据需要调用与请求对应的doGet或doPost等方法；当服务器关闭或项目被卸载时服务器会将Servlet实例销毁，此时会调用Servlet的destroy()方法。init方法和destroy方法只会执行一次，service方法客户端每次请求Servlet都会执行。Servlet中有时会用到一些需要初始化与销毁的资源，因此可以把初始化资源的代码放入init方法中，销毁资源的代码放入destroy方法中，这样就不需要每次处理客户端的请求都要初始化与销毁资源。 参考：《javaweb整合开发王者归来》P81 get和post请求的区别 网上也有文章说：get和post请求实际上是没有区别，大家可以自行查询相关文章（参考文章：https://www.cnblogs.com/logsharing/p/8448446.html，知乎对应的问题链接：get和post区别？）！我下面给出的只是一种常见的答案。 ①get请求用来从服务器上获得资源，而post是用来向服务器提交数据； ②get将表单中数据按照name=value的形式，添加到action 所指向的URL 后面，并且两者使用&quot;?“连接，而各个变量之间使用”&amp;&quot;连接；post是将表单中的数据放在HTTP协议的请求头或消息体中，传递到action所指向URL； ③get传输的数据要受到URL长度限制（最大长度是 2048 个字符）；而post可以传输大量的数据，上传文件通常要使用post方式； ④使用get时参数会显示在地址栏上，如果这些数据不是敏感数据，那么可以使用get；对于敏感数据还是应用使用post； ⑤get使用MIME类型application/x-www-form-urlencoded的URL编码（也叫百分号编码）文本的格式传递参数，保证被传送的参数由遵循规范的文本组成，例如一个空格的编码是&quot;%20&quot;。 补充：GET方式提交表单的典型应用是搜索引擎。GET方式就是被设计为查询用的。 还有另外一种回答。推荐大家看一下： https://www.zhihu.com/question/28586791 https://mp.weixin.qq.com/s?__biz=MzI3NzIzMzg3Mw==&amp;mid=100000054&amp;idx=1&amp;sn=71f6c214f3833d9ca20b9f7dcd9d33e4#rd 什么情况下调用doGet()和doPost() Form标签里的method的属性为get时调用doGet()，为post时调用doPost()。 转发(Forward)和重定向(Redirect)的区别 转发是服务器行为，重定向是客户端行为。 转发（Forword） 通过RequestDispatcher对象的forward（HttpServletRequest request,HttpServletResponse response）方法实现的。RequestDispatcher可以通过HttpServletRequest 的getRequestDispatcher()方法获得。例如下面的代码就是跳转到login_success.jsp页面。 1request.getRequestDispatcher(\"login_success.jsp\").forward(request, response); 重定向（Redirect） 是利用服务器返回的状态码来实现的。客户端浏览器请求服务器的时候，服务器会返回一个状态码。服务器通过 HttpServletResponse 的 setStatus(int status) 方法设置状态码。如果服务器返回301或者302，则浏览器会到新的网址重新请求该资源。 从地址栏显示来说 forward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址. redirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL. 从数据共享来说 forward:转发页面和转发到的页面可以共享request里面的数据. redirect:不能共享数据. 从运用地方来说 forward:一般用于用户登陆的时候,根据角色转发到相应的模块. redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等 从效率来说 forward:高. redirect:低. 自动刷新(Refresh) 自动刷新不仅可以实现一段时间之后自动跳转到另一个页面，还可以实现一段时间之后自动刷新本页面。Servlet中通过HttpServletResponse对象设置Header属性实现自动刷新例如： 1Response.setHeader(\"Refresh\",\"5;URL=http://localhost:8080/servlet/example.htm\"); 其中5为时间，单位为秒。URL指定就是要跳转的页面（如果设置自己的路径，就会实现每过5秒自动刷新本页面一次） Servlet与线程安全 Servlet不是线程安全的，多线程并发的读写会导致数据不同步的问题。 解决的办法是尽量不要定义name属性，而是要把name变量分别定义在doGet()和doPost()方法内。虽然使用synchronized(name){}语句块可以解决问题，但是会造成线程的等待，不是很科学的办法。 注意：多线程的并发的读写Servlet类属性会导致数据不同步。但是如果只是并发地读取属性而不写入，则不存在数据不同步的问题。因此Servlet里的只读属性最好定义为final类型的。 参考：《javaweb整合开发王者归来》P92 JSP和Servlet是什么关系 其实这个问题在上面已经阐述过了，Servlet是一个特殊的Java程序，它运行于服务器的JVM中，能够依靠服务器的支持向浏览器提供显示内容。JSP本质上是Servlet的一种简易形式，JSP会被服务器处理成一个类似于Servlet的Java程序，可以简化页面内容的生成。Servlet和JSP最主要的不同点在于，Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML分离开来。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件。有人说，Servlet就是在Java中写HTML，而JSP就是在HTML中写Java代码，当然这个说法是很片面且不够准确的。JSP侧重于视图，Servlet更侧重于控制逻辑，在MVC架构模式中，JSP适合充当视图（view）而Servlet适合充当控制器（controller）。 JSP工作原理 JSP是一种Servlet，但是与HttpServlet的工作方式不太一样。HttpServlet是先由源代码编译为class文件后部署到服务器下，为先编译后部署。而JSP则是先部署后编译。JSP会在客户端第一次请求JSP文件时被编译为HttpJspPage类（接口Servlet的一个子类）。该类会被服务器临时存放在服务器工作目录里面。下面通过实例给大家介绍。 工程JspLoginDemo下有一个名为login.jsp的Jsp文件，把工程第一次部署到服务器上后访问这个Jsp文件，我们发现这个目录下多了下图这两个东东。 .class文件便是JSP对应的Servlet。编译完毕后再运行class文件来响应客户端请求。以后客户端访问login.jsp的时候，Tomcat将不再重新编译JSP文件，而是直接调用class文件来响应客户端请求。 由于JSP只会在客户端第一次请求的时候被编译 ，因此第一次请求JSP时会感觉比较慢，之后就会感觉快很多。如果把服务器保存的class文件删除，服务器也会重新编译JSP。 开发Web程序时经常需要修改JSP。Tomcat能够自动检测到JSP程序的改动。如果检测到JSP源代码发生了改动。Tomcat会在下次客户端请求JSP时重新编译JSP，而不需要重启Tomcat。这种自动检测功能是默认开启的，检测改动会消耗少量的时间，在部署Web应用的时候可以在web.xml中将它关掉。 参考：《javaweb整合开发王者归来》P97 JSP有哪些内置对象、作用分别是什么 JSP内置对象 - CSDN博客 JSP有9个内置对象： request：封装客户端的请求，其中包含来自GET或POST请求的参数； response：封装服务器对客户端的响应； pageContext：通过该对象可以获取其他对象； session：封装用户会话的对象； application：封装服务器运行环境的对象； out：输出服务器响应的输出流对象； config：Web应用的配置对象； page：JSP页面本身（相当于Java程序中的this）； exception：封装页面抛出异常的对象。 Request对象的主要方法有哪些 setAttribute(String name,Object)：设置名字为name的request 的参数值 getAttribute(String name)：返回由name指定的属性值 getAttributeNames()：返回request 对象所有属性的名字集合，结果是一个枚举的实例 getCookies()：返回客户端的所有 Cookie 对象，结果是一个Cookie 数组 getCharacterEncoding() ：返回请求中的字符编码方式 = getContentLength() ：返回请求的 Body的长度 getHeader(String name) ：获得HTTP协议定义的文件头信息 getHeaders(String name) ：返回指定名字的request Header 的所有值，结果是一个枚举的实例 getHeaderNames() ：返回所以request Header 的名字，结果是一个枚举的实例 getInputStream() ：返回请求的输入流，用于获得请求中的数据 getMethod() ：获得客户端向服务器端传送数据的方法 getParameter(String name) ：获得客户端传送给服务器端的有 name指定的参数值 getParameterNames() ：获得客户端传送给服务器端的所有参数的名字，结果是一个枚举的实例 getParameterValues(String name)：获得有name指定的参数的所有值 getProtocol()：获取客户端向服务器端传送数据所依据的协议名称 getQueryString() ：获得查询字符串 getRequestURI() ：获取发出请求字符串的客户端地址 getRemoteAddr()：获取客户端的 IP 地址 getRemoteHost() ：获取客户端的名字 getSession([Boolean create]) ：返回和请求相关 Session getServerName() ：获取服务器的名字 getServletPath()：获取客户端所请求的脚本文件的路径 getServerPort()：获取服务器的端口号 removeAttribute(String name)：删除请求中的一个属性 request.getAttribute()和 request.getParameter()有何区别 从获取方向来看： getParameter()是获取 POST/GET 传递的参数值； getAttribute()是获取对象容器中的数据值； 从用途来看： getParameter用于客户端重定向时，即点击了链接或提交按扭时传值用，即用于在用表单或url重定向传值时接收数据用。 getAttribute用于服务器端重定向时，即在 sevlet 中使用了 forward 函数,或 struts 中使用了 mapping.findForward。 getAttribute 只能收到程序用 setAttribute 传过来的值。 另外，可以用 setAttribute,getAttribute 发送接收对象.而 getParameter 显然只能传字符串。 setAttribute 是应用服务器把这个对象放在该页面所对应的一块内存中去，当你的页面服务器重定向到另一个页面时，应用服务器会把这块内存拷贝另一个页面所对应的内存中。这样getAttribute就能取得你所设下的值，当然这种方法可以传对象。session也一样，只是对象在内存中的生命周期不一样而已。getParameter只是应用服务器在分析你送上来的 request页面的文本时，取得你设在表单或 url 重定向时的值。 总结： getParameter 返回的是String,用于读取提交的表单中的值;（获取之后会根据实际需要转换为自己需要的相应类型，比如整型，日期类型啊等等） getAttribute 返回的是Object，需进行转换,可用setAttribute 设置成任意对象，使用很灵活，可随时用 include指令include的行为的区别 include指令： JSP可以通过include指令来包含其他文件。被包含的文件可以是JSP文件、HTML文件或文本文件。包含的文件就好像是该JSP文件的一部分，会被同时编译执行。 语法格式如下： &lt;%@ include file=“文件相对 url 地址” %&gt; include动作： jsp:include动作元素用来包含静态和动态的文件。该动作把指定文件插入正在生成的页面。语法格式如下： &lt;jsp:include page=“相对 URL 地址” flush=“true” /&gt; JSP九大内置对象，七大动作，三大指令 JSP九大内置对象，七大动作，三大指令总结 讲解JSP中的四种作用域 JSP中的四种作用域包括page、request、session和application，具体来说： page代表与一个页面相关的对象和属性。 request代表与Web客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个Web组件；需要在页面显示的临时数据可以置于此作用域。 session代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的session中。 application代表与整个Web应用程序相关的对象和属性，它实质上是跨越整个Web应用程序，包括多个页面、请求和会话的一个全局作用域。 如何实现JSP或Servlet的单线程模式 对于JSP页面，可以通过page指令进行设置。 &lt;%@page isThreadSafe=”false”%&gt; 对于Servlet，可以让自定义的Servlet实现SingleThreadModel标识接口。 说明：如果将JSP或Servlet设置成单线程工作模式，会导致每个请求创建一个Servlet实例，这种实践将导致严重的性能问题（服务器的内存压力很大，还会导致频繁的垃圾回收），所以通常情况下并不会这么做。 实现会话跟踪的技术有哪些 使用Cookie 向客户端发送Cookie 123Cookie c =new Cookie(\"name\",\"value\"); //创建Cookie c.setMaxAge(60*60*24); //设置最大时效，此处设置的最大时效为一天response.addCookie(c); //把Cookie放入到HTTP响应中 从客户端读取Cookie 123456789101112String name =\"name\"; Cookie[]cookies =request.getCookies(); if(cookies !=null)&#123; for(int i= 0;i&lt;cookies.length;i++)&#123; Cookie cookie =cookies[i]; if(name.equals(cookis.getName())) //something is here. //you can get the value cookie.getValue(); &#125; &#125; 优点: 数据可以持久保存，不需要服务器资源，简单，基于文本的Key-Value 缺点: 大小受到限制，用户可以禁用Cookie功能，由于保存在本地，有一定的安全风险。 URL 重写 在URL中添加用户会话的信息作为请求的参数，或者将唯一的会话ID添加到URL结尾以标识一个会话。 优点： 在Cookie被禁用的时候依然可以使用 缺点： 必须对网站的URL进行编码，所有页面必须动态生成，不能用预先记录下来的URL进行访问。 3.隐藏的表单域 1&lt;input type=\"hidden\" name =\"session\" value=\"...\"/&gt; 优点： Cookie被禁时可以使用 缺点： 所有页面必须是表单提交之后的结果。 HttpSession 在所有会话跟踪技术中，HttpSession对象是最强大也是功能最多的。当一个用户第一次访问某个网站时会自动创建 HttpSession，每个用户可以访问他自己的HttpSession。可以通过HttpServletRequest对象的getSession方 法获得HttpSession，通过HttpSession的setAttribute方法可以将一个值放在HttpSession中，通过调用 HttpSession对象的getAttribute方法，同时传入属性名就可以获取保存在HttpSession中的对象。与上面三种方式不同的 是，HttpSession放在服务器的内存中，因此不要将过大的对象放在里面，即使目前的Servlet容器可以在内存将满时将HttpSession 中的对象移到其他存储设备中，但是这样势必影响性能。添加到HttpSession中的值可以是任意Java对象，这个对象最好实现了 Serializable接口，这样Servlet容器在必要的时候可以将其序列化到文件中，否则在序列化时就会出现异常。 Cookie和Session的的区别 由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如Memcached之类的来放 Session。 思考一下服务端如何识别特定的客户？这个时候Cookie就登场了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。 Cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到Cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是Cookie名称的由来，给用户的一点甜头。所以，总结一下：Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。 参考： https://www.zhihu.com/question/19786827/answer/28752144 《javaweb整合开发王者归来》P158 Cookie和Session的比较","categories":[{"name":"Java","slug":"Java","permalink":"http://i.codingce.com.cn/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://i.codingce.com.cn/tags/Java/"}]},{"title":"第一个MVC程序","slug":"第一个MVC程序","date":"2020-08-02T02:39:36.000Z","updated":"2020-12-13T04:41:40.453Z","comments":true,"path":"2020/08/02/第一个MVC程序/","link":"","permalink":"http://i.codingce.com.cn/2020/08/02/%E7%AC%AC%E4%B8%80%E4%B8%AAMVC%E7%A8%8B%E5%BA%8F/","excerpt":"","text":"配置版 新建一个Moudle ， springmvc-02-hello ， 添加web的支持！ 确定导入了SpringMVC 的依赖！ 配置web.xml ， 注册DispatcherServlet 1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;!--1.注册DispatcherServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--关联一个springmvc的配置文件:【servlet-name】-servlet.xml--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--启动级别-1--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--/ 匹配所有的请求；（不包括.jsp）--&gt; &lt;!--/* 匹配所有的请求；（包括.jsp）--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 编写SpringMVC 的 配置文件！名称：springmvc-servlet.xml : [servletname]-servlet.xml 说明，这里的名称要求是按照官方来的 12345678910111213141516171819202122232425262728&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!--添加 处理映射器--&gt; &lt;bean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"/&gt; &lt;!--添加 处理器适配器--&gt; &lt;bean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\"/&gt; &lt;!--添加 视图解析器--&gt; &lt;!--视图解析器:DispatcherServlet给他的ModelAndView--&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"InternalResourceViewResolver\"&gt; &lt;!--前缀--&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"/&gt; &lt;!--后缀--&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt; &lt;!--Handler--&gt; &lt;bean id=\"/hello\" class=\"cn.com.codingce.controller.HelloController\"/&gt;&lt;/beans&gt; 添加 处理映射器 1&lt;bean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"/&gt; 添加 处理器适配器 1&lt;bean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\"/&gt; 添加 视图解析器 1234567&lt;!--视图解析器:DispatcherServlet给他的ModelAndView--&gt;&lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"InternalResourceViewResolver\"&gt; &lt;!--前缀--&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"/&gt; &lt;!--后缀--&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt;&lt;/bean&gt; 编写我们要操作业务Controller ，要么实现Controller接口，要么增加注解；需要返回一个ModelAndView，装数据，封视图； 123456789101112131415161718192021222324package cn.com.codingce.controller;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.mvc.Controller;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;//注意：这里我们先导入Controller接口//编写我们要操作业务Controller ，要么实现Controller接口，要么增加注解；需要返回一个ModelAndView，装数据，封视图；public class HelloController implements Controller &#123; public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; //ModelAndView 模型和视图 ModelAndView mv = new ModelAndView(); //封装对象，放在ModelAndView中。Model mv.addObject(\"msg\",\"HelloSpringMVC!\"); //封装要跳转的视图，放在ModelAndView中 mv.setViewName(\"hello\"); //类似于项目一: /WEB-INF/jsp/hello.jsp return mv; &#125;&#125; 将自己的类交给SpringIOC容器，注册bean 123&lt;!--Handler--&gt;&lt;bean id=\"/hello\" class=\"com.kuang.controller.HelloController\"/&gt; 写要跳转的jsp页面，显示ModelandView存放的数据，以及我们的正常页面； 12345678910111213141516&lt;%-- Created by IntelliJ IDEA. User: xzMa Date: 2020/8/2 Time: 11:34 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;msg&#125;&lt;/body&gt;&lt;/html&gt; 配置Tomcat 启动测试！ 可能遇到的问题：访问出现404，排查步骤： 查看控制台输出，看一下是不是缺少了什么jar包。 如果jar包存在，显示无法输出，就在IDEA的项目发布中，添加lib依赖！ 重启Tomcat 即可解决！ 注解版 新建一个Moudle，springmvc-03-hello-annotation 。添加web支持！ 由于Maven可能存在资源过滤的问题，我们将配置完善 任何maven项目都建议在pom.xml中加上以下资源过滤配置 123456789101112131415161718192021&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 在pom.xml文件引入相关的依赖：主要有Spring框架核心库、Spring MVC、servlet , JSTL等。我们在父依赖中已经引入了！ 配置web.xml 1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;!--1.注册servlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动顺序，数字越小，启动越早 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--所有请求都会被springmvc拦截 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; / 和 /* 的区别：&lt; url-pattern &gt; / &lt;/ url-pattern &gt; 不会匹配到.jsp， 只针对我们编写的请求；即：.jsp 不会进入spring的 DispatcherServlet类 。&lt; url-pattern &gt; /* &lt;/ url-pattern &gt; 会匹配 .jsp，会出现返回 jsp视图 时再次进入spring的DispatcherServlet 类，导致找不到对应的controller所以报404错。 - 注意web.xml版本问题，要最新版！ - 注册DispatcherServlet - 关联SpringMVC的配置文件 - 启动级别为1 - 映射路径为 / 【不要用/，会404】 Controller 1234567891011121314151617package cn.com.codingce.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;@Controller@RequestMapping(\"/hello\")public class HelloController&#123; @RequestMapping(\"/h1\") public String hello(Model mv) &#123; //封装数据 mv.addAttribute(\"msg\", \"HelloAnnotation\"); return \"hello\"; //会被视图解析器处理 &#125;&#125; @Controller是为了让Spring IOC容器初始化时自动扫描到； @RequestMapping是为了映射请求路径，这里因为类与方法上都有映射所以访问时应该是/HelloController/hello； 方法中声明Model类型的参数是为了把Action中的数据带到视图中； 方法返回的结果是视图的名称hello，加上配置文件中的前后缀变成WEB-INF/jsp/hello.jsp。 创建视图层 在WEB-INF/ jsp目录中创建hello.jsp ， 视图可以直接取出并展示从Controller带回的信息； 可以通过EL表示取出Model中存放的值，或者对象； 123456789&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;SpringMVC&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;msg&#125;&lt;/body&gt;&lt;/html&gt; 配置Tomcat运行 配置Tomcat ， 开启服务器 ， 访问 对应的请求路径！ 小结 实现步骤其实非常的简单： 新建一个web项目 导入相关jar包 编写web.xml , 注册DispatcherServlet 编写springmvc配置文件 接下来就是去创建对应的控制类 , controller 最后完善前端视图和controller之间的对应 测试运行调试. 使用springMVC必须配置的三大件： 处理器映射器、处理器适配器、视图解析器 通常，我们只需要手动配置视图解析器，而处理器映射器和处理器适配器只需要开启注解驱动即可，而省去了大段的xml配置","categories":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://i.codingce.com.cn/categories/SpringMVC/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://i.codingce.com.cn/tags/SpringMVC/"}]},{"title":"初识SpringMVC","slug":"什么是SpringMVC","date":"2020-08-01T14:52:36.000Z","updated":"2020-12-13T04:41:40.438Z","comments":true,"path":"2020/08/01/什么是SpringMVC/","link":"","permalink":"http://i.codingce.com.cn/2020/08/01/%E4%BB%80%E4%B9%88%E6%98%AFSpringMVC/","excerpt":"","text":"回顾MVC 什么是MVC MVC是模型(Model)、视图(View)、控制器(Controller)的简写，是一种软件设计规范。 是将业务逻辑、数据、显示分离的方法来组织代码。 MVC主要作用是降低了视图与业务逻辑间的双向偶合。 MVC不是一种设计模式，MVC是一种架构模式。当然不同的MVC存在差异。 Model（模型）：数据模型，提供要展示的数据，因此包含数据和行为，可以认为是领域模型或JavaBean组件（包含数据和行为），不过现在一般都分离开来：Value Object（数据Dao） 和 服务层（行为Service）。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。 View（视图）：负责进行模型的展示，一般就是我们见到的用户界面，客户想看到的东西。 Controller（控制器）：接收用户请求，委托给模型进行处理（状态改变），处理完毕后把返回的模型数据返回给视图，由视图负责展示。也就是说控制器做了个调度员的工作。 最典型的MVC就是JSP + servlet + javabean的模式。 Model1时代 在web早期的开发中，通常采用的都是Model1。 Model1中，主要分为两层，视图层和模型层。 Model1优点：架构简单，比较适合小型项目开发； Model1缺点：JSP职责不单一，职责过重，不便于维护； Model2时代 Model2把一个项目分成三部分，包括视图、控制、模型。 用户发请求 Servlet接收请求数据，并调用对应的业务逻辑方法 业务处理完毕，返回更新后的数据给servlet servlet转向到JSP，由JSP来渲染页面 响应给前端更新后的页面 职责分析： Controller：控制器 取得表单数据 调用业务逻辑 转向指定的页面 Model：模型 业务逻辑 保存数据的状态 View：视图 显示页面 Model2这样不仅提高的代码的复用率与项目的扩展性，且大大降低了项目的维护成本。Model 1模式的实现比较简单，适用于快速开发小规模项目，Model1中JSP页面身兼View和Controller两种角色，将控制逻辑和表现逻辑混杂在一起，从而导致代码的重用性非常低，增加了应用的扩展性和维护的难度。Model2消除了Model1的缺点。 假设: 你的项目的架构, 是设计好的还是演进的? Alibaba PHP 随着用户大 java 王坚 去 IOE MySql Mysql: Mysql-&gt;AliSQL-&gt;AliRedis All in one —&gt;微服务 回顾Servlet 新建一个Maven工程当做父工程！pom依赖！ 123456789101112131415161718192021222324252627&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 建立一个Moudle：springmvc-01-servlet ， 添加Web app的支持！ 导入servlet 和 jsp 的 jar 依赖 12345678910&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt;&lt;/dependency&gt; 编写一个Servlet类，用来处理用户的请求 123456789101112131415161718192021222324252627282930package cn.com.codingce.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class HelloServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //取得参数 String method = req.getParameter(\"method\"); if (method.equals(\"add\"))&#123; req.getSession().setAttribute(\"msg\",\"执行了add方法\"); &#125; if (method.equals(\"delete\"))&#123; req.getSession().setAttribute(\"msg\",\"执行了delete方法\"); &#125; //业务逻辑 //视图跳转 req.getRequestDispatcher(\"/WEB-INF/jsp/test.jsp\").forward(req, resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; super.doGet(req, resp); &#125;&#125; 编写test.jsp，在WEB-INF目录下新建一个jsp的文件夹，新建test.jsp 12345678910111213141516&lt;%-- Created by IntelliJ IDEA. User: xzMa Date: 2020/8/2 Time: 9:22 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;msg&#125;&lt;/body&gt;&lt;/html&gt; 在web.xml中注册Servlet 123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;servlet&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;servlet-class&gt;cn.com.codingce.servlet.HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;session-config&gt; &lt;session-timeout&gt;15&lt;/session-timeout&gt; &lt;/session-config&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt; 配置Tomcat，并启动测试 localhost:8080/user?method=add localhost:8080/user?method=delete MVC框架要做哪些事情 将url映射到java类或java类的方法 . 封装用户提交的数据 . 处理请求–调用相关的业务处理–封装响应数据 . 将响应的数据进行渲染 . jsp / html 等表示层数据 . 说明： 常见的服务器端MVC框架有：Struts、Spring MVC、ASP.NET MVC、Zend Framework、JSF；常见前端MVC框架：vue、angularjs、react、backbone；由MVC演化出了另外一些模式如：MVP、MVVM 等等… 全栈: 后台 + 前端 + 数据库 + 运维 前端: 后台Node.js + 前端 MVC MVVM: M V VM ViewModel: 双向绑定 什么是SpringMVC 概述 Spring MVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架。 查看官方文档：https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/web.html#spring-web 我们为什么要学习SpringMVC呢? Spring MVC的特点： 轻量级，简单易学 高效 , 基于请求响应的MVC框架 与Spring兼容性好，无缝结合 约定优于配置 功能强大：RESTful、数据验证、格式化、本地化、主题等 简洁灵活 Spring的web框架围绕DispatcherServlet [ 调度Servlet ] 设计。 DispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解形式进行开发，十分简洁； 正因为SpringMVC好 , 简单 , 便捷 , 易学 , 天生和Spring无缝集成(使用SpringIoC和Aop) , 使用约定优于配置 . 能够进行简单的junit测试 . 支持Restful风格 .异常处理 , 本地化 , 国际化 , 数据验证 , 类型转换 , 拦截器 等等…所以我们要学习 . 最重要的一点还是用的人多 , 使用的公司多 . 中心控制器 Spring的web框架围绕DispatcherServlet设计。DispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解的controller声明方式。 Spring MVC框架像许多其他MVC框架一样, 以请求为驱动 , 围绕一个中心Servlet分派请求及提供其他功能，DispatcherServlet是一个实际的Servlet (它继承自HttpServlet 基类)。 SpringMVC的原理如下图所示： 当发起请求时被前置的控制器拦截到请求，根据请求参数生成代理请求，找到请求对应的实际控制器，控制器处理请求，创建数据模型，访问数据库，将模型响应给中心控制器，控制器使用模型与视图渲染视图结果，将结果返回给中心控制器，再将结果返回给请求者。 SpringMVC执行原理 图为SpringMVC的一个较完整的流程图，实线表示SpringMVC框架提供的技术，不需要开发者实现，虚线表示需要开发者实现。 简要分析执行流程 DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。我们假设请求的url为 : http://localhost:8080/SpringMVC/hello 如上url拆分成三部分： http://localhost:8080服务器域名 SpringMVC部署在服务器上的web站点 hello表示控制器 通过分析，如上url表示为：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器。 HandlerMapping为处理器映射。DispatcherServlet调用 HandlerMapping,HandlerMapping根据请求url查找Handler。 HandlerExecution表示具体的Handler,其主要作用是根据url查找控制器，如上url被查找控制器为：hello。 HandlerExecution将解析后的信息传递给DispatcherServlet,如解析控制器映射等。 HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler。 Handler让具体的Controller执行。 Controller将具体的执行信息返回给HandlerAdapter,如ModelAndView。 HandlerAdapter将视图逻辑名或模型传递给DispatcherServlet。 DispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。 视图解析器将解析的逻辑视图名传给DispatcherServlet。 DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图。 最终视图呈现给用户。 微信公众号","categories":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://i.codingce.com.cn/categories/SpringMVC/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://i.codingce.com.cn/tags/SpringMVC/"}]},{"title":"Java基础知识","slug":"Java基础知识","date":"2020-08-01T14:37:39.000Z","updated":"2020-12-13T04:41:40.422Z","comments":true,"path":"2020/08/01/Java基础知识/","link":"","permalink":"http://i.codingce.com.cn/2020/08/01/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"1. 面向对象和面向过程的区别 面向过程 面向对象 2. Java 语言有哪些特点 3. 关于 JVM JDK 和 JRE 最详细通俗的解答 JVM JDK 和 JRE 4. Oracle JDK 和 OpenJDK 的对比 5. Java和C++的区别 6. 什么是 Java 程序的主类 应用程序和小程序的主类有何不同 7. Java 应用程序与小程序之间有那些差别 8. 字符型常量和字符串常量的区别 9. 构造器 Constructor 是否可被 override 10. 重载和重写的区别 11. Java 面向对象编程三大特性: 封装 继承 多态 封装 继承 多态 12. String StringBuffer 和 StringBuilder 的区别是什么 String 为什么是不可变的 13. 自动装箱与拆箱 14. 在一个静态方法内调用一个非静态成员为什么是非法的 15. 在 Java 中定义一个不做事且没有参数的构造方法的作用 16. import java和javax有什么区别 17. 接口和抽象类的区别是什么 18. 成员变量与局部变量的区别有那些 19. 创建一个对象用什么运算符?对象实体与对象引用有何不同? 20. 什么是方法的返回值?返回值在类的方法里的作用是什么? 21. 一个类的构造方法的作用是什么 若一个类没有声明构造方法,该程序能正确执行吗 ?为什么? 22. 构造方法有哪些特性 23. 静态方法和实例方法有何不同 24. 对象的相等与指向他们的引用相等，两者有什么不同？ 25. 在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是? 26. == 与 equals(重要) 27. hashCode 与 equals (重要) hashCode（）介绍 为什么要有 hashCode hashCode（）与equals（）的相关规定 28. 为什么Java中只有值传递 29. 简述线程，程序、进程的基本概念。以及他们之间关系是什么 30. 线程有哪些基本状态? 31 关于 final 关键字的一些总结 32 Java 中的异常处理 Java异常类层次结构图 Throwable类常用方法 异常处理总结 33 Java序列化中如果有些字段不想进行序列化 怎么办 34 获取用键盘输入常用的的两种方法 参考 1. 面向对象和面向过程的区别 面向过程 优点： 性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。 缺点： 没有面向对象易维护、易复用、易扩展 面向对象 优点： 易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护 缺点： 性能比面向过程低 2. Java 语言有哪些特点 简单易学； 面向对象（封装，继承，多态）； 平台无关性（ Java 虚拟机实现平台无关性）； 可靠性； 安全性； 支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）； 支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）； 编译与解释并存； 3. 关于 JVM JDK 和 JRE 最详细通俗的解答 JVM Java虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。 什么是字节码?采用字节码的好处是什么? 在 Java 中，JVM可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。 Java 程序从源代码到运行一般有下面3步： 我们需要格外注意的是 .class-&gt;机器码 这一步。在这一步 jvm 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的，也就是所谓的热点代码，所以后面引进了 JIT 编译器，JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。 HotSpot采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是JIT所需要编译的部分。JVM会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9引入了一种新的编译模式AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了JIT预热等各方面的开销。JDK支持分层编译和AOT协作使用。但是 ，AOT 编译器的编译质量是肯定比不上 JIT 编译器的。 总结：Java虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。 JDK 和 JRE JDK是Java Development Kit，它是功能齐全的Java SDK。它拥有JRE所拥有的一切，还有编译器（javac）和工具（如javadoc和jdb）。它能够创建和编译程序。 JRE 是 Java运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java虚拟机（JVM），Java类库，java命令和其他的一些基础构件。但是，它不能用于创建新程序。 如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装JDK了。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何Java开发，仍然需要安装JDK。例如，如果要使用JSP部署Web应用程序，那么从技术上讲，您只是在应用程序服务器中运行Java程序。那你为什么需要JDK呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。 4. Oracle JDK 和 OpenJDK 的对比 可能在看这个问题之前很多人和我一样并没有接触和使用过 OpenJDK 。那么Oracle和OpenJDK之间是否存在重大差异？下面通过我通过我收集到一些资料对你解答这个被很多人忽视的问题。 对于Java 7，没什么关键的地方。OpenJDK项目主要基于Sun捐赠的HotSpot源代码。此外，OpenJDK被选为Java 7的参考实现，由Oracle工程师维护。关于JVM，JDK，JRE和OpenJDK之间的区别，Oracle博客帖子在2012年有一个更详细的答案： 问：OpenJDK存储库中的源代码与用于构建Oracle JDK的代码之间有什么区别？ 答：非常接近 - 我们的Oracle JDK版本构建过程基于OpenJDK 7构建，只添加了几个部分，例如部署代码，其中包括Oracle的Java插件和Java WebStart的实现，以及一些封闭的源代码派对组件，如图形光栅化器，一些开源的第三方组件，如Rhino，以及一些零碎的东西，如附加文档或第三方字体。展望未来，我们的目的是开源Oracle JDK的所有部分，除了我们考虑商业功能的部分。 总结： Oracle JDK版本将每三年发布一次，而OpenJDK版本每三个月发布一次； OpenJDK 是一个参考模型并且是完全开源的，而Oracle JDK是OpenJDK的一个实现，并不是完全开源的； Oracle JDK 比 OpenJDK 更稳定。OpenJDK和Oracle JDK的代码几乎相同，但Oracle JDK有更多的类和一些错误修复。因此，如果您想开发企业/商业软件，我建议您选择Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到Oracle JDK就可以解决问题； 在响应性和JVM性能方面，Oracle JDK与OpenJDK相比提供了更好的性能； Oracle JDK不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本； Oracle JDK根据二进制代码许可协议获得许可，而OpenJDK根据GPL v2许可获得许可。 5. Java和C++的区别 我知道很多人没学过 C++，但是面试官就是没事喜欢拿咱们 Java 和 C++ 比呀！没办法！！！就算没学过C++，也要记下来！ 都是面向对象的语言，都支持封装、继承和多态 Java 不提供指针来直接访问内存，程序内存更加安全 Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。 Java 有自动内存管理机制，不需要程序员手动释放无用内存 6. 什么是 Java 程序的主类 应用程序和小程序的主类有何不同 一个程序中可以有多个类，但只能有一个类是主类。在 Java 应用程序中，这个主类是指包含 main（）方法的类。而在 Java 小程序中，这个主类是一个继承自系统类 JApplet 或 Applet 的子类。应用程序的主类不一定要求是 public 类，但小程序的主类要求必须是 public 类。主类是 Java 程序执行的入口点。 7. Java 应用程序与小程序之间有那些差别 简单说应用程序是从主线程启动(也就是 main() 方法)。applet 小程序没有main方法，主要是嵌在浏览器页面上运行(调用init()线程或者run()来启动)，嵌入浏览器这点跟 flash 的小游戏类似。 8. 字符型常量和字符串常量的区别 形式上: 字符常量是单引号引起的一个字符 字符串常量是双引号引起的若干个字符 含义上: 字符常量相当于一个整形值( ASCII 值),可以参加表达式运算 字符串常量代表一个地址值(该字符串在内存中存放位置) 占内存大小 字符常量只占2个字节 字符串常量占若干个字节(至少一个字符结束标志) (注意： char在Java中占两个字节) java编程思想第四版：2.2.2节 9. 构造器 Constructor 是否可被 override 在讲继承的时候我们就知道父类的私有属性和构造方法并不能被继承，所以 Constructor 也就不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。 10. 重载和重写的区别 重载： 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。 重写： 发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为 private 则子类就不能重写该方法。 11. Java 面向对象编程三大特性: 封装 继承 多态 封装 封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。 继承 继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。 关于继承如下 3 点请记住： 子类拥有父类非 private 的属性和方法。 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。 子类可以用自己的方式实现父类的方法。（以后介绍）。 多态 所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。 在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。 12. String StringBuffer 和 StringBuilder 的区别是什么 String 为什么是不可变的 可变性 简单的来说：String 类中使用 final 关键字字符数组保存字符串，private final char value[]，所以 String 对象是不可变的。而StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串char[]value 但是没有用 final 关键字修饰，所以这两种对象都是可变的。 StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法也就是 AbstractStringBuilder 实现的，大家可以自行查阅源码。 AbstractStringBuilder.java 12345678abstract class AbstractStringBuilder implements Appendable, CharSequence &#123; char[] value; int count; AbstractStringBuilder() &#123; &#125; AbstractStringBuilder(int capacity) &#123; value = new char[capacity]; &#125; 线程安全性 String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。 性能 每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。 对于三者使用的总结： 操作少量的数据 = String 单线程操作字符串缓冲区下操作大量数据 = StringBuilder 多线程操作字符串缓冲区下操作大量数据 = StringBuffer 13. 自动装箱与拆箱 装箱：将基本类型用它们对应的引用类型包装起来； 拆箱：将包装类型转换为基本数据类型； 14. 在一个静态方法内调用一个非静态成员为什么是非法的 由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。 15. 在 Java 中定义一个不做事且没有参数的构造方法的作用 Java 程序在执行子类的构造方法之前，如果没有用 super() 来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 super() 来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。 16. import java和javax有什么区别 刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是扩展 API 包来说使用。然而随着时间的推移，javax 逐渐的扩展成为 Java API 的组成部分。但是，将扩展从 javax 包移动到 java 包将是太麻烦了，最终会破坏一堆现有的代码。因此，最终决定 javax 包将成为标准API的一部分。 所以，实际上java和javax没有区别。这都是一个名字。 17. 接口和抽象类的区别是什么 接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），抽象类可以有非抽象的方法 接口中的实例变量默认是 final 类型的，而抽象类中则不一定 一个类可以实现多个接口，但最多只能实现一个抽象类 一个类实现接口的话要实现接口的所有方法，而抽象类不一定 接口不能用 new 实例化，但可以声明，但是必须引用一个实现该接口的对象 从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。 备注:在JDK8中，接口也可以定义静态方法，可以直接用接口名调用。实现类和实现是不可以调用的。如果同时实现两个接口，接口中定义了一样的默认方法，必须重写，不然会报错。(详见issue:https://github.com/Snailclimb/JavaGuide/issues/146) 18. 成员变量与局部变量的区别有那些 从语法形式上，看成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰； 从变量在内存中的存储方式来看:如果成员变量是使用static修饰的，那么这个成员变量是属于类的，如果没有使用使用static修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量存在于栈内存 从变量在内存中的生存时间上看:成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。 成员变量如果没有被赋初值:则会自动以类型的默认值而赋值（一种情况例外被 final 修饰的成员变量也必须显示地赋值）；而局部变量则不会自动赋值。 19. 创建一个对象用什么运算符?对象实体与对象引用有何不同? new运算符，new创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向0个或1个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有n个引用指向它（可以用n条绳子系住一个气球）。 20. 什么是方法的返回值?返回值在类的方法里的作用是什么? 方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用:接收出结果，使得它可以用于其他的操作！ 21. 一个类的构造方法的作用是什么 若一个类没有声明构造方法,该程序能正确执行吗 ?为什么? 主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。 22. 构造方法有哪些特性 名字与类名相同； 没有返回值，但不能用void声明构造函数； 生成类的对象时自动执行，无需调用。 23. 静态方法和实例方法有何不同 在外部调用静态方法时，可以使用&quot;类名.方法名&quot;的方式，也可以使用&quot;对象名.方法名&quot;的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。 静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制. 24. 对象的相等与指向他们的引用相等,两者有什么不同? 对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。 25. 在调用子类构造方法之前会先调用父类没有参数的构造方法,其目的是? 帮助子类做初始化工作。 26. == 与 equals(重要) == : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型==比较的是值，引用数据类型==比较的是内存地址) equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况： 情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。 情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。 举个例子： 1234567891011121314151617public class test1 &#123; public static void main(String[] args) &#123; String a = new String(\"ab\"); // a 为一个引用 String b = new String(\"ab\"); // b为另一个引用,对象的内容一样 String aa = \"ab\"; // 放在常量池中 String bb = \"ab\"; // 从常量池中查找 if (aa == bb) // true System.out.println(\"aa==bb\"); if (a == b) // false，非同一对象 System.out.println(\"a==b\"); if (a.equals(b)) // true System.out.println(\"aEQb\"); if (42 == 42.0) &#123; // true System.out.println(\"true\"); &#125; &#125;&#125; 说明： String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。 当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。 27. hashCode 与 equals (重要) 面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？” hashCode（）介绍 hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。 散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象） 为什么要有 hashCode 我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode： 当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals（）方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的Java启蒙书《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。 hashCode（）与equals（）的相关规定 如果两个对象相等，则hashcode一定也是相同的 两个对象相等,对两个对象分别调用equals方法都返回true 两个对象有相同的hashcode值，它们也不一定是相等的 因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖 hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据） 28. 为什么Java中只有值传递 为什么Java中只有值传递？ 29. 简述线程,程序,进程的基本概念.以及他们之间关系是什么? 线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。 程序是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。 进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如CPU时间，内存空间，文件，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。 线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。 30. 线程有哪些基本状态? Java 线程在运行的生命周期中的指定时刻只可能处于下面6种不同状态的其中一个状态（图源《Java 并发编程艺术》4.1.4节）。 线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。Java 线程状态变迁如下图所示（图源《Java 并发编程艺术》4.1.4节）： 由上图可以看出： 线程创建之后它将处于 NEW（新建） 状态，调用 start() 方法后开始运行，线程这时候处于 READY（可运行） 状态。可运行状态的线程获得了 cpu 时间片（timeslice）后就处于 RUNNING（运行） 状态。 操作系统隐藏 Java虚拟机（JVM）中的 RUNNABLE 和 RUNNING 状态，它只能看到 RUNNABLE 状态（图源：HowToDoInJava：Java Thread Life Cycle and Thread States），所以 Java 系统一般将这两个状态统称为 RUNNABLE（运行中） 状态 。 当线程执行 wait()方法之后，线程进入 **WAITING（等待）**状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 TIME_WAITING(超时等待) 状态相当于在等待状态的基础上增加了超时限制，比如通过 sleep（long millis）方法或 wait（long millis）方法可以将 Java 线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 BLOCKED（阻塞） 状态。线程在执行 Runnable 的run()方法之后将会进入到 TERMINATED（终止） 状态。 31 关于 final 关键字的一些总结 final关键字主要用在三个地方：变量、方法、类。 对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。 当用final修饰一个类时，表明这个类不能被继承。final类中的所有成员方法都会被隐式地指定为final方法。 使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的Java版本已经不需要使用final方法进行这些优化了）。类中所有的private方法都隐式地指定为final。 32 Java 中的异常处理 Java异常类层次结构图 在 Java 中，所有的异常都有一个共同的祖先java.lang包中的 Throwable类。Throwable： 有两个重要的子类：Exception（异常） 和 Error（错误） ，二者都是 Java 异常处理的重要子类，各自都包含大量子类。 Error（错误）:是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。 这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如Java虚拟机运行错误（Virtual MachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在 Java中，错误通过Error的子类描述。 Exception（异常）:是程序本身可以处理的异常。Exception 类有一个重要的子类 RuntimeException。RuntimeException 异常由Java虚拟机抛出。NullPointerException（要访问的变量没有引用任何对象时，抛出该异常）、ArithmeticException（算术运算异常，一个整数除以0时，抛出该异常）和 ArrayIndexOutOfBoundsException （下标越界异常）。 注意：异常和错误的区别：异常能被程序本身可以处理，错误是无法处理。 Throwable类常用方法 public string getMessage():返回异常发生时的详细信息 public string toString():返回异常发生时的简要描述 public string getLocalizedMessage():返回异常对象的本地化信息。使用Throwable的子类覆盖这个方法，可以声称本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与getMessage（）返回的结果相同 public void printStackTrace():在控制台上打印Throwable对象封装的异常信息 异常处理总结 **try 块：**用于捕获异常。其后可接零个或多个catch块，如果没有catch块，则必须跟一个finally块。 **catch 块：**用于处理try捕获到的异常。 **finally 块：**无论是否捕获或处理异常，finally块里的语句都会被执行。当在try块或catch块中遇到return语句时，finally语句块将在方法返回之前被执行。 在以下4种特殊情况下，finally块不会被执行： 在finally语句块第一行发生了异常。 因为在其他行，finally块还是会得到执行 在前面的代码中用了System.exit(int)已退出程序。 exit是带参函数 ；若该语句在异常语句之后，finally会执行 程序所在的线程死亡。 关闭CPU。 下面这部分内容来自issue:https://github.com/Snailclimb/JavaGuide/issues/190。 关于返回值： 如果try语句里有return，返回的是try语句块中变量值。 详细执行过程如下： 如果有返回值，就把返回值保存到局部变量中； 执行jsr指令跳到finally语句里执行； 执行完finally语句后，返回之前保存在局部变量表里的值。 如果try，finally语句里均有return，忽略try的return，而使用finally的return. 33 Java序列化中如果有些字段不想进行序列化 怎么办 对于不想进行序列化的变量，使用transient关键字修饰。 transient关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被transient修饰的变量值不会被持久化和恢复。transient只能修饰变量，不能修饰类和方法。 34 获取用键盘输入常用的的两种方法 方法1：通过 Scanner 123Scanner input = new Scanner(System.in);String s = input.nextLine();input.close(); 方法2：通过 BufferedReader 12BufferedReader input = new BufferedReader(new InputStreamReader(System.in)); String s = input.readLine(); 参考 https://stackoverflow.com/questions/1906445/what-is-the-difference-between-jdk-and-jre https://www.educba.com/oracle-vs-openjdk/ https://stackoverflow.com/questions/22358071/differences-between-oracle-jdk-and-openjdk?answertab=active#tab-top","categories":[{"name":"Java","slug":"Java","permalink":"http://i.codingce.com.cn/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://i.codingce.com.cn/tags/Java/"}]},{"title":"JDK8--Lambda表达式","slug":"JDK8-Lambda表达式","date":"2020-08-01T14:31:17.000Z","updated":"2020-12-13T04:41:40.422Z","comments":true,"path":"2020/08/01/JDK8-Lambda表达式/","link":"","permalink":"http://i.codingce.com.cn/2020/08/01/JDK8-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"JDK8–Lambda表达式 1.什么是Lambda表达式 Lambda表达式实质上是一个可传递的代码块，Lambda又称为闭包或者匿名函数，是函数式编程语法，让方法可以像普通参数一样传递 2.Lambda表达式语法 (参数列表) -&gt; {执行代码块} 参数列表可以为空()-&gt;{} 可以加类型声明比如(String para1, int para2) -&gt; {return para1 + para2;}我们可以看到，lambda同样可以有返回值. 在编译器可以推断出类型的时候，可以将类型声明省略，比如(para1, para2) -&gt; {return para1 + para2;} (lambda有点像动态类型语言语法。lambda在字节码层面是用invokedynamic实现的，而这条指令就是为了让JVM更好的支持运行在其上的动态类型语言) 3.函数式接口 在了解Lambda表达式之前，有必要先了解什么是函数式接口(@FunctionalInterface) 函数式接口指的是有且只有一个抽象(abstract)方法的接口 当需要一个函数式接口的对象时，就可以用Lambda表达式来实现，举个常用的例子: 123Thread thread = new Thread(() -&gt; &#123; System.out.println(\"This is JDK8's Lambda!\");&#125;); 这段代码和函数式接口有啥关系？我们回忆一下，Thread类的构造函数里是不是有一个以Runnable接口为参数的？ 123456789public Thread(Runnable target) &#123;...&#125;/** * Runnable Interface */@FunctionalInterfacepublic interface Runnable &#123; public abstract void run();&#125; 到这里大家可能已经明白了，Lambda表达式相当于一个匿名类或者说是一个匿名方法。上面Thread的例子相当于 123456Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"Anonymous class\"); &#125;&#125;); 也就是说，上面的lambda表达式相当于实现了这个run()方法，然后当做参数传入(个人感觉可以这么理解,lambda表达式就是一个函数，只不过它的返回值、参数列表都 由编译器帮我们推断，因此可以减少很多代码量)。 Lambda也可以这样用 : 1Runnable runnable = () -&gt; &#123;...&#125;; 其实这和上面的用法没有什么本质上的区别。 至此大家应该明白什么是函数式接口以及函数式接口和lambda表达式之间的关系了。在JDK8中修改了接口的规范， 目的是为了在给接口添加新的功能时保持向前兼容(个人理解)，比如一个已经定义了的函数式接口，某天我们想给它添加新功能，那么就不能保持向前兼容了， 因为在旧的接口规范下，添加新功能必定会破坏这个函数式接口(JDK8中接口规范) 除了上面说的Runnable接口之外，JDK中已经存在了很多函数式接口 比如(当然不止这些): java.util.concurrent.Callable java.util.Comparator java.io.FileFilter 关于JDK中的预定义的函数式接口 JDK在java.util.function下预定义了很多函数式接口 Function&lt;T, R&gt; {R apply(T t);} 接受一个T对象，然后返回一个R对象，就像普通的函数。 Consumer&lt;T&gt; {void accept(T t);} 消费者 接受一个T对象，没有返回值。 Predicate&lt;T&gt; {boolean test(T t);} 判断，接受一个T对象，返回一个布尔值。 Supplier&lt;T&gt; {T get();} 提供者(工厂) 返回一个T对象。 其他的跟上面的相似，大家可以看一下function包下的具体接口。 4.变量作用域 12345678910111213141516171819202122232425262728public class VaraibleHide &#123; @FunctionalInterface interface IInner &#123; void printInt(int x); &#125; public static void main(String[] args) &#123; int x = 20; IInner inner = new IInner() &#123; int x = 10; @Override public void printInt(int x) &#123; System.out.println(x); &#125; &#125;; inner.printInt(30); inner = (s) -&gt; &#123; //Variable used in lambda expression should be final or effectively final //!int x = 10; //!x= 50; error System.out.print(x); &#125;; inner.printInt(30); &#125;&#125;输出 :3020 对于lambda表达式java inner = (s) -&gt; {System.out.print(x);};,变量x并不是在lambda表达式中定义的，像这样并不是在lambda中定义或者通过lambda的参数列表()获取的变量成为自由变量，它是被lambda表达式捕获的。 lambda表达式和内部类一样，对外部自由变量捕获时，外部自由变量必须为final或者是最终变量(effectively final)的，也就是说这个变量初始化后就不能为它赋新值， 同时lambda不像内部类/匿名类，lambda表达式与外围嵌套块有着相同的作用域，因此对变量命名的有关规则对lambda同样适用。大家阅读上面的代码对这些概念应该 不难理解。 5.方法引用 只需要提供方法的名字，具体的调用过程由Lambda和函数式接口来确定，这样的方法调用成为方法引用。 下面的例子会打印list中的每个元素: 12345List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; ++i) &#123; list.add(i); &#125; list.forEach(System.out::println); 其中System.out::println这个就是一个方法引用，等价于Lambda表达式 (para)-&gt;{System.out.println(para);} 我们看一下List#forEach方法 default void forEach(Consumer&lt;? super T&gt; action)可以看到它的参数是一个Consumer接口，该接口是一个函数式接口 123@FunctionalInterfacepublic interface Consumer&lt;T&gt; &#123; void accept(T t); 大家能发现这个函数接口的方法和System.out::println有什么相似的么？没错，它们有着相似的参数列表和返回值。 我们自己定义一个方法，看看能不能像标准输出的打印函数一样被调用 123456789101112131415public class MethodReference &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; ++i) &#123; list.add(i); &#125; list.forEach(MethodReference::myPrint); &#125; static void myPrint(int i) &#123; System.out.print(i + \", \"); &#125;&#125;输出: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 可以看到，我们自己定义的方法也可以当做方法引用。 到这里大家多少对方法引用有了一定的了解，我们再来说一下方法引用的形式。 方法引用 类名::静态方法名 类名::实例方法名 类名::new (构造方法引用) 实例名::实例方法名 可以看出，方法引用是通过(方法归属名)::(方法名)来调用的。通过上面的例子已经讲解了一个类名::静态方法名的使用方法了，下面再依次介绍其余的几种 方法引用的使用方法。 类名::实例方法名 先来看一段代码 12String[] strings = new String[10];Arrays.sort(strings, String::compareToIgnoreCase); 上面的String::compareToIgnoreCase等价于(x, y) -&gt; {return x.compareToIgnoreCase(y);} 我们看一下Arrays#sort方法public static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c), 可以看到第二个参数是一个Comparator接口，该接口也是一个函数式接口，其中的抽象方法是int compare(T o1, T o2);，再看一下 String#compareToIgnoreCase方法,public int compareToIgnoreCase(String str)，这个方法好像和上面讲方法引用中类名::静态方法名不大一样啊，它 的参数列表和函数式接口的参数列表不一样啊，虽然它的返回值一样？ 是的，确实不一样但是别忘了，String类的这个方法是个实例方法，而不是静态方法，也就是说，这个方法是需要有一个接收者的。所谓接收者就是 instance.method(x)中的instance， 它是某个类的实例，有的朋友可能已经明白了。上面函数式接口的compare(T o1, T o2)中的第一个参数作为了实例方法的接收者，而第二个参数作为了实例方法的 参数。我们再举一个自己实现的例子: 12345678910public class MethodReference &#123; static Random random = new Random(47); public static void main(String[] args) &#123; MethodReference[] methodReferences = new MethodReference[10]; Arrays.sort(methodReferences, MethodReference::myCompare); &#125; int myCompare(MethodReference o) &#123; return random.nextInt(2) - 1; &#125;&#125; 上面的例子可以在IDE里通过编译，大家有兴趣的可以模仿上面的例子自己写一个程序，打印出排序后的结果。 构造器引用 构造器引用仍然需要与特定的函数式接口配合使用，并不能像下面这样直接使用。IDE会提示String不是一个函数式接口 12//compile error : String is not a functional interfaceString str = String::new; 下面是一个使用构造器引用的例子，可以看出构造器引用可以和这种工厂型的函数式接口一起使用的。 12345678910111213141516 interface IFunctional&lt;T&gt; &#123; T func();&#125;public class ConstructorReference &#123; public ConstructorReference() &#123; &#125; public static void main(String[] args) &#123; Supplier&lt;ConstructorReference&gt; supplier0 = () -&gt; new ConstructorReference(); Supplier&lt;ConstructorReference&gt; supplier1 = ConstructorReference::new; IFunctional&lt;ConstructorReference&gt; functional = () -&gt; new ConstructorReference(); IFunctional&lt;ConstructorReference&gt; functional1 = ConstructorReference::new; &#125;&#125; 下面是一个JDK官方的例子 12345678910111213141516public static &lt;T, SOURCE extends Collection&lt;T&gt;, DEST extends Collection&lt;T&gt;&gt; DEST transferElements( SOURCE sourceCollection, Supplier&lt;DEST&gt; collectionFactory) &#123; DEST result = collectionFactory.get(); for (T t : sourceCollection) &#123; result.add(t); &#125; return result; &#125; ... Set&lt;Person&gt; rosterSet = transferElements( roster, HashSet::new); 实例::实例方法 其实开始那个例子就是一个实例::实例方法的引用 12345List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; ++i) &#123; list.add(i); &#125; list.forEach(System.out::println); 其中System.out就是一个实例，println是一个实例方法。相信不用再给大家做解释了。 总结 Lambda表达式是JDK8引入Java的函数式编程语法，使用Lambda需要直接或者间接的与函数式接口配合，在开发中使用Lambda可以减少代码量， 但是并不是说必须要使用Lambda(虽然它是一个很酷的东西)。有些情况下使用Lambda会使代码的可读性急剧下降，并且也节省不了多少代码， 所以在实际开发中还是需要仔细斟酌是否要使用Lambda。和Lambda相似的还有JDK10中加入的var类型推断，同样对于这个特性需要斟酌使用。","categories":[{"name":"Java","slug":"Java","permalink":"http://i.codingce.com.cn/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://i.codingce.com.cn/tags/Java/"}]},{"title":"声明式事务","slug":"声明式事务","date":"2020-08-01T08:46:21.000Z","updated":"2020-12-13T04:41:40.438Z","comments":true,"path":"2020/08/01/声明式事务/","link":"","permalink":"http://i.codingce.com.cn/2020/08/01/%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1/","excerpt":"","text":"声明式事务 回顾事务 把一组业务当成一个业务来做,要么都成功, 要么都失败 事务在项目开发中, 十分的重要, 涉及到数据一致性问题, 不能马虎 确保事务完整性和一致性 事务ACID原则 原子性 一致性 隔离性 多个业务可能操作同一资源, 防止数据损坏 持久性 事务一旦提交, 无论系统发生什么问题, 结果都不会在被影响, 被持久化的写到存储器中! Spring中的事务管理 声明式事务：AOP 编程式事务: 需要在代码中进行代码的管理 思考: 为什么要事务？ 如果不配置事务, 可能存在数据提交不一致的情况下; 如果我们不在Spring中去配置声明式事务, 我们就需要在代码中手动配置事务 事务在项目的开发中十分重要, 设计到数据的一致性和完整性问题, 不容马虎 appliactionContext.xml 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx https://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;import resource=\"spring-dao.xml\"/&gt; &lt;bean id=\"userMapper\" class=\"cn.com.codingce.mapper.UserMapperImpl\"&gt; &lt;property name=\"sqlSession\" ref=\"sqlSession\"/&gt; &lt;/bean&gt; &lt;bean id=\"userMapper2\" class=\"cn.com.codingce.mapper.UserMapperImpl2\"&gt; &lt;property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"/&gt; &lt;/bean&gt; &lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;!--给那些方法配置事务 事务传播propagation=\"REQUIRED\"默认是这个--&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"add\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"delete\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"update\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"query\" read-only=\"true\"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!--配置事务切入--&gt; &lt;aop:config&gt; &lt;aop:pointcut id=\"txPointCut\" expression=\"execution(* cn.com.codingce.mapper.*.*(..))\"/&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"txPointCut\"/&gt; &lt;/aop:config&gt;&lt;/beans&gt; spring-dao.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 遇到的问题以及解决方案 https://blog.csdn.net/weixin_43874301/article/details/107732178 --&gt; &lt;!--DateSource:使用Spring的数据源替换Mybatis的配置 c3p0 dbcp druid 我们这里使用Spring提供的JDBC org.springframework.jdbc.datasource --&gt; &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://cdb-q9atzwrq.bj.tencentcdb.com:10167/mybatis?useSSL=true\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"123456\"/&gt; &lt;/bean&gt; &lt;!--sqlSessionFactory--&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;!--绑定Mybatis配置文件--&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/&gt; &lt;property name=\"mapperLocations\" value=\"classpath:cn/com/codingce/mapper/*.xml\"/&gt; &lt;/bean&gt; &lt;!--SqlSessionTemplate 这就是我们使用的sqlSession--&gt; &lt;bean id=\"sqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\"&gt; &lt;!--只能使用构造器注入sqlSessionFactory, 因为它没有set方法--&gt; &lt;constructor-arg index=\"0\" ref=\"sqlSessionFactory\"/&gt; &lt;/bean&gt;&lt;!-- &lt;bean id=\"userMapper\" class=\"cn.com.codingce.mapper.UserMapperImpl\"&gt;--&gt;&lt;!-- &lt;property name=\"sqlSession\" ref=\"sqlSession\"/&gt;--&gt;&lt;!-- &lt;/bean&gt;--&gt; &lt;!--配置声明式事务--&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;constructor-arg name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;/bean&gt; &lt;!--结合AOP实现事务的织入--&gt; &lt;!--配置事物的类:--&gt;&lt;/beans&gt; 1234567public interface UserMapper &#123; public List&lt;User&gt; selectUser(); public int addUser(User user); public int deleteUser(int id);&#125; mapper.xml 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"cn.com.codingce.mapper.UserMapper\"&gt; &lt;select id=\"selectUser\" resultType=\"user\"&gt; select * from user; &lt;/select&gt; &lt;insert id=\"addUser\" parameterType=\"user\"&gt; insert into mybatis.user (id, name, pwd) values (#&#123;id&#125;, #&#123;name&#125;, #&#123;pwd&#125;) &lt;/insert&gt; &lt;delete id=\"deleteUser\" parameterType=\"int\"&gt; delete from user where id = #&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; UserMapperImpl 123456789101112131415161718192021222324252627282930package cn.com.codingce.mapper;import cn.com.codingce.pojo.User;import org.mybatis.spring.SqlSessionTemplate;import java.util.List;public class UserMapperImpl implements UserMapper &#123; //我们所有操作, 都使用sqlSession来执行, 在原来, 现在都是用SqlSessionTemplate private SqlSessionTemplate sqlSession; public void setSqlSession(SqlSessionTemplate sqlSession) &#123; this.sqlSession = sqlSession; &#125; public List&lt;User&gt; selectUser() &#123; UserMapper mapper = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; userList = mapper.selectUser(); return userList; &#125; public int addUser(User user) &#123; return sqlSession.getMapper(UserMapper.class).addUser(user); &#125; public int deleteUser(int id) &#123; return sqlSession.getMapper(UserMapper.class).deleteUser(id); &#125;&#125; 测试类 123456789101112131415161718192021222324252627282930313233343536import cn.com.codingce.mapper.UserMapper;import cn.com.codingce.pojo.User;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import java.io.IOException;public class MyTest &#123; @Test public void test1() throws IOException &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); UserMapper userMapper = context.getBean(\"userMapper\", UserMapper.class); for (User user : userMapper.selectUser()) &#123; System.out.println(user); &#125; &#125; @Test public void Test2() &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); UserMapper userMapper = context.getBean(\"userMapper\", UserMapper.class); System.out.println(userMapper.deleteUser(10)); &#125; @Test public void Test3() &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); UserMapper userMapper = context.getBean(\"userMapper\", UserMapper.class); User user = new User(11, \"事务\", \"123456\"); System.out.println(userMapper.addUser(user)); &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"http://i.codingce.com.cn/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://i.codingce.com.cn/tags/Spring/"}]},{"title":"Spring整合Mybatis","slug":"Spring整合Mybatis","date":"2020-08-01T01:23:33.000Z","updated":"2020-12-13T04:41:40.422Z","comments":true,"path":"2020/08/01/Spring整合Mybatis/","link":"","permalink":"http://i.codingce.com.cn/2020/08/01/Spring%E6%95%B4%E5%90%88Mybatis/","excerpt":"","text":"整合Mybatis 导入相关jar包 junit mybatis mysql数据库 spring相关的 aop织入 mybatis-spring 【new】 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 &lt;dependencies&gt; &lt;!--mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.4&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.16&lt;/version&gt; &lt;/dependency&gt; &lt;!--Spring操作数据库的话还需要一个spring-jdbc--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.13&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;!--在build中配置resources, 来防止我们资源导出失败的问题--&gt;&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 编写配置文件 测试 回忆Mybatis（他认识你你不认识他） 编写实体类 123456public class User &#123; private int id; private String name; private String pwd; &#125; 编写核心配置文件 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;!--核心配置文件--&gt;&lt;configuration&gt; &lt;!--引入外部配置文件--&gt; &lt;properties resource=\"db.properties\" /&gt; &lt;!--标准日志工厂--&gt; &lt;settings&gt; &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/&gt; &lt;/settings&gt; &lt;!--别名 类就不用写长的包名了--&gt; &lt;typeAliases&gt; &lt;package name=\"cn.com.codingce.pojo\"/&gt; &lt;/typeAliases&gt; &lt;!--下面有两个配置, 默认是id=development &amp;amp;代表and(非&amp;)--&gt; &lt;environments default=\"test\"&gt; &lt;environment id=\"test\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper class=\"cn.com.codingce.mapper.UserMapper\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 编写接口 1234567891011package cn.com.codingce.mapper;import cn.com.codingce.pojo.User;import java.util.List;public interface UserMapper &#123; public List&lt;User&gt; selectUser();&#125; 编写Mapper.xml 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"cn.com.codingce.mapper.UserMapper\"&gt; &lt;select id=\"selectUser\" resultType=\"user\"&gt; select * from user; &lt;/select&gt;&lt;/mapper&gt; 测试 123456789101112@Testpublic void test1() throws IOException &#123; String resources = \"mybatis-config.xml\"; InputStream in = Resources.getResourceAsStream(resources); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(in); SqlSession sqlSession = sqlSessionFactory.openSession(true); UserMapper mapper = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; userList = mapper.selectUser(); for (User user : userList) &#123; System.out.println(user); &#125;&#125; Mybatis-Spring 编写数据源 1234567891011121314&lt;!-- 遇到的问题以及解决方案 https://blog.csdn.net/weixin_43874301/article/details/107732178--&gt;&lt;!--DateSource:使用Spring的数据源替换Mybatis的配置 c3p0 dbcp druid 我们这里使用Spring提供的JDBC org.springframework.jdbc.datasource--&gt;&lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://cdb-q9atzwrq.bj.tencentcdb.com:10167/mybatis?useSSL=true\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"123456\"/&gt;&lt;/bean&gt; sqlSessionFactory 1234567&lt;!--sqlSessionFactory--&gt;&lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;!--绑定Mybatis配置文件--&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/&gt; &lt;property name=\"mapperLocations\" value=\"classpath:cn/com/codingce/mapper/*.xml\"/&gt;&lt;/bean&gt; sqlSessionTemplate 12345&lt;!--SqlSessionTemplate 这就是我们使用的sqlSession--&gt;&lt;bean id=\"sqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\"&gt; &lt;!--只能使用构造器注入sqlSessionFactory, 因为它没有set方法--&gt; &lt;constructor-arg index=\"0\" ref=\"sqlSessionFactory\"/&gt;&lt;/bean&gt; 需要给接口添加实现类【】 123456789101112131415public class UserMapperImpl implements UserMapper &#123; //我们所有操作, 都使用sqlSession来执行, 在原来, 现在都是用SqlSessionTemplate private SqlSessionTemplate sqlSession; public void setSqlSession(SqlSessionTemplate sqlSession) &#123; this.sqlSession = sqlSession; &#125; public List&lt;User&gt; selectUser() &#123; UserMapper mapper = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; userList = mapper.selectUser(); return userList; &#125;&#125; 将自己的实现类，注入到Spring中 123&lt;bean id=\"userMapper\" class=\"cn.com.codingce.mapper.UserMapperImpl\"&gt; &lt;property name=\"sqlSession\" ref=\"sqlSession\"/&gt;&lt;/bean&gt; 测试使用即可 12345678@Testpublic void test1() throws IOException &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); UserMapper userMapper = context.getBean(\"userMapper\", UserMapper.class); for (User user : userMapper.selectUser()) &#123; System.out.println(user); &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"http://i.codingce.com.cn/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://i.codingce.com.cn/tags/Spring/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://i.codingce.com.cn/tags/MyBatis/"}]},{"title":"git的add、commit、push的详细介绍","slug":"git的add、commit、push的详细介绍","date":"2020-07-31T02:23:07.000Z","updated":"2020-12-13T04:41:40.438Z","comments":true,"path":"2020/07/31/git的add、commit、push的详细介绍/","link":"","permalink":"http://i.codingce.com.cn/2020/07/31/git%E7%9A%84add%E3%80%81commit%E3%80%81push%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"简单的代码提交流程 git status 查看工作区代码相对于暂存区的差别 git add . 将当前目录下修改的所有代码从工作区添加到暂存区 . 代表当前目录 git commit -m ‘注释’ 将缓存区内容添加到本地仓库 git pull origin master先将远程仓库master中的信息同步到本地仓库master中 git push origin master 将本地版本库推送到远程服务器， origin是远程主机，master表示是远程服务器上的master分支和本地分支重名的简写，分支名是可以修改的 Git add git add [参数] &lt;路径&gt; 作用就是将我们需要提交的代码从工作区添加到暂存区，就是告诉git系统，我们要提交哪些文件，之后就可以使用git commit命令进行提交了。 为了方便下面都用 . 来标识路径， . 表示当前目录，路径可以修改，下列操作的作用范围都在版本库之内。 git add . 不加参数默认为将修改操作的文件和未跟踪新添加的文件添加到git系统的暂存区，注意不包括删除 git add -u . -u 表示将已跟踪文件中的修改和删除的文件添加到暂存区，不包括新增加的文件，注意这些被删除的文件被加入到暂存区再被提交并推送到服务器的版本库之后这个文件就会从git系统中消失了。 git add -A . -A 表示将所有的已跟踪的文件的修改与删除和新增的未跟踪的文件都添加到暂存区。 Git commit git commit 主要是将暂存区里的改动给提交到本地的版本库。每次使用git commit 命令我们都会在本地版本库生成一个40位的哈希值，这个哈希值也叫commit-id， commit-id 在版本回退的时候是非常有用的，它相当于一个快照,可以在未来的任何时候通过与git reset的组合命令回到这里. git commit -m ‘message’ -m 参数表示可以直接输入后面的“message”，如果不加 -m参数，那么是不能直接输入message的，而是会调用一个编辑器一般是vim来让你输入这个message， message即是我们用来简要说明这次提交的语句。 git commit -am ‘message’ -am等同于-a -m -a参数可以将所有已跟踪文件中的执行修改或删除操作的文件都提交到本地仓库，即使它们没有经过git add添加到暂存区， 注意: 新加的文件（即没有被git系统管理的文件）是不能被提交到本地仓库的。 Git push 在使用git commit命令将修改从暂存区提交到本地版本库后，只剩下最后一步将本地版本库的分支推送到远程服务器上对应的分支了，如果不清楚版本库的构成，可以查看我的另一篇，git 仓库的基本结构。 git push的一般形式为 git push &lt;远程主机名&gt; &lt;本地分支名&gt; &lt;远程分支名&gt; ，例如 git push origin master：refs/for/master ，即是将本地的master分支推送到远程主机origin上的对应master分支， origin 是远程主机名。第一个master是本地分支名，第二个master是远程分支名。 git push origin master 如果远程分支被省略，如上则表示将本地分支推送到与之存在追踪关系的远程分支（通常两者同名），如果该远程分支不存在，则会被新建 git push origin ：refs/for/master 如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支，等同于 git push origin –delete master git push origin 如果当前分支与远程分支存在追踪关系，则本地分支和远程分支都可以省略，将当前分支推送到origin主机的对应分支 git push 如果当前分支只有一个远程分支，那么主机名都可以省略，形如 git push，可以使用git branch -r ，查看远程的分支名 关于 refs/for： refs/for 的意义在于我们提交代码到服务器之后是需要经过code review 之后才能进行merge的，而refs/heads 不需要","categories":[{"name":"Git","slug":"Git","permalink":"http://i.codingce.com.cn/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://i.codingce.com.cn/tags/Git/"}]},{"title":"AOP","slug":"SpringAop","date":"2020-07-23T11:18:05.000Z","updated":"2020-12-13T04:41:40.422Z","comments":true,"path":"2020/07/23/SpringAop/","link":"","permalink":"http://i.codingce.com.cn/2020/07/23/SpringAop/","excerpt":"","text":"代理模式 为什么要学习代理模式，因为AOP的底层机制就是动态代理！ 代理模式： 静态代理 动态代理 学习aop之前 , 我们要先了解一下代理模式！ 静态代理 静态代理角色分析 抽象角色 : 一般使用接口或者抽象类来实现 真实角色 : 被代理的角色 代理角色 : 代理真实角色 ; 代理真实角色后 , 一般会做一些附属的操作 . 客户 : 使用代理角色来进行一些操作 . 动态代理 动态代理的角色和静态代理的一样 . 动态代理的代理类是动态生成的 . 静态代理的代理类是我们提前写好的 动态代理分为两类 : 一类是基于接口动态代理 , 一类是基于类的动态代理 基于接口的动态代理----JDK动态代理 基于类的动态代理–cglib 现在用的比较多的是 javasist 来生成动态代理 . 百度一下javasist 我们这里使用JDK的原生代码来实现，其余的道理都是一样的！、 JDK的动态代理需要了解两个类 核心 : InvocationHandler 和 Proxy ， 打开JDK帮助文档看看 【InvocationHandler：调用处理程序】 动态代理的好处 静态代理有的它都有，静态代理没有的，它也有！ 可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 . 公共的业务由代理来完成 . 实现了业务的分工 , 公共业务发生扩展时变得更加集中和方便 . 一个动态代理 , 一般代理某一类业务 一个动态代理可以代理多个类，代理的是接口！ 代码 接口 123456789/** * @author xzMa * 租房 */public interface Rent &#123; public void rent();&#125; 真实角色 12345678910/** * @author xzMa * 房东 * */public class Host implements Rent &#123; public void rent() &#123; System.out.println(\"房东要出租房子\"); &#125;&#125; 代理角色 12345678910111213141516171819202122232425262728293031323334public class Proxy implements Rent &#123; private Host host; public Proxy() &#123; &#125; public Proxy(Host host) &#123; this.host = host; &#125; public void rent() &#123; seeHourse(); host.rent(); fare(); &#125; //看房 public void seeHourse() &#123; System.out.println(\"中介带你看房\"); &#125; //合同 public void heTong() &#123; System.out.println(\"签租赁合同\"); &#125; //中介费 public void fare() &#123; System.out.println(\"收中介费\"); &#125;&#125; 客户端访问代理角色 123456789101112public class Client &#123; public static void main(String[] args) &#123; Host host = new Host(); host.rent(); //代理模式 中介帮房东租房子 但是呢 代理一般都有一些附属操作 Proxy proxy = new Proxy(host); proxy.rent(); &#125;&#125; 缺点 一个真实角色就会产生一个代理角色, 代码量就会翻倍 开发效率会变低 静态代理详解 1234567public interface UserService &#123; public void add(); public void delete(); public void update(); public void query();&#125; 123456789101112131415161718192021//真实对象public class UserServiceImpl implements UserService &#123; public void add() &#123; System.out.println(\"使用了add方法\"); System.out.println(\"添加了一个用户\"); &#125; public void delete() &#123; System.out.println(\"删除了用户\"); &#125; public void update() &#123; System.out.println(\"修改了一个用户\"); &#125; public void query() &#123; System.out.println(\"查询一个用户\"); &#125; //1 改动原有的业务代码, 在公司中是大忌&#125; 12345678910111213141516171819202122232425262728293031323334public class UserServiceProxy implements UserService &#123; private UserServiceImpl userService; public void setUserService(UserServiceImpl userService) &#123; this.userService = userService; &#125; public void add() &#123; log(\"add\"); userService.add(); &#125; public void delete() &#123; log(\"delete\"); userService.delete(); &#125; public void update() &#123; log(\"update\"); userService.update(); &#125; public void query() &#123; log(\"query\"); userService.query(); &#125; //日志方法 public void log(String msg) &#123; System.out.println(\"[Debug]使用了\" + msg + \"方法\"); &#125;&#125; 1234567891011public static void main(String args[]) &#123; UserServiceImpl userService = new UserServiceImpl(); UserServiceProxy proxy = new UserServiceProxy(); proxy.setUserService(userService); proxy.add();&#125; 动态代理 动态代理和静态代理角色一样 动态代理的代理类是动态生成的, 不是我们直接写好的 动态代理分为两大类: 基于接口的动态代理, 基于类的动态代理 基于接口-JDK动态代理 基于类: cglib java字节码实现: javasist 需要了解两个类: Proxy InvocationHandler ProxyInvocationHandler类 123456789101112131415161718192021222324252627282930313233343536373839404142//等会我们会用这个类, 自动生成代理类public class ProxyInvocationHandler implements InvocationHandler &#123; //被代理的接口 public Rent rent; public Rent getRent() &#123; return rent; &#125; public void setRent(Rent rent) &#123; this.rent = rent; &#125; ////生成代理类 public Object getProxy() &#123; return Proxy.newProxyInstance(this.getClass().getClassLoader(), rent.getClass().getInterfaces(), this); &#125; //处理代理的实例, 并返回结果 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //动态代理的本质, 就是使用反射机制来实现 seeHourse(); Object result = method.invoke(rent, args); return result; &#125; //看房 public void seeHourse() &#123; System.out.println(\"中介带你看房\"); &#125; //合同 public void heTong() &#123; System.out.println(\"签租赁合同\"); &#125; //中介费 public void fare() &#123; System.out.println(\"收中介费\"); &#125;&#125; Rent 123456789/** * @author xzMa * 租房 */public interface Rent &#123; public void rent();&#125; Host 12345678910/** * @author xzMa * 房东 * */public class Host implements Rent &#123; public void rent() &#123; System.out.println(\"房东要出租房子\"); &#125;&#125; Client 12345678910111213141516public class Client &#123; public static void main(String[] args) &#123; //真实角色 Host host = new Host(); //代理角色 ProxyInvocationHandler pih = new ProxyInvocationHandler(); //通过调用程序处理角色来处理我们要调用的接口对象 pih.setRent(host); Rent proxy = (Rent) pih.getProxy();//这里的proxy就是动态生成的, 我们并没有写 proxy.rent(); &#125;&#125; 继续优化使其成为公共的 1234567891011121314151617181920212223242526272829303132//等会我们会用这个类, 自动生成代理类public class ProxyInvocationHandler implements InvocationHandler &#123; //被代理的接口 public Object target; public Object getTarget() &#123; return target; &#125; public void setTarget(Object target) &#123; this.target = target; &#125; ////生成代理类 public Object getProxy() &#123; return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(), this); &#125; //处理代理的实例, 并返回结果 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //动态代理的本质, 就是使用反射机制来实现 log(method.getName()); Object result = method.invoke(target, args); return result; &#125; public void log(String msg) &#123; System.out.println(\"执行了\"+ msg +\"方法\"); &#125;&#125; Client 123456789101112131415public class Client &#123; public static void main(String[] args) &#123; //真实角色 UserServiceImpl userService = new UserServiceImpl(); //代理角色 不存在 ProxyInvocationHandler pih = new ProxyInvocationHandler(); pih.setTarget(userService); //设置要代理的对象 //动态生成代理类 UserService proxy = (UserService) pih.getProxy(); proxy.add(); &#125;&#125; 动态代理的好处 可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 . 公共的业务由代理来完成 . 实现了业务的分工 , 公共业务发生扩展时变得更加集中和方便 . 一个动态代理是一个接口, 一般就是对应的一类业务 一个动态代理可以代理多个类，只要是实现了一个接口即可 什么是AOP 进入重点 什么是AOP AOP（Aspect Oriented Programming）意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 Aop在Spring中的作用 提供声明式事务；允许用户自定义切面 以下名词需要了解下： 横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志 , 安全 , 缓存 , 事务等等 … 切面（ASPECT）：横切关注点 被模块化 的特殊对象。即，它是一个类。 通知（Advice）：切面必须要完成的工作。即，它是类中的一个方法。 目标（Target）：被通知对象。 代理（Proxy）：向目标对象应用通知之后创建的对象。 切入点（PointCut）：切面通知 执行的 “地点”的定义。 连接点（JointPoint）：与切入点匹配的执行点。 SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice: 即 Aop 在 不改变原有代码的情况下 , 去增加新的功能 . 使用Spring实现Aop 重点】使用AOP织入，需要导入一个依赖包！ 123456&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt;&lt;/dependency&gt; 第一种方式 通过 Spring API 实现 首先编写我们的业务接口和实现类 log类 1234567891011121314151617public class AfterLog implements AfterReturningAdvice &#123; //returnValue 返回值 public void afterReturning(Object returnValue, Method method, Object[] objects, Object o1) throws Throwable &#123; System.out.println(\"执行了\" + method.getName() + \"返回结果为\" + returnValue); &#125;&#125;public class Log implements MethodBeforeAdvice &#123; //method: 要执行的目标对象的方法 //objects：参数 //target：目标对象 public void before(Method method, Object[] objects, Object target) throws Throwable &#123; System.out.println(target.getClass().getName() + \"的\" + method.getName() + \"被执行了\"); &#125;&#125; UserService 123456public interface UserService &#123; public void add(); public void delete(); public void update(); public void select();&#125; UserServiceImpl 1234567891011121314151617public class UserServiceImpl implements UserService &#123; public void add() &#123; System.out.println(\"增加了一个用户\"); &#125; public void delete() &#123; System.out.println(\"删除了一个用户\"); &#125; public void update() &#123; System.out.println(\"修改了一个用户\"); &#125; public void select() &#123; System.out.println(\"查询了一个用户\"); &#125;&#125; bean 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!--指定要扫描的宝, 这个包下的注解就会生效--&gt; &lt;context:component-scan base-package=\"cn.com.codingce\"/&gt; &lt;!--开启注解的支持--&gt; &lt;context:annotation-config/&gt; &lt;!--注册bean--&gt; &lt;bean id=\"userService\" class=\"cn.com.codingce.service.UserServiceImpl\"/&gt; &lt;bean id=\"log\" class=\"cn.com.codingce.log.Log\"/&gt; &lt;bean id=\"afterLog\" class=\"cn.com.codingce.log.AfterLog\"/&gt; &lt;!--方式一: 使用Spring API接口--&gt; &lt;!--配置aop: 需要导入aop的约束--&gt; &lt;aop:config&gt; &lt;!--切入点：expression：表达式 execution(要执行的位置)--&gt; &lt;aop:pointcut id=\"pointcut\" expression=\"execution(* cn.com.codingce.service.UserServiceImpl.*(..))\"/&gt; &lt;!--执行环绕增加!--&gt; &lt;aop:advisor advice-ref=\"log\" pointcut-ref=\"pointcut\"/&gt; &lt;aop:advisor advice-ref=\"afterLog\" pointcut-ref=\"pointcut\"/&gt; &lt;/aop:config&gt;&lt;/beans&gt; 第二种 自定义实现AOP【主要切面定义】 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!--指定要扫描的宝, 这个包下的注解就会生效--&gt; &lt;context:component-scan base-package=\"cn.com.codingce\"/&gt; &lt;!--开启注解的支持--&gt; &lt;context:annotation-config/&gt; &lt;!--注册bean--&gt; &lt;bean id=\"userService\" class=\"cn.com.codingce.service.UserServiceImpl\"/&gt; &lt;bean id=\"log\" class=\"cn.com.codingce.log.Log\"/&gt; &lt;bean id=\"afterLog\" class=\"cn.com.codingce.log.AfterLog\"/&gt; &lt;!--方式一: 使用Spring API接口--&gt; &lt;!--配置aop: 需要导入aop的约束--&gt;&lt;!-- &lt;aop:config&gt;--&gt;&lt;!-- &amp;lt;!&amp;ndash;切入点：expression：表达式 execution(要执行的位置)&amp;ndash;&amp;gt;--&gt;&lt;!-- &lt;aop:pointcut id=\"pointcut\" expression=\"execution(* cn.com.codingce.service.UserServiceImpl.*(..))\"/&gt;--&gt;&lt;!-- &amp;lt;!&amp;ndash;执行环绕增加!&amp;ndash;&amp;gt;--&gt;&lt;!-- &lt;aop:advisor advice-ref=\"log\" pointcut-ref=\"pointcut\"/&gt;--&gt;&lt;!-- &lt;aop:advisor advice-ref=\"afterLog\" pointcut-ref=\"pointcut\"/&gt;--&gt;&lt;!-- &lt;/aop:config&gt;--&gt; &lt;!--方式二： 自定义类--&gt; &lt;bean id=\"diy\" class=\"cn.com.codingce.diy.DiyPointCut\"/&gt; &lt;aop:config&gt; &lt;!--自定义切面, ref引用的类--&gt; &lt;aop:aspect ref=\"diy\"&gt; &lt;!--切入点--&gt; &lt;aop:pointcut id=\"point\" expression=\"execution(* cn.com.codingce.service.UserServiceImpl.*(..))\"/&gt; &lt;!--通知--&gt; &lt;aop:before method=\"before\" pointcut-ref=\"point\"/&gt; &lt;aop:after method=\"after\" pointcut-ref=\"point\"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 1234567@Testpublic void Test() &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); //动态代理是接口 UserService userService = context.getBean(\"userService\", UserService.class); userService.add();&#125; 第三种注解实现 AnnotationPointCut 123456789101112131415161718192021222324252627//使用注解方式实现AOP@Aspect //标注这个类是一个切面public class AnnotationPointCut &#123; @Before(\"execution(* cn.com.codingce.service.UserServiceImpl.*(..))\") public void before() &#123; System.out.println(\"==============方法执行前===============\"); &#125; @After(\"execution(* cn.com.codingce.service.UserServiceImpl.*(..))\") public void after() &#123; System.out.println(\"===============方法执行后===============\"); &#125; //在环绕增强中，我们可以定一个参数, 代表我们要处理切入的点 @Around(\"execution(* cn.com.codingce.service.UserServiceImpl.*(..))\") public void around(ProceedingJoinPoint jp) throws Throwable &#123; System.out.println(\"环绕前\"); //执行方法 Object proceed = jp.proceed(); System.out.println(\"环绕后\"); Signature signature = jp.getSignature();//获得签名 System.out.println(\"signature\" + signature); &#125;&#125; XML 12345 &lt;!--方式三--&gt; &lt;bean id=\"annotationpointcut\" class=\"cn.com.codingce.diy.AnnotationPointCut\"/&gt; &lt;!--开启注解 JDK(默认 proxy-target-class=\"false\") cglib (proxy-target-class=\"true\") 当然结果没有任何区别--&gt;&lt;!-- &lt;aop:aspectj-autoproxy proxy-target-class=\"false\"/&gt; --&gt; &lt;aop:aspectj-autoproxy proxy-target-class=\"false\"/&gt;","categories":[{"name":"Spring","slug":"Spring","permalink":"http://i.codingce.com.cn/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://i.codingce.com.cn/tags/Spring/"}]},{"title":"Bean的自动装配与注解开发","slug":"Bean的自动装配","date":"2020-07-22T04:13:24.000Z","updated":"2020-12-13T04:41:40.422Z","comments":true,"path":"2020/07/22/Bean的自动装配/","link":"","permalink":"http://i.codingce.com.cn/2020/07/22/Bean%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/","excerpt":"","text":"Bean的自动装配 自动装配是Spring满足Bean依赖的一种方式 Spring会在上下文自动寻找, 并且自动给bean装配属性 在Spring中有三种装配的方式 在xml中显示的配置 在Java中显示配置 隐式的自动配置bean【重要】 测试 搭建环境成功 ： 一个人有两个宠物 ByName自动装配 1234567891011 &lt;bean id=\"cat\" class=\"cn.com.codingce.pojo.Cat\"/&gt; &lt;bean id=\"dog\" class=\"cn.com.codingce.pojo.Dog\"/&gt;&lt;!-- byName：会自动在容器上下文查找, 和自己对象set方法后面的值对应的beanid byType：会自动在容器上下文查找, 和自己对象属性相同的beanid --&gt; &lt;bean id=\"people\" class=\"cn.com.codingce.pojo.People\" autowire=\"byName\"&gt; &lt;property name=\"name\" value=\"掌上编程\"/&gt;&lt;!-- &lt;property name=\"dog\" ref=\"dog\"/&gt;--&gt;&lt;!-- &lt;property name=\"cat\" ref=\"cat\"/&gt;--&gt; &lt;/bean&gt; ByType自动装配 1234567891011 &lt;bean id=\"cat\" class=\"cn.com.codingce.pojo.Cat\"/&gt; &lt;bean id=\"dog\" class=\"cn.com.codingce.pojo.Dog\"/&gt;&lt;!-- byName：会自动在容器上下文查找, 和自己对象set方法后面的值对应的beanid byType：会自动在容器上下文查找, 和自己对象属性相同的beanid --&gt; &lt;bean id=\"people\" class=\"cn.com.codingce.pojo.People\" autowire=\"byType\"&gt; &lt;property name=\"name\" value=\"掌上编程\"/&gt;&lt;!-- &lt;property name=\"dog\" ref=\"dog\"/&gt;--&gt;&lt;!-- &lt;property name=\"cat\" ref=\"cat\"/&gt;--&gt; &lt;/bean&gt; 小结 byName的时候, 需要保证所有bean的id唯一, 并且这个bean需要和自动注入的属性的set方法的值一致 byType的时候, 需要保证所有class的id唯一, 并且这个bean需要和自动注入的属性的类型一样 使用注解实现自动装配 JDK1.5支持注解，Spring2.5就支持注解了 The introduction of annotation-based configuration raised the question of whether this approach is “better” than XML 要用注解须知 导入约束 context 配置注解的支持context:annotation-config/ 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;context:annoation-config/&gt;&lt;/beans&gt; @Autowired 直接使用在属性上即可! 也可以在set方式上的使用 使用Autowired我们就可以不用使用Set方法了, 前提是你这个自动装配属性在IOC(Spring)容器中存在, 且符合名字byname 科普: 1@Nullable: 字段标记了这个注解, 说明这个字段可以为null； 1234public @interface Autowired &#123; boolean required() default true;&#125; 12345678910public class People &#123; //如果显示的定义了Autowried的required属性为false, 说明这个对象可以为Null 否则不许为空 @Autowired private Cat cat; @Autowired private Dog dog; private String name;&#125; 如果@Autowired自动装配的环境比较复杂, 自动装配无法通过一个注解【@Autowired】完成的时候，我们可以使用@Qualifier(value=“dog22”) 去配合@Autowired的使用 Resource注解 1234567public class People &#123; @Resource private Cat cat; @Resource private Dog dog; private String name;&#125; 小结: @Resource与@Autowired的区别 都是用来自动装配, 都可以放在属性字段上 @Autowired是通过byType的方式实现, 而且必须要求这个对象存在! @Resource默认通过byName的方式实现, 如果找不到名字, 则通过byType实现, 如果两个都找不到的情况下就报错 执行顺序不同: @Autowired通过btType的方式实现。@Resource默认通过byName的方式来实现 使用注解开发 bean 123注解说明@Component: 组件放在类名上, 说明这个类被Spring管理了, 就是Bean@Value: 相当于等价&lt;property name=\"name\" value=\"掌上编程\" /&gt; 属性如何注入 1234567@Componentpublic class User &#123; @Value(\"掌上编程\") public String name;&#125; 衍生的注解 @Componment有几个衍生的注解, 我们在Web开发中, 会按照mvc三层架构分层 dao【@Repository】 service【@Service】 controller【@Controller】 这四个注解功能都是一样的, 都是代表将某个类注册到Spring, 装配Bean 作用域 1234567891011@Component@Scope(\"prototype\")public class User &#123; @Value(\"掌上编程\") public String name; @Value(\"掌上编程\") public void setName(String name) &#123; this.name = name; &#125;&#125; 小结: xml与注解 xml更加万能, 适用于任何场合! 维护简单方便 注解不是自己的类使用不了, 维护相对复杂！ xml与注解最佳实践 xml用来管理bean; 注解只负责完成属性的注入. 我们在使用过程中, 只需要注意一个问题: 必须让注解生效, 就需要开启注解的支持 1234&lt;!--指定要扫描的宝, 这个包下的注解就会生效--&gt;&lt;context:component-scan base-package=\"cn.com.codingce\"/&gt;&lt;!--开启注解的支持--&gt;&lt;context:annotation-config/&gt; 使用Java的方式配置Spring 我们现在要完全不使用Spring的xml的配置了, 全权交给Java来做 JavaConfig是Spring的一个子项目, 在Spring4之后, 它成为了一个核心的功能. 实体类 123456789101112131415161718192021222324252627282930313233package cn.com.codingce.pojo;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;//这里这个注解的意思, 就是说明这个类被Spring接管了, 注册到了容器中@Componentpublic class User &#123; private String name; public User() &#123; &#125; public User(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; @Value(\"掌上编程\")//属性注入值 public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"name='\" + name + '\\'' + '&#125;'; &#125;&#125; 配置文件 123456789101112131415161718192021222324252627package cn.com.codingce.config;import cn.com.codingce.pojo.User;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Import;/** * @Configuration加上这个注解就相当于beans * @author xzMa *///这个也会被Spring托管, 注册到容器中, 因为它本来就是个@Component, @Configuration代表一个配置类, 就和我们之前看到的beans.xml@Configuration@ComponentScan(\"cn.com.codingce.pojo\")@Import(ZeConfig2.class)public class ZeConfig &#123; //注册一个bean, 就相当于我们之前写的一个bean标签 //这个方法的名字, 就相当于bean标签中的id属性 //这个方法返回值, 就相当于bean标签中的class属性 @Bean public User getUser() &#123; return new User();//就是返回要注入到bean的对象! &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"http://i.codingce.com.cn/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://i.codingce.com.cn/tags/Spring/"}]},{"title":"Spring依赖注入","slug":"bSpring依赖注入","date":"2020-07-21T01:09:11.000Z","updated":"2020-12-13T04:41:40.438Z","comments":true,"path":"2020/07/21/bSpring依赖注入/","link":"","permalink":"http://i.codingce.com.cn/2020/07/21/bSpring%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/","excerpt":"","text":"依赖注入 构造器注入 翻看上文 Set方式注入【重点】 依赖注入: Set注入 依赖: bean对象的创建依赖于容器 注入: bean对象中所有属性, 由容器来注入 【环境搭建】 复杂类型 真实测试对象 1234567891011public class Student &#123; private String name; private Address address; private String[] books; private List&lt;String&gt; hobbys; private Map&lt;String, String&gt; card; private Set&lt;String&gt; games; private String wife; private Properties info;&#125; 12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"student\" class=\"cn.com.codingce.pojo.Student\"&gt; &lt;!--普通值注入--&gt; &lt;property name=\"name\" value=\"掌上编程\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 测试类 123456@Testpublic void Test() &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); Student student = (Student) context.getBean(\"student\"); System.out.println(student.getName());;&#125; 拓展方式 p 命名空间注入 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:c=\"http://www.springframework.org/schema/c\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;import resource=\"userBean.xml\"/&gt; &lt;!--xmlns:p=\"http://www.springframework.org/schema/p\" p 命名空间注入 可以直接注入属性的值 property标签操作--&gt; &lt;bean id=\"user\" class=\"cn.com.codingce.pojo.User\" p:age=\"12\" p:name=\"掌上编程\"&gt; &lt;/bean&gt; &lt;!--xmlns:c=\"http://www.springframework.org/schema/c\" c命名空间, 通过构造器注入: construct-args--&gt; &lt;bean id=\"user2\" class=\"cn.com.codingce.pojo.User\" c:age=\"18\" c:name=\"人间事Life\"/&gt;&lt;/beans&gt; 12345678@Testpublic void Test2() &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); //这样就不用强转 User user = context.getBean(\"user\", User.class); User user2 = context.getBean(\"user2\", User.class); System.out.println(user.toString());&#125; c命名空间 12&lt;!--xmlns:c=\"http://www.springframework.org/schema/c\" c命名空间, 通过构造器注入: construct-args--&gt;&lt;bean id=\"user2\" class=\"cn.com.codingce.pojo.User\" c:age=\"18\" c:name=\"人间事Life\"/&gt; 12345678@Testpublic void Test2() &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); //这样就不用强转 User user = context.getBean(\"user\", User.class); User user2 = context.getBean(\"user2\", User.class); System.out.println(user2.toString());&#125; 注意一点: p命名空间和c命名空间不能直接使用需要导入 xml约束 xmlns:p=“http://www.springframework.org/schema/p” xmlns:c=“http://www.springframework.org/schema/c” bean的作用域 单例模式(Spring默认机制) 1&lt;bean id=\"user2\" class=\"cn.com.codingce.pojo.User\" c:age=\"18\" c:name=\"人间事Life\" scope=\"singleton\"/&gt; 原型模式：每次从容器get的时候, 都会产生一个新对象 1&lt;bean id=\"user2\" class=\"cn.com.codingce.pojo.User\" c:age=\"18\" c:name=\"人间事Life\" scope=\"prototype\"/&gt; 其余的request、session、application这些只能存在于web开发中使用到!","categories":[{"name":"Spring","slug":"Spring","permalink":"http://i.codingce.com.cn/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://i.codingce.com.cn/tags/Spring/"}]},{"title":"Spring配置","slug":"aSpring配置","date":"2020-07-21T00:31:41.000Z","updated":"2020-12-13T04:41:40.438Z","comments":true,"path":"2020/07/21/aSpring配置/","link":"","permalink":"http://i.codingce.com.cn/2020/07/21/aSpring%E9%85%8D%E7%BD%AE/","excerpt":"","text":"Spring配置 别名 12&lt;!--别名,别名区分大小写, 我们也可以使用别名获取到这个对象--&gt;&lt;alias name=\"user\" alias=\"aliasUser\"/&gt; 12345public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); User user = (User) context.getBean(\"aliasUser\"); System.out.println(user.toString()); &#125; Bean配置 12345678&lt;!-- id: bean 唯一标识符, 也就是相当于我们学的对象名 class: bean对象所对应的类型 name: 也是别名, 而且name更高级 可以取多个别名name=\"user2, u2\" name=\"user2\"--&gt;&lt;bean id=\"userT\" class=\"cn.com.codingce.pojo.User\" name=\"user2, u2\"&gt; &lt;property name=\"name\" value=\"掌上开源\"/&gt;&lt;/bean&gt; 12345public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); User user = (User) context.getBean(\"u2\"); System.out.println(user.toString());&#125; import 这个import, 一般用于团队开发使用, 它可以将多个配置文件, 导入合并为一个 假设现在项目有多个人开发, 这三个人复制不同的类开发, 不同的类需要注册在不同的bean中, 我们可以利用import将所有人的beans.xml合并为一个总的, 使用的时候直接使用总的 张三 李四 王五 applicationContext.xml 123&lt;import resource=\"beans.xml\"/&gt;&lt;import resource=\"beans2.xml\"/&gt;&lt;import resource=\"beans3.xml\"/&gt;","categories":[{"name":"Spring","slug":"Spring","permalink":"http://i.codingce.com.cn/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://i.codingce.com.cn/tags/Spring/"}]},{"title":"快速上手Spring","slug":"快速上手Spring","date":"2020-07-20T00:56:32.000Z","updated":"2020-12-13T04:41:40.438Z","comments":true,"path":"2020/07/20/快速上手Spring/","link":"","permalink":"http://i.codingce.com.cn/2020/07/20/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8BSpring/","excerpt":"","text":"导入Jar包 注 : spring 需要导入commons-logging进行日志记录 . 我们利用maven,他会自动下载对应的依赖项 . 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.10.RELEASE&lt;/version&gt;&lt;/dependency&gt; 编写代码 编写一个Hello实体类 1234567891011121314151617181920212223242526public class Hello &#123; private String name; public Hello() &#123; &#125; public Hello(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return \"Hello&#123;\" + \"name='\" + name + '\\'' + '&#125;'; &#125;&#125; 编写我们的spring文件,这里我们命名为beans.xml 123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!--使用Spring来创建对象, 在Spring中这些都称为Bean 类型 变量名 = new 类型() Hello hello = new Hello(); id = 变量名 class = new 的对象 property 相当于给对象中的属性设置一个值 根据set方法注入 --&gt; &lt;bean id=\"hello\" class=\"cn.com.codingce.pojo.Hello\"&gt; &lt;property name=\"name\" value=\"Spring\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 测试 123456789public class MyTest &#123; public static void main(String[] args) &#123; //获取Spring上下文对象 ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); //我们的对象现在都在Spring中管理了, 我们要使用, 直接去里面取出来 Hello hello = (Hello)context.getBean(\"hello\"); System.out.println(hello.toString()); &#125;&#125; 思考 Hello 对象是谁创建的 ? 【hello 对象是由Spring创建的Hello 对象的属性是怎么设置的 ? hello 对象的属性是由Spring容器设置的 这个过程就叫控制反转 : 控制 : 谁来控制对象的创建,传统应用程序的对象是由程序本身控制创建的,使用Spring后,对象是由Spring来创建的 反转 : 程序本身不创建对象,而变成被动的接收对象 . 依赖注入 : 就是利用set方法来进行注入的. IOC是一种编程思想，由主动的编程变成被动的接收 可以通过newClassPathXmlApplicationContext去浏览一下底层源码 修改案例一 在案例一中， 新增一个Spring配置文件beans.xml 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!--使用Spring来创建对象, 在Spring中这些都称为Bean 类型 变量名 = new 类型() Hello hello = new Hello(); id = 变量名 class = new 的对象 property 相当于给对象中的属性设置一个值 根据set方法注入 --&gt; &lt;bean id=\"mysqlImpl\" class=\"cn.com.codingce.dao.UserDaoMysqlImpl\" /&gt; &lt;bean id=\"oracleImpl\" class=\"cn.com.codingce.dao.UserDaoOracleImpl\" /&gt; &lt;bean id=\"UserServiceImpl\" class=\"cn.com.codingce.service.UserServiceImpl\"&gt; &lt;!--ref 引用Spring容器中创建好的对象 value: 具体的值基本数据类型 --&gt; &lt;property name=\"userDao\" ref=\"mysqlImpl\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 测试 12345678910111213141516171819public class MyTest &#123;// public static void main(String[] args) &#123;// //用户实际调用的是业务层, dao层他们不需要接触// UserService userService = new UserServiceImpl();// ((UserServiceImpl)userService).setUserDao(new UserDaoMysqlImpl());// userService.getUser();// &#125; public static void main(String[] args) &#123; //获取ApplicationContext 拿到Spring的容器 ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); //容器在手 需要什么就直接get UserServiceImpl userServiceImpl = (UserServiceImpl) context.getBean(\"UserServiceImpl\"); userServiceImpl.getUser(); &#125;&#125; 到了现在,我们彻底不用再程序中去改动了,要实现不同的操作,只需要在xml配置文件中进行修改,所谓的IoC,一句话搞定:对象由Spring 来创建,管理,装配! IOC创建对象方式(构造器) 通过无参构造方法来创建 User.java 123456789101112131415161718192021222324252627public class User &#123; private String name; public User() &#123; System.out.println(\"走的无参\"); &#125; public User(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"name='\" + name + '\\'' + '&#125;'; &#125;&#125; beans.xml 12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"user\" class=\"cn.com.codingce.pojo.User\"&gt; &lt;property name=\"name\" value=\"掌上编程\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 测试类 12345public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); User user = (User) context.getBean(\"user\"); System.out.println(user.toString());&#125; 结果可以发现，在调用toString方法之前，User对象已经通过无参构造初始化了! 通过有参构造方法来创建 下标赋值 1234&lt;!--第一种下标赋值--&gt;&lt;bean id=\"user\" class=\"cn.com.codingce.pojo.User\"&gt; &lt;constructor-arg index=\"0\" value=\"掌上编程\"/&gt;&lt;/bean&gt; 参数类型 1234&lt;!--第二种参数类型 不建议使用 假设两个参数都是String--&gt;&lt;bean id=\"user\" class=\"cn.com.codingce.pojo.User\"&gt; &lt;constructor-arg type=\"java.lang.String\" value=\"掌上编程\"/&gt;&lt;/bean&gt; 参数名来设置 1234&lt;!--第三种通过参数名来设置--&gt;&lt;bean id=\"user\" class=\"cn.com.codingce.pojo.User\"&gt; &lt;constructor-arg name=\"name\" value=\"掌上编程\"/&gt;&lt;/bean&gt; 结论：在配置文件加载的时候。其中管理的对象都已经初始化了！","categories":[{"name":"Spring","slug":"Spring","permalink":"http://i.codingce.com.cn/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://i.codingce.com.cn/tags/Spring/"}]},{"title":"Spring概述及IOC理论推导","slug":"Spring概述及IOC理论推导","date":"2020-07-17T12:51:07.000Z","updated":"2020-12-13T04:41:40.438Z","comments":true,"path":"2020/07/17/Spring概述及IOC理论推导/","link":"","permalink":"http://i.codingce.com.cn/2020/07/17/Spring%E6%A6%82%E8%BF%B0%E5%8F%8AIOC%E7%90%86%E8%AE%BA%E6%8E%A8%E5%AF%BC/","excerpt":"","text":"简介 Spring : 春天 —&gt;给软件行业带来了春天 2002年,Rod Jahnson首次推出了Spring框架雏形interface21框架. 2004年3月24日,Spring框架以interface21框架为基础,经过重新设计,发布了1.0正式版. 很难想象Rod Johnson的学历 , 他是悉尼大学的博士,然而他的专业不是计算机,而是音乐学. Spring理念 : 使现有技术更加实用 . 本身就是一个大杂烩 , 整合现有的框架技术 官网 : http://spring.io/ 官方下载地址 : https://repo.spring.io/libs-release-local/org/springframework/spring/ GitHub : https://github.com/spring-projects 优点 Spring是一个开源免费的框架 , 容器 . Spring是一个轻量级的框架 , 非侵入式的 . 控制反转 IoC , 面向切面 Aop 对事物的支持 , 对框架的支持 一句话概括： Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器（框架）. 组成 Spring 框架是一个分层架构,由 7 个定义良好的模块组成.Spring 模块构建在核心容器之上,核心容器定义了创建、配置和管理 bean 的方式 . 组成 Spring 框架的每个模块（或组件）都可以单独存在,或者与其他一个或多个模块联合实现.每个模块的功能如下： 核心容器：核心容器提供 Spring 框架的基本功能.核心容器的主要组件是 BeanFactory,它是工厂模式的实现.BeanFactory 使用控制反转（IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开. Spring 上下文：Spring 上下文是一个配置文件,向 Spring 框架提供上下文信息.Spring 上下文包括企业服务,例如 JNDI、EJB、电子邮件、国际化、校验和调度功能. Spring AOP：通过配置管理特性,Spring AOP 模块直接将面向切面的编程功能 , 集成到了 Spring 框架中.所以,可以很容易地使 Spring 框架管理任何支持 AOP的对象.Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务.通过使用 Spring AOP,不用依赖组件,就可以将声明性事务管理集成到应用程序中. Spring DAO：JDBC DAO 抽象层提供了有意义的异常层次结构,可用该结构来管理异常处理和不同数据库供应商抛出的错误消息.异常层次结构简化了错误处理,并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）.Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构. Spring ORM：Spring 框架插入了若干个 ORM 框架,从而提供了 ORM 的对象关系工具,其中包括 JDO、Hibernate 和 iBatis SQL Map.所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构. Spring Web 模块：Web 上下文模块建立在应用程序上下文模块之上,为基于 Web 的应用程序提供了上下文.所以,Spring 框架支持与 Jakarta Struts 的集成.Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作. Spring MVC 框架：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现.通过策略接口,MVC 框架变成为高度可配置的,MVC 容纳了大量视图技术,其中包括 JSP、Velocity、Tiles、iText 和 POI. 拓展 Spring Boot与Spring Cloud Spring Boot 是 Spring 的一套快速配置脚手架,可以基于Spring Boot 快速开发单个微服务; Spring Cloud是基于Spring Boot实现的； Spring Boot专注于快速、方便集成的单个微服务个体,Spring Cloud关注全局的服务治理框架； Spring Boot使用了约束优于配置的理念,很多集成方案已经帮你选择好了,能不配置就不配置 , Spring Cloud很大的一部分是基于Spring Boot来实现,Spring Boot可以离开Spring Cloud独立使用开发项目,但是Spring Cloud离不开Spring Boot,属于依赖的关系. SpringBoot在SpringClound中起到了承上启下的作用,如果你要学习SpringCloud必须要学习SpringBoot. IoC基础 Dao 123public interface UserDao &#123; void getUser();&#125; 12345public class UserDaoImpl implements UserDao &#123; public void getUser() &#123; System.out.println(\"默认获取用户数据\"); &#125;&#125; 12345public class UserDaoMysqlImpl implements UserDao &#123; public void getUser() &#123; System.out.println(\"Mysql获取用户数据\"); &#125;&#125; 12345public class UserDaoOracleImpl implements UserDao &#123; public void getUser() &#123; System.out.println(\"Oracle获取数据\"); &#125;&#125; 123public interface UserDao &#123; void getUser();&#125; Service 123public interface UserService &#123; void getUser();&#125; 12345678910111213141516171819202122public class UserServiceImpl implements UserService &#123;/* private UserDao userDao = new UserDaoImpl(); public void getUser() &#123; userDao.getUser(); &#125;*/ private UserDao userDao; public void getUser() &#123; userDao.getUser(); &#125; public UserDao getUserDao() &#123; return userDao; &#125; //利用Set进行动态实现值的注入 public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125;&#125; 之前程序是主动创建对象, 控制权在程序猿手上! 使用了set注入后, 程序不在具有主动性, 而是变成了主动接受对象! 这种思想, 从本质上解决了问题, 我们程序猿不在去管理对象创建了. 系统的耦合性大大降低, 可以更加专注的在业务的实现上 这时IOC的原型. Test 12345678public class MyTest &#123; public static void main(String[] args) &#123; //用户实际调用的是业务层, dao层他们不需要接触 UserService userService = new UserServiceImpl(); ((UserServiceImpl)userService).setUserDao(new UserDaoMysqlImpl()); userService.getUser(); &#125;&#125; IOC本质 控制反转IoC(Inversion of Control),是一种设计思想,DI(依赖注入)是实现IoC的一种方法,也有人认为DI只是IoC的另一种说法.没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中,对象的创建由程序自己控制,控制反转后将对象的创建转移给第三方,个人认为所谓控制反转就是：获得依赖对象的方式反转了. IoC是Spring框架的核心内容.使用多种方式完美的实现了IoC.可以使用XML配置.也可以使用注解.新版本的Spring也可以零配置实现IoC. Spring容器在初始化时先读取配置文件.根据配置文件或元数据创建与组织对象存入容器中.程序使用时再从Ioc容器中取出需要的对象. 采用XML方式配置Bean的时候.Bean的定义信息是和实现分离的.而采用注解的方式可以把两者合为一体.Bean的定义信息直接以注解的形式定义在实现类中.从而达到了零配置的目的. 控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式.在Spring中实现控制反转的是IoC容器.其实现方法是依赖注入（Dependency Injection,DI）.","categories":[{"name":"Spring","slug":"Spring","permalink":"http://i.codingce.com.cn/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://i.codingce.com.cn/tags/Spring/"}]},{"title":"缓存","slug":"缓存","date":"2020-07-16T23:53:22.000Z","updated":"2020-12-13T04:41:40.453Z","comments":true,"path":"2020/07/17/缓存/","link":"","permalink":"http://i.codingce.com.cn/2020/07/17/%E7%BC%93%E5%AD%98/","excerpt":"","text":"简介 查询: 连接数据库 耗资源 一次查询的结果, 给他暂时存在一个可以直接存放的地方!–&gt;内存: 缓存 我们再次查询相同数据的时候, 直接走缓存, 就不走数据库了 什么是缓存 [ Cache ]？ 存在内存中的临时数据。 将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。 为什么使用缓存？ 减少和数据库的交互次数，减少系统开销，提高系统效率。 什么样的数据能使用缓存？ 经常查询并且不经常改变的数据。 Mybatis缓存 MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率。 MyBatis系统中默认定义了两级缓存：一级缓存和二级缓存 默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存） 二级缓存需要手动开启和配置，他是基于namespace级别的缓存。 -为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存 一级缓存 一级缓存也叫本地缓存： 与数据库同一次会话期间查询到的数据会放在本地缓存中。 以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库； 测试 在mybatis中加入日志，方便测试结果 编写接口方法 12//根据id查询用户User queryUserById(@Param(\"id\") int id); 接口对应的Mapper文件 123&lt;select id=\"queryUserById\" resultType=\"user\"&gt; select * from user where id = #&#123;id&#125;&lt;/select&gt; 测试 12345678910111213141516@Testpublic void testQueryUserById()&#123; SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user = mapper.queryUserById(1); System.out.println(user); User user2 = mapper.queryUs一级缓存失效的四种情况erById(1); System.out.println(user2); System.out.println(user==use) 一级缓存是SqlSession级别的缓存，是一直开启的，我们关闭不了它； 一级缓存失效情况：没有使用到当前的一级缓存，效果就是，还需要再向数据库中发起一次查询请求！r2); session.close();&#125; 一级缓存失效的四种情况 一级缓存是SqlSession级别的缓存，是一直开启的，我们关闭不了它； 一级缓存失效情况：没有使用到当前的一级缓存，效果就是，还需要再向数据库中发起一次查询请求！ sqlSession不同 12345678910111213141516171819@Testpublic void testQueryUserById()&#123; SqlSession session = MybatisUtils.getSession(); SqlSession session2 = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); UserMapper mapper2 = session2.getMapper(UserMapper.class); User user = mapper.queryUserById(1); System.out.println(user); User user2 = mapper2.queryUserById(1); System.out.println(user2); System.out.println(user==user2); session.close(); session2.close();&#125; 观察结果：发现发送了两条SQL语句！ 结论：每个sqlSession中的缓存相互独立 sqlSession相同，查询条件不同 123456789101112131415@Testpublic void testQueryUserById()&#123; SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); UserMapper mapper2 = session.getMapper(UserMapper.class); User user = mapper.queryUserById(1); System.out.println(user); User user2 = mapper2.queryUserById(2); System.out.println(user2); System.out.println(user==user2); session.close();&#125; 观察结果：发现发送了两条SQL语句！很正常的理解 结论：当前缓存中，不存在这个数据 sqlSession相同，两次查询之间执行了增删改操作！ 增加方法 12//修改用户int updateUser(Map map); 编写SQL 123&lt;update id=\"updateUser\" parameterType=\"map\"&gt; update user set name = #&#123;name&#125; where id = #&#123;id&#125;&lt;/update&gt; 测试 123456789101112131415161718@Testpublic void testQueryUserById()&#123; SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user = mapper.queryUserById(1); System.out.println(user); HashMap map = new HashMap(); map.put(\"name\",\"kuangshen\"); map.put(\"id\",4); mapper.updateUser(map); User user2 = mapper.queryUserById(1); System.out.println(user2); System.out.println(user==user2); session.close();&#125; 观察结果：查询在中间执行了增删改操作后，重新执行了 结论：因为增删改操作可能会对当前数据产生影响 sqlSession相同，手动清除一级缓存 123456789101112131415@Testpublic void testQueryUserById()&#123; SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user = mapper.queryUserById(1); System.out.println(user); session.clearCache();//手动清除缓存 User user2 = mapper.queryUserById(1); System.out.println(user2); System.out.println(user==user2); session.close();&#125; 一级缓存就是一个map 二级缓存 二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存 基于namespace级别的缓存，一个名称空间，对应一个二级缓存； 工作机制 一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中； 如果当前会话关闭了，这个会话对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中； 新的会话查询信息，就可以从二级缓存中获取内容； 不同的mapper查出的数据会放在自己对应的缓存（map）中； 使用步骤 开启全局缓存 【mybatis-config.xml】 1&lt;setting name=\"cacheEnabled\" value=\"true\"/&gt; 去每个mapper.xml中配置使用二级缓存，这个配置非常简单；【xxxMapper.xml】 123456789&lt;cache/&gt;官方示例=====&gt;查看官方文档&lt;cacheeviction=\"FIFO\"flushInterval=\"60000\"size=\"512\"readOnly=\"true\"/&gt;这个更高级的配置创建了一个 FIFO 缓存，每隔 60 秒刷新，最多可以存储结果对象或列表的 512 个引用，而且返回的对象被认为是只读的，因此对它们进行修改可能会在不同线程中的调用者产生冲突。 代码测试 所有的实体类先实现序列化接口 测试代码 123456789101112131415161718@Testpublic void testQueryUserById()&#123; SqlSession session = MybatisUtils.getSession(); SqlSession session2 = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); UserMapper mapper2 = session2.getMapper(UserMapper.class); User user = mapper.queryUserById(1); System.out.println(user); session.close(); User user2 = mapper2.queryUserById(1); System.out.println(user2); System.out.println(user==user2); session2.close();&#125; 结论 只要开启了二级缓存，我们在同一个Mapper中的查询，可以在二级缓存中拿到数据 查出的数据都会被默认先放在一级缓存中 只有会话提交或者关闭以后，一级缓存中的数据才会转到二级缓存中 缓存原理图 EhCache 第三方缓存实现–EhCache: 查看百度百科 Ehcache是一种广泛使用的java分布式缓存，用于通用缓存； 要在应用程序中使用Ehcache，需要引入依赖的jar包 123456&lt;!-- https://mvnrepository.com/artifact/org.mybatis.caches/mybatis-ehcache --&gt;&lt;dependency&gt;&lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt;&lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt;&lt;version&gt;1.1.0&lt;/version&gt;&lt;/dependency&gt;` 在mapper.xml中使用对应的缓存即可 123&lt;mapper namespace = “org.acme.FooMapper” &gt;&lt;cache type = “org.mybatis.caches.ehcache.EhcacheCache” /&gt;&lt;/mapper&gt; 编写ehcache.xml文件，如果在加载时未找到/ehcache.xml资源或出现问题，则将使用默认配置。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;ehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"http://ehcache.org/ehcache.xsd\" updateCheck=\"false\"&gt;&lt;!-- diskStore：为缓存路径，ehcache分为内存和磁盘两级，此属性定义磁盘的缓存位置。参数解释如下： user.home – 用户主目录 user.dir – 用户当前工作目录 java.io.tmpdir – 默认临时文件路径 --&gt;&lt;diskStore path=\"./tmpdir/Tmp_EhCache\"/&gt;&lt;defaultCache eternal=\"false\" maxElementsInMemory=\"10000\" overflowToDisk=\"false\" diskPersistent=\"false\" timeToIdleSeconds=\"1800\" timeToLiveSeconds=\"259200\" memoryStoreEvictionPolicy=\"LRU\"/&gt;&lt;cache name=\"cloud_user\" eternal=\"false\" maxElementsInMemory=\"5000\" overflowToDisk=\"false\" diskPersistent=\"false\" timeToIdleSeconds=\"1800\" timeToLiveSeconds=\"1800\" memoryStoreEvictionPolicy=\"LRU\"/&gt;&lt;!-- defaultCache：默认缓存策略，当ehcache找不到定义的缓存时，则使用这个缓存策略。只能定义一个。 --&gt;&lt;!-- name:缓存名称。 maxElementsInMemory:缓存最大数目 maxElementsOnDisk：硬盘最大缓存个数。 eternal:对象是否永久有效，一但设置了，timeout将不起作用。 overflowToDisk:是否保存到磁盘，当系统当机时 timeToIdleSeconds:设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。 timeToLiveSeconds:设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。 diskPersistent：是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is false. diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。 diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。 memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。 clearOnFlush：内存数量最大时是否清除。 memoryStoreEvictionPolicy:可选策略有：LRU（最近最少使用，默认策略）、FIFO（先进先出）、LFU（最少访问次数）。 FIFO，first in first out，这个是大家最熟的，先进先出。 LFU， Less Frequently Used，就是上面例子中使用的策略，直白一点就是讲一直以来最少被使用的。如上面所讲，缓存的元素有一个hit属性，hit值最小的将会被清出缓存。 LRU，Least Recently Used，最近最少使用的，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存。--&gt;&lt;/ehcache&gt; 合理的使用缓存，可以让我们程序的性能大大提升！","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://i.codingce.com.cn/categories/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://i.codingce.com.cn/tags/MyBatis/"}]},{"title":"硕士研究生学校名单","slug":"硕士研究生学校名单","date":"2020-07-16T02:15:30.000Z","updated":"2021-01-06T11:04:01.680Z","comments":true,"path":"2020/07/16/硕士研究生学校名单/","link":"","permalink":"http://i.codingce.com.cn/2020/07/16/%E7%A1%95%E5%A3%AB%E7%A0%94%E7%A9%B6%E7%94%9F%E5%AD%A6%E6%A0%A1%E5%90%8D%E5%8D%95/","excerpt":"","text":"数据来源: 研招网 https://yz.chsi.com.cn/ 计算机考研学科最强十所211大学 10013北京邮电大学 10004北京交通大学 10701西安电子科技大学 10005北京工业大学 10008北京科技大学 10217哈尔滨工程大学 10287南京航空航天大学 10288南京理工大学 10359合肥工业大学 10613西南交通大学 天津 专业学位 (0854电子信息) 10055南开大学 10056天津大学 10057天津科技大学 学术学位 (07理学) (0775计算机科学与技术) 天津师范大学 (08工学) (0812计算机科学与技术) 天津工业大学 中国民航大学 天津理工大学 天津财经大学 天津城建大学 山西 (08工学) (0812计算机科学与技术) 太原理工大学 关注下方公众号, 回复1024进入技术交流群","categories":[{"name":"考研","slug":"考研","permalink":"http://i.codingce.com.cn/categories/%E8%80%83%E7%A0%94/"}],"tags":[{"name":"考研","slug":"考研","permalink":"http://i.codingce.com.cn/tags/%E8%80%83%E7%A0%94/"}]},{"title":"Mybatis多对一与一对多、动态SQL","slug":"多对一与一对多","date":"2020-07-15T01:36:59.000Z","updated":"2020-12-13T04:41:40.438Z","comments":true,"path":"2020/07/15/多对一与一对多/","link":"","permalink":"http://i.codingce.com.cn/2020/07/15/%E5%A4%9A%E5%AF%B9%E4%B8%80%E4%B8%8E%E4%B8%80%E5%AF%B9%E5%A4%9A/","excerpt":"","text":"多对一处理 测试环境搭建 导入lombok 新建实体类Student、Teacher 建立Mapper接口 建立Mapper.xml文件 在核心配置文件中绑定注册我们的Mapper接口或者文件![方式很多, 随心选] 测试查询能否成功 按照查询嵌套处理 123456789101112131415161718192021222324252627&lt;!-- 思路: 1. 从学生表和老师表中查出学生id，学生姓名，老师姓名 2. 对查询出来的操作做结果集映射 1. 集合的话，使用collection！ JavaType和ofType都是用来指定对象类型的 JavaType是用来指定pojo中属性的类型 ofType指定的是映射到list集合属性中pojo的类型。 --&gt;&lt;!-- &lt;select id=\"getStudents\" resultType=\"student\"&gt;--&gt;&lt;!-- select * from student--&gt;&lt;!-- &lt;/select&gt;--&gt; &lt;select id=\"getStudent\" resultMap=\"StudentTeacher\"&gt; select * from student &lt;/select&gt; &lt;resultMap id=\"StudentTeacher\" type=\"Student\"&gt;&lt;!-- &lt;result property=\"id\" column=\"id\" /&gt;--&gt;&lt;!-- &lt;result property=\"name\" column=\"name\" /&gt;--&gt; &lt;!--复杂的属性:,我们需要单独处理 对象: association 集合: collection --&gt; &lt;association property=\"teacher\" column=\"tid\" javaType=\"Teacher\" select=\"getTeacher\"/&gt; &lt;/resultMap&gt; &lt;select id=\"getTeacher\" resultType=\"Teacher\"&gt; select * from teacher where id = #&#123;id&#125; &lt;/select&gt; 按照结果嵌套处理 12345678910111213&lt;!--按照结果嵌套处理--&gt;&lt;select id=\"getStudent2\" resultMap=\"StudentTeacher2\"&gt; select s.id sid, s.name sname, t.name tname from student s, teacher t where s.tid = t.id;&lt;/select&gt;&lt;resultMap id=\"StudentTeacher2\" type=\"Student\"&gt; &lt;result property=\"id\" column=\"sid\"/&gt; &lt;result property=\"name\" column=\"sname\"/&gt; &lt;association property=\"teacher\" javaType=\"Teacher\"&gt; &lt;result property=\"name\" column=\"tname\"/&gt; &lt;/association&gt;&lt;/resultMap&gt; 1234567891011@Testpublic void getStudents() &#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); //底层主要应用反射 StudentMapper mapper = sqlSession.getMapper(StudentMapper.class); List&lt;Student&gt; studentList = mapper.getStudent2(); for (Student student : studentList) &#123; System.out.println(student); &#125; sqlSession.close();&#125; 回顾mysql 子查询 联表查询 一对多 比如一个老师拥有多个学生 对于老师而言, 就是一对多关系 环境搭建 实体类 1234567891011121314@Data //GET,SET,ToString，有参，无参构造public class Teacher &#123; private int id; private String name; private List&lt;Student&gt; studentList;&#125;@Datapublic class Student &#123; private int id; private String name; //多个学生可以是同一个老师，即多对一 private int tid;&#125; 按照结果嵌套处理 12345678910111213141516171819&lt;!--按结果嵌套查询--&gt;&lt;select id=\"getTeacher\" resultType=\"Teacher\" resultMap=\"TeacherStudent\"&gt; select s.id sid, s.name sname, t.name tname, t.id tid from student s, teacher t where s.tid = t.id and t.id = #&#123;id&#125;&lt;/select&gt;&lt;resultMap id=\"TeacherStudent\" type=\"Teacher\"&gt; &lt;result property=\"id\" column=\"tid\"/&gt; &lt;result property=\"name\" column=\"tname\"/&gt; &lt;!--复杂的属性,我们需要单独处理 对象: assrciation 集合: collection javaType=\"\" 指定属性的类型! 集合中的泛型信息, 我们使用ofType获取 --&gt; &lt;collection property=\"studentList\" ofType=\"Student\"&gt; &lt;result property=\"id\" column=\"sid\"/&gt; &lt;result property=\"name\" column=\"sname\"/&gt; &lt;result property=\"tid\" column=\"tid\"/&gt; &lt;/collection&gt;&lt;/resultMap&gt; 按照查询嵌套处理 123456789&lt;select id=\"getTeacher2\" resultType=\"Teacher\" resultMap=\"TeacherStudent2\"&gt; select * from teacher where id = #&#123;id&#125;&lt;/select&gt;&lt;resultMap id=\"TeacherStudent2\" type=\"Teacher\"&gt; &lt;collection property=\"studentList\" javaType=\"ArrayList\" ofType=\"Student\" select=\"getStudentByTeacherId\" column=\"id\"/&gt;&lt;/resultMap&gt;&lt;select id=\"getStudentByTeacherId\" resultType=\"Student\"&gt; select * from student where tid = #&#123;tid&#125;&lt;/select&gt; 小结 关联 -association[多对一] 结合 -collection[一对多] javaType &amp; ofType javaType用来指定 ofType用来指定映射到List或者集合中的pojo类型, 泛型中的约束类型! 注意点 保证SQL的可读性, 尽量保证通俗易懂 注意多对一和一对多中, 属性名和字段名问题 如果问题不好观察, 建议使用日志Log4j 动态SQL 什么是动态SQL这一特性:动态SQL就是指根据不同的条件生成不同的SQL 利用动态SQL这一特性可以彻底的 1234ifchoose (when, otherwise)trim (where, set)foreach 搭建环境 导包 编写配置文件 编写实体类 12345678@Datapublic class Blog &#123; private int id; private String title; private String author; private Data createTime; private int views;&#125; 编写实体类对应的Mapper和Mapper.xml文件 if 12345678910111213141516171819202122 &lt;select id=\"queryBlogIf\" parameterType=\"map\" resultType=\"blog\"&gt; select * from blog where 1 = 1 &lt;if test=\"title != null\"&gt; and title = #&#123;title&#125; &lt;/if&gt; &lt;if test=\"author != null\"&gt; and author = #&#123;author&#125; &lt;/if&gt; &lt;/select&gt; &lt;!--(建议采取下面这种)这样也行避免出现 where and author = --&gt; &lt;select id=\"queryBlogIf\" parameterType=\"map\" resultType=\"blog\"&gt; select * from blog &lt;where&gt; &lt;if test=\"title != null\"&gt; and title = #&#123;title&#125; &lt;/if&gt; &lt;if test=\"author != null\"&gt; and author = #&#123;author&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; choose、when、otherwise 它有点像 Java 中的 switch 语句 12345678910111213141516&lt;select id=\"queryBlogChoose\" parameterType=\"map\" resultType=\"blog\"&gt; select * from blog &lt;where&gt; &lt;choose&gt; &lt;when test=\"title != null\"&gt; title = #&#123;title&#125; &lt;/when&gt; &lt;when test=\"author != null\"&gt; and author = #&#123;author&#125; &lt;/when&gt; &lt;otherwise&gt; and views = #&#123;views&#125; &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt;&lt;/select&gt; trim、where、set 1234567891011 &lt;select id=\"queryBlogIf\" parameterType=\"map\" resultType=\"blog\"&gt; select * from blog &lt;where&gt; &lt;if test=\"title != null\"&gt; and title = #&#123;title&#125; &lt;/if&gt; &lt;if test=\"author != null\"&gt; and author = #&#123;author&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 123456789101112&lt;update id=\"updateBlog\" parameterType=\"map\"&gt; update blog &lt;set&gt; &lt;if test=\"title != null\"&gt; title = #&#123;title&#125;, &lt;/if&gt; &lt;if test=\"author != null\"&gt; author = #&#123;author&#125; &lt;/if&gt; &lt;/set&gt; where id = #&#123;id&#125;&lt;/update&gt; 所谓的动态SQL, 本质就是SQL语句, 只是我们可以在SQL层面, 去执行一个逻辑代码 if where set choose when #SQL片段 有的时候, 我们可能会将一些功能的部分抽取出来, 方便复用 使用SQL标签抽取公共部分 12345678&lt;sql id=\"if-title-author\"&gt; &lt;if test=\"title != null\"&gt; and title = #&#123;title&#125; &lt;/if&gt; &lt;if test=\"author != null\"&gt; and author = #&#123;author&#125; &lt;/if&gt;&lt;/sql&gt; 在需要使用的地方使用include标签引用即可 123456&lt;select id=\"queryBlogIf\" parameterType=\"map\" resultType=\"blog\"&gt; select * from blog &lt;where&gt; &lt;include refid=\"if-title-author\"&gt;&lt;/include&gt; &lt;/where&gt;&lt;/select&gt; foreach 动态 SQL 的另一个常见使用场景是对集合进行遍历（尤其是在构建 IN 条件语句的时候） 1select * from user where 1 = 1 and (id = 1 or id = 2 or id = 3) 12345678&lt;select id=\"queryBlogForEach\" parameterType=\"map\" resultType=\"blog\"&gt; select * from blog &lt;where&gt; &lt;foreach collection=\"ids\" item=\"id\" open=\"(\" separator=\"or\" close=\")\"&gt; id = #&#123;id&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt; 12345678910111213141516@Testpublic void queryBlogForEach() &#123; SqlSession session = MybatisUtils.getSession(); BlogMapper mapper = session.getMapper(BlogMapper.class); ArrayList&lt;Object&gt; list = new ArrayList&lt;&gt;(); list.add(\"974f3a24647c44158c1a68ff2d525931\"); list.add(\"04d3e517967745888792fbc6bc16883f\"); list.add(\"86317fe6084c49c785e93df77aedcc59\"); HashMap map = new HashMap&lt;&gt;(); map.put(\"ids\", list); List&lt;Blog&gt; blogList = mapper.queryBlogForEach(map); for (Blog blog : blogList) &#123; System.out.println(blog); &#125; session.close();&#125; 动态SQL就是在拼接SQL语句, 我们只要保证SQL的正确性, 按照SQL的格式, 去排列组合就可以了 建议: 先在Mysql中写出完整的SQL, 再对对应的去修改成为我们的动态SQL实现即可!","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://i.codingce.com.cn/categories/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://i.codingce.com.cn/tags/MyBatis/"}]},{"title":"注解开发","slug":"注解开发","date":"2020-07-14T01:48:28.000Z","updated":"2020-12-13T04:41:40.453Z","comments":true,"path":"2020/07/14/注解开发/","link":"","permalink":"http://i.codingce.com.cn/2020/07/14/%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/","excerpt":"","text":"使用注解开发 面向接口编程 大家之前都学过面向对象编程, 也学过接口, 但真正的开发过程中,很多时候我们都会选择面向接口编程 根本原因: 解耦, 可拓展, 提高复用, 分层开发中, 上层不用具体实现, 大家都遵守共同的标准, 使得开发变得很容易, 规范更好 在一个面向对象的系统中, 系统的各种功能, 是由许许多多的不同对象协作完成的, 在这种情况下, 各个对象内部是如何实现自己的, 对系统的设计人员来讲就不那么重要了. 各个对象之间的协作关系成为系统设计的关键, 小到不同类之间的通信, 大到模块之间的交互, 在系统的设计之初都要着重考虑的, 这也是系统设计的主要内容. 面向接口编程就是指按照这种思想来编程. 关于接口的理解 接口从更深层次的理解, 应是定义(规范, 约束)与实现(名实分离的原则)的分离 接口的本身反映了系统的设计人员对系统的抽象理解 接口应该有两类 第一类是对一个个体的抽象, 它可对应成为一个抽象体(abstract class) 第二类是对一个个体某一方面的抽象, 即形成一个抽面体(interface) 一个个体可能有多个抽象层面, 抽象与抽象体面是有区别的 三个面向的区别 面向对象是指, 我们考虑问题时, 以对象为单位, 考虑它的属性及方法 面向过程是指, 我们考虑问题时, 以一个具体的流程(事务过程)为单位, 考虑它的实现 接口设计与非接口设计是针对复用技术而言, 与面向对象(过程)不是一个问题, 更多的体现就是对系统整体的架构 使用注解开发 注解在接口上实现 12@Select(\"select * from user\")List&lt;User&gt; getUsers(); 需要在核心配置文件中绑定接口 1234&lt;!--绑定接口--&gt;&lt;mappers&gt; &lt;mapper class=\"cn.com.codingce.dao.UserMapper\" /&gt;&lt;/mappers&gt; 测试 本质: 反射机制实现 原理: 动态代理 Mybatis详细的执行流程 改造MybatisUtils工具类的getSession( ) 方法，重载实现。 12345678//获取SqlSession连接public static SqlSession getSession()&#123; return getSession(true); //事务自动提交&#125; public static SqlSession getSession(boolean flag)&#123; return sqlSessionFactory.openSession(flag);&#125; 【注意】确保实体类和数据库字段对应 查询 编写接口方法注解 123//根据id查询用户@Select(\"select * from user where id = #&#123;id&#125;\")User selectUserById(@Param(\"id\") int id); 测试 12345678@Testpublic void testSelectUserById() &#123; SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user = mapper.selectUserById(1); System.out.println(user); session.close();&#125; 新增： 编写接口方法注解 123//添加一个用户@Insert(\"insert into user (id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;)\")int addUser(User user); 测试 12345678@Testpublic void testAddUser() &#123; SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user = new User(6, \"掌上编程\", \"123456\"); mapper.addUser(user); session.close();&#125; 修改： 编写接口方法注解 12@Update(\"update user set name=#&#123;name&#125;,pwd=#&#123;password&#125; where id = #&#123;id&#125;\")int updateUser(User user); 测试 123456789//修改一个用户@Testpublic void testUpdateUser() &#123; SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user = new User(6, \"掌上编程\", \"zxcvbn\"); mapper.updateUser(user); session.close();&#125; 删除： 编写接口方法注解 123//根据id删除用@Delete(\"delete from user where id = #&#123;id&#125;\")int deleteUser(@Param(\"id\")int id); 测试 1234567@Testpublic void testDeleteUser() &#123; SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); mapper.deleteUser(6); session.close();&#125; 【注意点：增删改一定记得对事务的处理】不建议自动提交事务","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://i.codingce.com.cn/categories/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://i.codingce.com.cn/tags/MyBatis/"}]},{"title":"其他分页","slug":"RowBounds","date":"2020-07-14T01:10:39.000Z","updated":"2020-12-13T04:41:40.422Z","comments":true,"path":"2020/07/14/RowBounds/","link":"","permalink":"http://i.codingce.com.cn/2020/07/14/RowBounds/","excerpt":"","text":"RowBounds分页 面向对象实现,RowBounds分页比较老了解即可,有些老的公司可能还在使用 不再使用SQL实现分页 接口 123456789 //RowBounds分页 List&lt;User&gt; getUserByRowBounds(Map&lt;String, Integer&gt; map);``` - mapper.xml```xml &lt;!--RowBounds分页--&gt; &lt;select id=\"getUserByRowBounds\" parameterType=\"map\" resultType=\"user\" resultMap=\"UserMap\"&gt; select * from mybatis.user &lt;/select&gt; 测试 12345678910111213@Testpublic void getUserByRowBounds() &#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); //通过RowBounds实现 RowBounds rowBounds = new RowBounds(1, 3); //通过Java代码层面实现分页 List&lt;User&gt; userList = sqlSession.selectList(\"cn.com.codingce.dao.UserMapper.getUserByRowBounds\", null, rowBounds); for (User u : userList ) &#123; System.out.println(u); &#125; sqlSession.close();&#125; 分页插件 了解即可, 万一以后公司的架构师, 说要使用, 你需要知道他是什么东西! 底层都是相同的.","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://i.codingce.com.cn/categories/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://i.codingce.com.cn/tags/MyBatis/"}]},{"title":"Java中exdents与implement区别","slug":"Java中exdents与implement区别","date":"2020-07-13T05:00:03.000Z","updated":"2020-12-13T04:41:40.422Z","comments":true,"path":"2020/07/13/Java中exdents与implement区别/","link":"","permalink":"http://i.codingce.com.cn/2020/07/13/Java%E4%B8%ADexdents%E4%B8%8Eimplement%E5%8C%BA%E5%88%AB/","excerpt":"","text":"Java中exdents implement 区别 简单说： extends是继承父类，只要那个类不是声明为final或者那个类定义为abstract的就能继承， JAVA中不支持多重继承，但是可以用接口来实现，这样就要用到implements， 继承只能继承一个类，但implements可以实现多个接口，用逗号分开就行了 ,比如 class A extends B implements C,D,E 术语话来说： extends 继承类；implements 实现接口。 类和接口是不同的：类里是有程序实现的；而接口无程序实现，只可以预定义方法 Java也提供继承机制﹐但还另外提供一个叫interface的概念。由于Java的继承机制只能提供单一继承（就是只能继承一种父类别）﹐所以就以Java的interface来代替C++的多重继承。interface就是一种介面﹐规定欲沟通的两物件﹐其通讯该有的规范有哪些。 如以Java程式语言的角度来看﹐Java的interface则表示： 一些函数或资料成员为另一些属于不同类别的物件所需共同拥有,则将这些函数与资料成员定义在一个interface中,然后让所有不同类别的Java物件可以共同操作使用之。 Java的class只能继承一个父类别（用extends关键字）, 但可以拥有（或称实作）许多interface（用implements关键字）。 extends和implements有什么不同？ 对于class而言，extends用于（单）继承一个类（class），而implements用于实现一个接口（interface）。 interface的引入是为了部分地提供多继承的功能。在interface中只需声明方法头，而将方法体留给实现的class来做。 这些实现的class的实例完全可以当作interface的实例来对待。 在interface之间也可以声明为extends（多继承）的关系。 注意: 一个interface可以extends多个其他interface。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://i.codingce.com.cn/tags/Java/"}]},{"title":"我理解的互联网应用和企业应用开发","slug":"我理解的互联网应用和企业应用开发","date":"2020-07-13T04:30:55.000Z","updated":"2020-12-13T04:41:40.438Z","comments":true,"path":"2020/07/13/我理解的互联网应用和企业应用开发/","link":"","permalink":"http://i.codingce.com.cn/2020/07/13/%E6%88%91%E7%90%86%E8%A7%A3%E7%9A%84%E4%BA%92%E8%81%94%E7%BD%91%E5%BA%94%E7%94%A8%E5%92%8C%E4%BC%81%E4%B8%9A%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/","excerpt":"","text":"互联网应用(网站或app)，和企业应用的本质区别，应该从用户谈起。 互联网是陌生用户，网站对于他们来说是自助系统(类似于ATM取款机)，不需要、也不可能对他们强制培训，比如用户注册。所以它们要做得绝对的弱智化，尽量降低学习成本。 企业应用是公司员工，带有强制性，而且上岗前、或系统上线前，一般都有培训，比如工行柜台员工那个Windows客户端的功能，比如存款，都是通过输入“2397”调出的。相对于互联网应用，用户体验并不是优先考虑的。但有一点会很重视，那就是便捷性，如快捷键，因为这些应用一般都是运营系统，员工每天都是重复做那些事情，效率很关键。 特别提示，像淘宝网，前台网站是互联网应用，供买家使用产品、订单模块属于企业应用。 对于一家B2C电子商务公司，往往既有前台的互联网应用，也有后台的业务系统。因为前后台的高度耦合性，如前台订单提交和状态，必须和后台的订单处理流程对应，导致项目很难外包给第三方软件公司，互联网公司一般都有自己的IT开发团队。将软件分包，需要很高的项目管理水平：开发过程解耦+模块解耦。目前，互联网开发外包刚刚起步。 用户行为驱动 vs 业务流程驱动 互联网是用户行为(意图)驱动，带有随机性，而且不同的用户有不同的浏览习惯。比如我google东西时，一般会先打开上10个页面，然后才一个个看。再比如豆瓣网的书籍详细页：书籍评分、查看类似的书、查看书评、添加书评等，并没有严格的逻辑或流程。同一个书籍界面，书商(作者)、读者、点评者，对该页面的关注点都不一样，就如同企业应用里面的不同用户角色，登录到系统看到的界面不一样。 而且，用户查到该书后，他的浏览顺序、下一步操作都有随机性。很可能因为网站速度慢，他点击了关闭。 这样的系统如何设计？核心原则：研究用户进入该页面的场景，在该场景下用户的需求，以及在此需求下产生的行为。比如购书网站，用户从比价网进来，第一关注点是折扣和促销；如果用户是购买过程中不经意看到一本陌生书，那么他会关注该书的目录和评价；如果用户已经在购物车添加了一本书，那么他会看一下“其他用户还购买了…”。 其实，企业应用也是这样，Use Case里就特别强调了Business Scenarios(业务场景)。 因为企业应用一般是协作式系统，协作式系统涉及到协作流程，也就是工作流，比如订单处理流程、病人应诊流程。当然了，也有很多模块是没有流程的，如交电费(电力CRM)。但它们基本上都可以抽象为表格+表单+流程。 互联网用户的行为习惯是自己练就的，而企业应用的用户习惯，更多是培训出来的。互联网用户行为极不稳定，比如20岁的年轻人浏览网页非常浮躁，到30多岁就沉稳多了；在网页臭长臭长的年代，鼠标滚轮就被派上了用场。而企业应用，界面操作一般是流程驱动，而流程可能上10年都是那样，用户操作相对比较稳定、线性。 界面原型 vs 领域模型 无论是互联网应用还是企业应用，稍微复杂点，一般都会出架构图，如部署图（可能4+1架构视图有点教条），如根据负载，一台服务器只做批处理(数据同步和发送邮件)，一台服务器只做搜索查询。 比较复杂的业务系统，我们倾向于在需求分析阶段，开发用例图、领域模型图、序列图。当然，我也见过，很简单的业务系统也画一堆图，然后被开发人员扔到垃圾堆里，其实，一个excel功能需求表就可以解决。 对于互联网应用，界面即需求，往往不需要给业务需求建模：领域模型图和序列图等基本上没法用。性能和可伸缩性等非功能需求，可以以功能列表归纳。 软件过程 因为需求过程的成果物不同，传统的那套软件开发方法：从需求规格说明书到详细设计，即使是RUP等迭代过程，也很难照搬。 互联网进化快，用户需求非常不稳定，它们往往都是在运营过程中改进；系统上线后，偏向于维护而不是迭代开发。估计若干年都不会出现针对互联网领域的业务组件库，但在企业应用领域却很普遍，比如SAP的NetWeaver里针对行业的组件库。 互联网应用，一般均采用敏捷过程。但这种敏捷过程，我们往往搬过来都很教条，如燃尽图和每日站立会议。其实它们解决的就是进度和沟通的，本质上也就是风险控制。这些方法学层面的东西，在《职业经理人》课程里面，都是常识：时间管理、沟通管理、团队管理等等。 敏捷是一种理念，不是一种方法学，虽然最终要落实到方法学。什么叫川菜，什么叫东北菜？一看就知道，但我们需要用辣椒和酱油来衡量吗？ IT人员构成 做企业应用项目，一般有三种角色：技术、需求、管理。 技术：架构师、高级工程师、工程师、设计师 需求：需求分析师 管理：项目经理PM、技术经理TL 上面我忽视掉了配置管理和测试等角色。 对于互联网项目，角色和上面差不多。 技术：也是架构师、高级工程师、工程师，但设计师普遍比做企业应用的强一个层次。因为他需要处理界面风格、易用性、浏览器兼容性、SEO等。 需求：产品经理+公司业务人员，可能还会配上用户体验专员(交互设计师)。 对于企业应用，偏向于分析性归纳思维(向内)，它只要求你抽象出的软件，能够match当前的业务；而互联网应用，更多是偏向创造性思维(向外)，比如SNS网站的like、poke按钮，极大活跃了用户互动。 管理：项目经理PM，可能由产品经理PD担当，看项目规模了。可能还有技术经理TL，负责技术人员的绩效管理。 技术架构 做企业应用的那一套，如Hibernate，我是不建议用在互联网上的。Hibernate解决领域模型的持久化很有效，而互联网应用，偏向于页面而不是领域模型。 另外，互联网应用偏向于读，而不是写操作，这和企业应用是反过来的，Hibernate主要是解决持久化(写)。 Hibernate的性能、级联查询，基本上在互联网上很难有作为。 如果用Java，我倾向于Spring MVC+Spring JDBC，前台做URLRewrite。企业应用那种三层架构、五层架构，在互联网开发上，一定要谨慎。 谈到开发语言，可以选择Java，这和.Net基本上没啥差别，看你的团队精通哪种了。因为它们在团队协作性方面都很强(静态编译型)，有强大的开发工具来规范团队行为，对项目可维护性也很有益。 当然了，如果团队不大，php应该是首选，因为它操作数据库非常简单、高效、灵活。php优势特别是在部署上面，因为互联网应用部署非常频繁，Java一部署就重启app，原来session全部丢失，这绝不是一个小问题。 对于Ruby这类小众语言，太过灵活，团队一大，很容易失控。我没有在项目中实战过，只是曾经研究、学习，不敢妄自发言。","categories":[{"name":"随记","slug":"随记","permalink":"http://i.codingce.com.cn/categories/%E9%9A%8F%E8%AE%B0/"}],"tags":[{"name":"随记","slug":"随记","permalink":"http://i.codingce.com.cn/tags/%E9%9A%8F%E8%AE%B0/"}]},{"title":"分页(SQL)","slug":"分页","date":"2020-07-13T02:34:50.000Z","updated":"2020-12-13T04:41:40.438Z","comments":true,"path":"2020/07/13/分页/","link":"","permalink":"http://i.codingce.com.cn/2020/07/13/%E5%88%86%E9%A1%B5/","excerpt":"","text":"分页 为什么分页 减少数据的处理量 使用Limit分页 1SELECT * FROM user limit startIndex, pageSize; 使用mybatis实现分页,核心SQL 接口 12//分页List&lt;User&gt; getUserByLimit(Map&lt;String, Integer&gt; map); mapper.xml 1234&lt;!--分页--&gt;&lt;select id=\"getUserByLimit\" parameterType=\"map\" resultType=\"user\" resultMap=\"UserMap\"&gt; select * from mybatis.user limit #&#123;startIndex&#125;, #&#123;pageSize&#125;&lt;/select&gt; 测试 1234567891011121314@Testpublic void getUserLimit() &#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); HashMap&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;(); map.put(\"startIndex\", 0); map.put(\"pageSize\", 3); List&lt;User&gt; userList = userMapper.getUserByLimit(map); for (User u : userList ) &#123; System.out.println(u); &#125; sqlSession.close();&#125;","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://i.codingce.com.cn/categories/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://i.codingce.com.cn/tags/MyBatis/"}]},{"title":"日志工厂","slug":"日志工厂","date":"2020-07-12T22:25:26.000Z","updated":"2020-12-13T04:41:40.453Z","comments":true,"path":"2020/07/13/日志工厂/","link":"","permalink":"http://i.codingce.com.cn/2020/07/13/%E6%97%A5%E5%BF%97%E5%B7%A5%E5%8E%82/","excerpt":"","text":"控制台打印SQL 如果一个数据库的操作,出现了异常,我们需要排查,日志就是最好的帮手 曾经: sout debug 现在: 日志工厂 SLF4J | LOG4J 掌握 LOG4J2 JDK_LOGGING COMMONS_LOGGING STDOUT_LOGGING 掌握 NO_LOGGING 在Mybatis中具体使用哪一个日志实现, 在设置中设定. STDOUT_LOGGING标准 在Mybatis的核心配置文件中配置 顺序: 1234&lt;!--日志工厂--&gt;&lt;settings&gt; &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/&gt;&lt;/settings&gt; Log4j 先导入log4j的包 123456&lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt;&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt; Log4j是Apache的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件 我们也可以控制每一条日志的输出格式 通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程 通过一个配置文件来灵活地进行配置 log4j.properties 1234567891011121314151617181920212223### 配置 ###log4j.rootLogger=DEBUG,console,file### 控制台输出相关设置 ###log4j.appender.console=org.apache.log4j.ConsoleAppenderlog4j.appender.console.Target=System.outlog4j.appender.console.Threshold=DEBUGlog4j.appender.console.layout=org.apache.log4j.PatternLayoutlog4j.appender.console.layout.ConversionPattern=[%c]-%m%n### 文件输出相关设置 ###log4j.appender.file=org.apache.log4j.RollingFileAppenderlog4j.appender.file.File=./log/coding.loglog4j.appender.file.MaxFileSize=10mblog4j.appender.file.Threshold=DEBUGlog4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern=[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n### 日志输出级别 ###log4j.logger.org.mybatis=DEBUGlog4j.logger.java.sql=DEBUGlog4j.logger.java.sql.Statement=DEBUGlog4j.logger.java.sql.ResultSet=DEBUGlog4j.logger.java.sql.PreparedStatement=DEBUG 配置log4j为日志的实现 123&lt;settings&gt; &lt;setting name=\"logImpl\" value=\"LOG4J\"/&gt;&lt;/settings&gt; 简单使用 在要使用Log4j的类中, 导入import org.apache.log4j.Logger; 日志对象, 参数为当前类的class 1Logger logger = Logger.getLogger(UserDaoTest.class); 日志级别(常用) 123logger.info(\"info\");logger.debug(\"debug\");logger.error(\"error\");","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://i.codingce.com.cn/categories/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://i.codingce.com.cn/tags/MyBatis/"}]},{"title":"Mybatis中的属性名和字段名","slug":"Mybatis中的属性名和字段名","date":"2020-07-12T09:20:36.000Z","updated":"2020-12-13T04:41:40.422Z","comments":true,"path":"2020/07/12/Mybatis中的属性名和字段名/","link":"","permalink":"http://i.codingce.com.cn/2020/07/12/Mybatis%E4%B8%AD%E7%9A%84%E5%B1%9E%E6%80%A7%E5%90%8D%E5%92%8C%E5%AD%97%E6%AE%B5%E5%90%8D/","excerpt":"","text":"解决属性名和字段名不一致问题 问题 数据库中的字段 新建一个项目，拷贝之前，测试实体类字段不一致的情况 12345public class User &#123; private int id; private String name; private String password;&#125; 测试出现问题 123select * from mybatis.user where id = #&#123;id&#125;类型处理器select id, name, pwd from mybatis.user where id = #&#123;id&#125; 解决方案 起别名 123&lt;select id=\"getUserById\" parameterType=\"int\" resultType=\"cn.com.codingce.pojo.User\"&gt; select id, name, pwd as password from mybatis.user where id = #&#123;id&#125; &lt;/select&gt; resultMap 结果集映射 id name pwd id name password 12345678910111213&lt;!--结果集映射--&gt; &lt;resultMap id=\"UserMap\" type=\"User\"&gt; &lt;!--colum数据库中的字段, property实体类中的属性--&gt; &lt;!-- &lt;result column=\"id\" property=\"id\"/&gt; &lt;result column=\"name\" property=\"name\"/&gt; --&gt; &lt;result column=\"pwd\" property=\"password\"/&gt; &lt;/resultMap&gt; &lt;!--查询--&gt; &lt;select id=\"getUserById\" parameterType=\"int\" resultMap=\"UserMap\"&gt; select * from mybatis.user where id = #&#123;id&#125; &lt;/select&gt; resultMap元素是MyNatis中最强大的元素 ResultMap 的设计思想是，对简单的语句做到零配置，对于复杂一点的语句，只需要描述语句之间的关系就行了. ResultMap 的优秀之处——你完全可以不用显式地配置它们. 如果这个世界总是这么简单就好了.","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://i.codingce.com.cn/categories/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://i.codingce.com.cn/tags/MyBatis/"}]},{"title":"utf8和utf8mb4的区别","slug":"utf8和utf8mb4的区别","date":"2020-07-11T02:19:57.000Z","updated":"2020-12-13T04:41:40.438Z","comments":true,"path":"2020/07/11/utf8和utf8mb4的区别/","link":"","permalink":"http://i.codingce.com.cn/2020/07/11/utf8%E5%92%8Cutf8mb4%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"一、简介 MySQL在5.5.3之后增加了这个utf8mb4的编码，mb4就是most bytes 4的意思，专门用来兼容四字节的unicode。好在utf8mb4是utf8的超集，除了将编码改为utf8mb4外不需要做其他转换。当然，为了节省空间，一般情况下使用utf8也就够了。 二、内容描述 那上面说了既然utf8能够存下大部分中文汉字,那为什么还要使用utf8mb4呢? 原来mysql支持的 utf8 编码最大字符长度为 3 字节，如果遇到 4 字节的宽字符就会插入异常了。三个字节的 UTF-8 最大能编码的 Unicode 字符是 0xffff，也就是 Unicode 中的基本多文种平面(BMP)。也就是说，任何不在基本多文本平面的 Unicode字符，都无法使用 Mysql 的 utf8 字符集存储。包括 Emoji 表情(Emoji 是一种特殊的 Unicode 编码，常见于 ios 和 android 手机上)，和很多不常用的汉字，以及任何新增的 Unicode 字符等等(utf8的缺点)。","categories":[{"name":"Sql","slug":"Sql","permalink":"http://i.codingce.com.cn/categories/Sql/"}],"tags":[{"name":"Sql","slug":"Sql","permalink":"http://i.codingce.com.cn/tags/Sql/"}]},{"title":"第一个MyBatis程序","slug":"First-MyBatis","date":"2020-07-11T02:11:52.000Z","updated":"2020-12-13T04:41:40.422Z","comments":true,"path":"2020/07/11/First-MyBatis/","link":"","permalink":"http://i.codingce.com.cn/2020/07/11/First-MyBatis/","excerpt":"","text":"第一个MyBatis程序 思路: 搭建环境–&gt;导入MyBatis–&gt;编写代码–&gt;测试 搭建环境 搭建数据库 新建项目 新建一个普通的maven项目 删除src目录 导入maven依赖 123456789101112131415161718192021&lt;!--导入依赖--&gt;&lt;dependencies&gt; &lt;!--mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.46&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建一个模块 编写mybatis的核心配置文件 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=\"org/mybatis/example/BlogMapper.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 编写mybatis的工具类 1234567891011121314151617181920212223//sqlSessionFactory-&gt;sqlSessionpublic class MybatisUtils &#123; private static SqlSessionFactory sqlSessionFactory; static &#123; try &#123; //使用Mybatis第一步:获取sqlSessionFactory对象 String resource = \"org/mybatis/example/mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; //既然有了 SqlSessionFactory,顾名思义,我们可以从中获得 SqlSession 的实例.SqlSession 提供了在数据库执行 SQL 命令所需的所有方法.你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句.例如： public static SqlSession getSession() &#123;// SqlSession sqlSession = sqlSessionFactory.openSession();// return sqlSession; return sqlSessionFactory.openSession(); &#125;&#125; 编写代码 实体类 Dao接口 123public interface UserDao &#123; List&lt;User&gt; getUserList();&#125; 接口实现类由原来的UserDaoImpl转变为一个Mapper配置文件 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;!--namespace=绑定一个对应的Dao/Mapper接口--&gt;&lt;mapper namespace=\"cn.com.codingce.dao.UserDao\"&gt;&lt;!--查询语句 id和接口方法一一对应--&gt;&lt;select id=\"getUserList\" resultType=\"cn.com.codingce.pojo.User\"&gt; select * from mybatis.user&lt;/select&gt;&lt;/mapper&gt;&lt;!--相当于UserDaoImpl--&gt; 测试 org.apache.ibatis.binding.BindingException: Type interface cn.com.codingce.dao.UserDao is not known to the MapperRegistry. 这个错会经常遇到 1234567891011121314151617181920212223 @Test public void test() &#123; //第一步: 获得SqlSession对象 SqlSession sqlSession = MybatisUtils.getSqlSession(); try &#123; //方式一:getMapper UserDao userDao = sqlSession.getMapper(UserDao.class); List&lt;User&gt; userList = userDao.getUserList(); //方式二:// List&lt;User&gt; userList = sqlSession.selectList(\"cn.com.codingce.dao.UserDao.getUserList\"); for (User u:userList ) &#123; System.out.println(u); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; //关闭sqlSession sqlSession.close(); &#125; &#125; 可能遇到的问题: 配置文件没有注册 绑定接口错误 方法名不对 返回类型不对 Maven导出资源问题 CRUE namespace namespace中的包名要和Dao/mapper接口包名一致 select 选择,查询语句: id: 就是对应的namespace中的方法名 resultType: Sql语句执行的返回值! parameterType: 参数类型! 1234567891011121314@Testpublic void getUserById() &#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); try &#123; UserMapper userDao = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; userList = userDao.getUserList(); User user = userDao.getUserById(1); System.out.println(user); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; sqlSession.close(); &#125;&#125; 插入一条数据 123456789101112131415161718192021//insert一个用户int addUser(User user);//注解插入 就不用使用mapper配置@Insert(\"insert into mybatis.user(id, name, pwd) values (#&#123;id&#125;, #&#123;name&#125;, #&#123;pwd&#125;)\")int insertUser(User user);&lt;!--插入, 对象中的属性可以直接取出来--&gt;&lt;insert id=\"addUser\" parameterType=\"cn.com.codingce.pojo.User\"&gt; insert into mybatis.user(id, name, pwd) values (#&#123;id&#125;, #&#123;name&#125;, #&#123;pwd&#125;)&lt;/insert&gt;@Testpublic void addUser() &#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); int i = userMapper.addUser(new User(5, \"123\", \"123456\")); System.out.println(i); //提交事务 sqlSession.commit(); sqlSession.close();&#125; 修改用户 12345678910111213141516171819//修改int updateUser(User user);&lt;!--修改--&gt;&lt;update id=\"updateUser\" parameterType=\"cn.com.codingce.pojo.User\"&gt; update mybatis.user set name = #&#123;name&#125;, pwd = #&#123;pwd&#125; where id = #&#123;id&#125;&lt;/update&gt;@Testpublic void updateUser() &#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); int res = userMapper.updateUser(new User(5, \"bytedance\", \"123456\")); if (res &gt; 0) &#123; System.out.println(\"修改成功\"); &#125; //提交事务 sqlSession.commit(); sqlSession.close();&#125; 删除用户 12345678910111213141516171819//删除int deleteUser(int id);&lt;!--删除--&gt;&lt;delete id=\"deleteUser\" parameterType=\"int\"&gt; delete from mybatis.user where id = #&#123;id&#125;&lt;/delete&gt;@Testpublic void deleteUser() &#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); int res = userMapper.deleteUser(4); if (res &gt; 0) &#123; System.out.println(\"删除成功\"); &#125; sqlSession.commit(); sqlSession.close();&#125; 注意点:增删改需要提交事务 分析错误 标签不要匹配错误 resource绑定mapper, 需要使用路径 程序配置文件必须符合规范 NullPointerException, 没有注册资源 输出的xml文件存在中文乱码问题 maven资源导出问题 万能的Map 1234567891011121314151617181920212223User getUserByIdTwo(Map&lt;String, Object&gt; map);&lt;!--查询Map--&gt;&lt;select id=\"getUserByIdTwo\" parameterType=\"map\" resultType=\"cn.com.codingce.pojo.User\"&gt; select * from mybatis.user where id = #&#123;id&#125; and name = #&#123;name&#125;&lt;/select&gt;@Testpublic void getUserByIdTwo() &#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); try &#123; UserMapper userMapper = sqlSession.getMapper(UserMapper.class); HashMap&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(\"id\", 1); map.put(\"name\", \"掌上编程\"); User user = userMapper.getUserByIdTwo(map); System.out.println(user); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; sqlSession.close(); &#125;&#125; 若实体类或者数据库中的表字段或者参数过多,我们应当考虑使用Map parameterType=“map” 对象传递参数,直接在sql中取对象的属性即可 parameterType=“object” 只有一个基本类型参数的情况下, 可以直接在sql中取到 parameterType=“int” 可以不写 多个参数用Map, 或者注解 模糊查询 Java代码执行的时候, 传递通配符%% List userList = userMapper.getUserListLike(&quot;%掌%&quot;); 在sql拼接使用通配符 select * from mybatis.user where name like “%”#{name}&quot;%&quot; 配置解析 核心配置文件 mybatis-config.xml(官方建议使用这个名字) mybatis的配置文件包含了会深深影响Mybatis行为设置和属性信息 12345678910111213configuration（配置）properties（属性）settings（设置）typeAliases（类型别名）typeHandlers（类型处理器）objectFactory（对象工厂）plugins（插件）environments（环境配置）environment（环境变量）transactionManager（事务管理器）dataSource（数据源）databaseIdProvider（数据库厂商标识）mappers（映射器） 环境配置(environments) MyBatis 可以配置成适应多种环境 不过要记住：尽管可以配置多个环境,但每个 SqlSessionFactory 实例只能选择一种环境. 学会使用配置多套运行环境 Mybatis默认的事务管理器就是JDBC, 连接池POOLED 属性(properties) 我们可以通过properties属性来实现引用配置文件 这些属性可以在外部进行配置,并可以进行动态替换.你既可以在典型的 Java 属性文件中配置这些属性,也可以在 properties 元素的子元素中设置.(db.properties) 1234567891011121314&lt;!--内部--&gt;&lt;properties resource=\"org/mybatis/example/config.properties\"&gt; &lt;property name=\"username\" value=\"dev_user\"/&gt; &lt;property name=\"password\" value=\"F2Fa3!33TYyg\"/&gt;&lt;/properties&gt;&lt;!--优先使用外部引入 引入外部配置文件--&gt;&lt;properties resource=\"db.properties\" /&gt;driver=com.mysql.jdbc.Driverurl=jdbc:mysql://cdb-q9atzwrq.bj.tencentcdb.com:1067/mybatis?useSSL=true&amp;amp;useUnicode=trueusername=rootpassword=123456 类型别名（typeAliases） 类型别名可为 Java 类型设置一个缩写名字. 它仅用于 XML 配置,意在降低冗余的全限定类名书写. 123456789&lt;typeAliases&gt; &lt;typeAlias alias=\"Author\" type=\"domain.blog.Author\"/&gt; &lt;typeAlias alias=\"Blog\" type=\"domain.blog.Blog\"/&gt; &lt;typeAlias alias=\"Comment\" type=\"domain.blog.Comment\"/&gt; &lt;typeAlias alias=\"Post\" type=\"domain.blog.Post\"/&gt; &lt;typeAlias alias=\"Section\" type=\"domain.blog.Section\"/&gt; &lt;typeAlias alias=\"Tag\" type=\"domain.blog.Tag\"/&gt;&lt;/typeAliases&gt;当这样配置时,Blog 可以用在任何使用 domain.blog.Blog 的地方. 也可以指定一个包名,MyBatis 会在包名下面搜索需要的 Java Bean 每一个在包 domain.blog 中的 Java Bean,在没有注解的情况下,会使用 Bean 的首字母小写的非限定类名来作为它的别名. 比如 domain.blog.Author 的别名为 author；若有注解,则别名为其注解值. 123&lt;typeAliases&gt; &lt;package name=\"domain.blog\"/&gt;&lt;/typeAliases&gt; 实体类少的时候使用第一种, 实体类多的时候使用第二种 第一种可以DIY别名,第二种则不行, 如果非要改, 需要在实体类上增加注解 使用注解 1234@Alias(\"author\")public class Author &#123; ...&#125; 设置 这是Mybatis中极为重要的调整设置, 他们会改变Mybatis的运行行为 cacheEnabled 全局性地开启或关闭所有映射器配置文件中已配置的任何缓存. true | false true lazyLoadingEnabled 延迟加载的全局开关.当开启时,所有关联对象都会延迟加载. 特定关联关系中可通过设置 fetchType 属性来覆盖该项的开关状态. true | false true logImpl 指定 MyBatis 所用日志的具体实现,未指定时将自动查找 SLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING 未设置 其他配置 typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） 映射器（mappers） 既然 MyBatis 的行为已经由上述元素配置完了,我们现在就要来定义 SQL 映射语句了. 但首先,我们需要告诉 MyBatis 到哪里去找到这些语句. 在自动查找资源方面,Java 并没有提供一个很好的解决方案,所以最好的办法是直接告诉 MyBatis 到哪里去找映射文件. 你可以使用相对于类路径的资源引用,或完全限定资源定位符（包括 file:/// 形式的 URL）,或类名和包名等. 12345678910111213141516171819202122232425&lt;!-- 使用相对于类路径的资源引用 推荐使用--&gt;&lt;mappers&gt; &lt;mapper resource=\"org/mybatis/builder/AuthorMapper.xml\"/&gt; &lt;mapper resource=\"org/mybatis/builder/BlogMapper.xml\"/&gt; &lt;mapper resource=\"org/mybatis/builder/PostMapper.xml\"/&gt;&lt;/mappers&gt;&lt;!-- 使用完全限定资源定位符（URL） 不建议使用--&gt;&lt;mappers&gt; &lt;mapper url=\"file:///var/mappers/AuthorMapper.xml\"/&gt; &lt;mapper url=\"file:///var/mappers/BlogMapper.xml\"/&gt; &lt;mapper url=\"file:///var/mappers/PostMapper.xml\"/&gt;&lt;/mappers&gt;&lt;!-- 使用映射器接口实现类的完全限定类名 接口和他的Mapper配置文件必须同名! 接口和他的Mapper配置文件必须在同一个包下--&gt;&lt;mappers&gt; &lt;mapper class=\"org.mybatis.builder.AuthorMapper\"/&gt; &lt;mapper class=\"org.mybatis.builder.BlogMapper\"/&gt; &lt;mapper class=\"org.mybatis.builder.PostMapper\"/&gt;&lt;/mappers&gt;&lt;!-- 将包内的映射器接口实现全部注册为映射器 接口和他的Mapper配置文件必须同名! 接口和他的Mapper配置文件必须在同一个包下--&gt;&lt;mappers&gt; &lt;package name=\"org.mybatis.builder\"/&gt;&lt;/mappers&gt; 生命周期和作用域 生命周期和作用域是至关重要, 因为错误的使用会导致严重的并发问题. SqlSessionFactoryBuilder 一旦创建了 SqlSessionFactory，就不再需要它了 局部变量 SqlSessionFactory 说白了可以想象为: 数据库连接池 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例(多次重建 SqlSessionFactory 被视为一种代码“坏习惯”) SqlSession 连接到连接池的一个请求 SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域 用完之后赶紧关闭, 否则资源占用","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://i.codingce.com.cn/categories/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://i.codingce.com.cn/tags/MyBatis/"}]},{"title":"什么是MyBatis","slug":"MyBatis","date":"2020-07-11T00:09:32.000Z","updated":"2020-12-13T04:41:40.422Z","comments":true,"path":"2020/07/11/MyBatis/","link":"","permalink":"http://i.codingce.com.cn/2020/07/11/MyBatis/","excerpt":"","text":"简介 什么是 MyBatis？ MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。 MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。 2013年11月迁移到Github。 如何获取MyBatis maven仓库 123456&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt;&lt;/dependency&gt; Github: https://github.com/mybatis/mybatis-3 中文文档地址: https://mybatis.org/mybatis-3/zh/index.html 持久化 数据持久化(是一个动作) 持久化就是将数据在持久化状态和瞬时状态的转化的过程 内存: 断电丢失 数据库jdbc: io文件持久化(早期将数据存储在tzt文件中,io特别特别的浪费资源) 生活: 冷藏、罐头. 为什么需要持久化 有一些对象,不能让他丢掉. 内存太贵了(虽然读取速度快) 持久层 Dao层、Service、Controller层 完成持久化工作的代码块. 层界限十分明显. 为什么需要MyBatis 帮助程序员将数据存入到数据库中. 方便 传统的JDBC太复杂了,简化,框架,自动化. 不用Mybatis也可以.更容易上手.技术没有高低之分,人才有 优点: 简单易学：本身就很小且简单。没有任何第三方依赖，最简单安装只要两个jar文件+配置几个sql映射文件易于学习，易于使用，通过文档和源代码，可以比较完全的掌握它的设计思路和实现。 灵活：mybatis不会对应用程序或者数据库的现有设计强加任何影响。 sql写在xml里，便于统一管理和优化。通过sql语句可以满足操作数据库的所有需求。 解除sql与程序代码的耦合：通过提供DAO层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。sql和代码的分离，提高了可维护性。 提供映射标签，支持对象与数据库的orm字段关系映射 提供对象关系映射标签，支持对象关系组建维护 提供xml标签，支持编写动态sql。 最重要的一点:使用的人多 Spring SpringMVC SpringBoot","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://i.codingce.com.cn/categories/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://i.codingce.com.cn/tags/MyBatis/"}]},{"title":"ArrayList","slug":"ArrayList","date":"2020-07-09T11:42:22.000Z","updated":"2020-12-13T04:41:40.422Z","comments":true,"path":"2020/07/09/ArrayList/","link":"","permalink":"http://i.codingce.com.cn/2020/07/09/ArrayList/","excerpt":"","text":"ArrayList简介 ArrayList核心源码 ArrayList源码分析 System.arraycopy()和Arrays.copyOf()方法 两者联系与区别 ArrayList核心扩容技术 内部类 ArrayList经典Demo ArrayList简介 ArrayList 的底层是数组队列，相当于动态数组。与 Java 中的数组相比，它的容量能动态增长。在添加大量元素前，应用程序可以使用ensureCapacity操作来增加 ArrayList 实例的容量。这可以减少递增式再分配的数量。 它继承于 AbstractList，实现了 List, RandomAccess, Cloneable, java.io.Serializable 这些接口。 在我们学数据结构的时候就知道了线性表的顺序存储，插入删除元素的时间复杂度为O（n）,求表长以及增加元素，取第 i 元素的时间复杂度为O（1） ArrayList 继承了AbstractList，实现了List。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。 ArrayList 实现了RandomAccess 接口， RandomAccess 是一个标志接口，表明实现这个这个接口的 List 集合是支持快速随机访问的。在 ArrayList 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。 ArrayList 实现了Cloneable 接口，即覆盖了函数 clone()，能被克隆。 ArrayList 实现java.io.Serializable 接口，这意味着ArrayList支持序列化，能通过序列化去传输。 和 Vector 不同，ArrayList 中的操作不是线程安全的！所以，建议在单线程中才使用 ArrayList，而在多线程中可以选择 Vector 或者 CopyOnWriteArrayList。 ArrayList核心源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498package java.util;import java.util.function.Consumer;import java.util.function.Predicate;import java.util.function.UnaryOperator;public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; private static final long serialVersionUID = 8683452581122892189L; /** * 默认初始容量大小 */ private static final int DEFAULT_CAPACITY = 10; /** * 空数组（用于空实例）。 */ private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; //用于默认大小空实例的共享空数组实例。 //我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。 private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; /** * 保存ArrayList数据的数组 */ transient Object[] elementData; // non-private to simplify nested class access /** * ArrayList 所包含的元素个数 */ private int size; /** * 带初始容量参数的构造函数。（用户自己指定容量） */ public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; //创建initialCapacity大小的数组 this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; //创建空数组 this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); &#125; &#125; /** *默认构造函数，DEFAULTCAPACITY_EMPTY_ELEMENTDATA 为0.初始化为10，也就是说初始其实是空数组 当添加第一个元素的时候数组容量才变成10 */ public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125; /** * 构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。 */ public ArrayList(Collection&lt;? extends E&gt; c) &#123; // elementData = c.toArray(); //如果指定集合元素个数不为0 if ((size = elementData.length) != 0) &#123; // c.toArray 可能返回的不是Object类型的数组所以加上下面的语句用于判断， //这里用到了反射里面的getClass()方法 if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // 用空数组代替 this.elementData = EMPTY_ELEMENTDATA; &#125; &#125; /** * 修改这个ArrayList实例的容量是列表的当前大小。 应用程序可以使用此操作来最小化ArrayList实例的存储。 */ public void trimToSize() &#123; modCount++; if (size &lt; elementData.length) &#123; elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); &#125; &#125;//下面是ArrayList的扩容机制//ArrayList的扩容机制提高了性能，如果每次只扩充一个，//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。 /** * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量 * @param minCapacity 所需的最小容量 */ public void ensureCapacity(int minCapacity) &#123; int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) // any size if not default element table ? 0 // larger than default for default empty table. It's already // supposed to be at default size. : DEFAULT_CAPACITY; if (minCapacity &gt; minExpand) &#123; ensureExplicitCapacity(minCapacity); &#125; &#125; //得到最小扩容量 private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; // 获取默认的容量和传入参数的较大值 minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity); &#125; //判断是否需要扩容 private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) //调用grow方法进行扩容，调用此方法代表已经开始扩容了 grow(minCapacity); &#125; /** * 要分配的最大数组大小 */ private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; /** * ArrayList扩容的核心方法。 */ private void grow(int minCapacity) &#123; // oldCapacity为旧容量，newCapacity为新容量 int oldCapacity = elementData.length; //将oldCapacity 右移一位，其效果相当于oldCapacity /2， //我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍， int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量， if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; //再检查新容量是否超出了ArrayList所定义的最大容量， //若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE， //如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; //比较minCapacity和 MAX_ARRAY_SIZE private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125; /** *返回此列表中的元素数。 */ public int size() &#123; return size; &#125; /** * 如果此列表不包含元素，则返回 true 。 */ public boolean isEmpty() &#123; //注意=和==的区别 return size == 0; &#125; /** * 如果此列表包含指定的元素，则返回true 。 */ public boolean contains(Object o) &#123; //indexOf()方法：返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1 return indexOf(o) &gt;= 0; &#125; /** *返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1 */ public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) //equals()方法比较 if (o.equals(elementData[i])) return i; &#125; return -1; &#125; /** * 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。. */ public int lastIndexOf(Object o) &#123; if (o == null) &#123; for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; /** * 返回此ArrayList实例的浅拷贝。 （元素本身不被复制。） */ public Object clone() &#123; try &#123; ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone(); //Arrays.copyOf功能是实现数组的复制，返回复制后的数组。参数是被复制的数组和复制的长度 v.elementData = Arrays.copyOf(elementData, size); v.modCount = 0; return v; &#125; catch (CloneNotSupportedException e) &#123; // 这不应该发生，因为我们是可以克隆的 throw new InternalError(e); &#125; &#125; /** *以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。 *返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。 *因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。 */ public Object[] toArray() &#123; return Arrays.copyOf(elementData, size); &#125; /** * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; *返回的数组的运行时类型是指定数组的运行时类型。 如果列表适合指定的数组，则返回其中。 *否则，将为指定数组的运行时类型和此列表的大小分配一个新数组。 *如果列表适用于指定的数组，其余空间（即数组的列表数量多于此元素），则紧跟在集合结束后的数组中的元素设置为null 。 *（这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度。） */ @SuppressWarnings(\"unchecked\") public &lt;T&gt; T[] toArray(T[] a) &#123; if (a.length &lt; size) // 新建一个运行时类型的数组，但是ArrayList数组的内容 return (T[]) Arrays.copyOf(elementData, size, a.getClass()); //调用System提供的arraycopy()方法实现数组之间的复制 System.arraycopy(elementData, 0, a, 0, size); if (a.length &gt; size) a[size] = null; return a; &#125; // Positional Access Operations @SuppressWarnings(\"unchecked\") E elementData(int index) &#123; return (E) elementData[index]; &#125; /** * 返回此列表中指定位置的元素。 */ public E get(int index) &#123; rangeCheck(index); return elementData(index); &#125; /** * 用指定的元素替换此列表中指定位置的元素。 */ public E set(int index, E element) &#123; //对index进行界限检查 rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; //返回原来在这个位置的元素 return oldValue; &#125; /** * 将指定的元素追加到此列表的末尾。 */ public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! //这里看到ArrayList添加元素的实质就相当于为数组赋值 elementData[size++] = e; return true; &#125; /** * 在此列表中的指定位置插入指定的元素。 *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大； *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。 */ public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! //arraycopy()这个实现数组之间复制的方法一定要看一下，下面就用到了arraycopy()方法实现数组自己复制自己 System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; &#125; /** * 删除该列表中指定位置的元素。 将任何后续元素移动到左侧（从其索引中减去一个元素）。 */ public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work //从列表中删除的元素 return oldValue; &#125; /** * 从列表中删除指定元素的第一个出现（如果存在）。 如果列表不包含该元素，则它不会更改。 *返回true，如果此列表包含指定的元素 */ public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; /* * Private remove method that skips bounds checking and does not * return the value removed. */ private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work &#125; /** * 从列表中删除所有元素。 */ public void clear() &#123; modCount++; // 把数组中所有的元素的值设为null for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0; &#125; /** * 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。 */ public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0; &#125; /** * 将指定集合中的所有元素插入到此列表中，从指定的位置开始。 */ public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount int numMoved = size - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0; &#125; /** * 从此列表中删除所有索引为fromIndex （含）和toIndex之间的元素。 *将任何后续元素移动到左侧（减少其索引）。 */ protected void removeRange(int fromIndex, int toIndex) &#123; modCount++; int numMoved = size - toIndex; System.arraycopy(elementData, toIndex, elementData, fromIndex, numMoved); // clear to let GC do its work int newSize = size - (toIndex-fromIndex); for (int i = newSize; i &lt; size; i++) &#123; elementData[i] = null; &#125; size = newSize; &#125; /** * 检查给定的索引是否在范围内。 */ private void rangeCheck(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; /** * add和addAll使用的rangeCheck的一个版本 */ private void rangeCheckForAdd(int index) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; /** * 返回IndexOutOfBoundsException细节信息 */ private String outOfBoundsMsg(int index) &#123; return \"Index: \"+index+\", Size: \"+size; &#125; /** * 从此列表中删除指定集合中包含的所有元素。 */ public boolean removeAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); //如果此列表被修改则返回true return batchRemove(c, false); &#125; /** * 仅保留此列表中包含在指定集合中的元素。 *换句话说，从此列表中删除其中不包含在指定集合中的所有元素。 */ public boolean retainAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); return batchRemove(c, true); &#125; /** * 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。 *指定的索引表示初始调用将返回的第一个元素为next 。 初始调用previous将返回指定索引减1的元素。 *返回的列表迭代器是fail-fast 。 */ public ListIterator&lt;E&gt; listIterator(int index) &#123; if (index &lt; 0 || index &gt; size) throw new IndexOutOfBoundsException(\"Index: \"+index); return new ListItr(index); &#125; /** *返回列表中的列表迭代器（按适当的顺序）。 *返回的列表迭代器是fail-fast 。 */ public ListIterator&lt;E&gt; listIterator() &#123; return new ListItr(0); &#125; /** *以正确的顺序返回该列表中的元素的迭代器。 *返回的迭代器是fail-fast 。 */ public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; ArrayList源码分析 System.arraycopy()和Arrays.copyOf()方法 通过上面源码我们发现这两个实现数组复制的方法被广泛使用而且很多地方都特别巧妙。比如下面add(int index, E element)方法就很巧妙的用到了arraycopy()方法让数组自己复制自己实现让index开始之后的所有成员后移一个位置: 123456789101112131415/** * 在此列表中的指定位置插入指定的元素。 *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大； *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。 */public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! //arraycopy()方法实现数组自己复制自己 //elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量； System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++;&#125; 又如toArray()方法中用到了copyOf()方法 12345678910/** *以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。 *返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。 *因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。 */public Object[] toArray() &#123;//elementData：要复制的数组；size：要复制的长度 return Arrays.copyOf(elementData, size);&#125; 两者联系与区别 联系： 看两者源代码可以发现copyOf()内部调用了System.arraycopy()方法 区别： arraycopy()需要目标数组，将原数组拷贝到你自己定义的数组里，而且可以选择拷贝的起点和长度以及放入新数组中的位置 copyOf()是系统自动在内部新建一个数组，并返回该数组。 ArrayList 核心扩容技术 1234567891011121314151617181920212223242526272829303132333435363738//下面是ArrayList的扩容机制//ArrayList的扩容机制提高了性能，如果每次只扩充一个，//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。 /** * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量 * @param minCapacity 所需的最小容量 */ public void ensureCapacity(int minCapacity) &#123; int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) // any size if not default element table ? 0 // larger than default for default empty table. It's already // supposed to be at default size. : DEFAULT_CAPACITY; if (minCapacity &gt; minExpand) &#123; ensureExplicitCapacity(minCapacity); &#125; &#125; //得到最小扩容量 private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; // 获取默认的容量和传入参数的较大值 minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity); &#125; //判断是否需要扩容,上面两个方法都要调用 private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // 如果说minCapacity也就是所需的最小容量大于保存ArrayList数据的数组的长度的话，就需要调用grow(minCapacity)方法扩容。 //这个minCapacity到底为多少呢？举个例子在添加元素(add)方法中这个minCapacity的大小就为现在数组的长度加1 if (minCapacity - elementData.length &gt; 0) //调用grow方法进行扩容，调用此方法代表已经开始扩容了 grow(minCapacity); &#125; 12345678910111213141516171819202122/** * ArrayList扩容的核心方法。 */private void grow(int minCapacity) &#123; //elementData为保存ArrayList数据的数组 ///elementData.length求数组长度elementData.size是求数组中的元素个数 // oldCapacity为旧容量，newCapacity为新容量 int oldCapacity = elementData.length; //将oldCapacity 右移一位，其效果相当于oldCapacity /2， //我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍， int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量， if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; //再检查新容量是否超出了ArrayList所定义的最大容量， //若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE， //如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125; 扩容机制代码已经做了详细的解释。另外值得注意的是大家很容易忽略的一个运算符：移位运算符 简介：移位运算符就是在二进制的基础上对数字进行平移。按照平移的方向和填充数字的规则分为三种:&lt;&lt;(左移)、&gt;&gt;(带符号右移)和&gt;&gt;&gt;(无符号右移)。 作用：对于大数据的2进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已,不去计算,这样提高了效率,节省了资源 比如这里：int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); 右移一位相当于除2，右移n位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了1位所以相当于oldCapacity /2。 另外需要注意的是： java 中的length 属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性. java 中的length()方法是针对字 符串String说的,如果想看这个字符串的长度则用到 length()这个方法. .java 中的size()方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看! 内部类 1234(1)private class Itr implements Iterator&lt;E&gt; (2)private class ListItr extends Itr implements ListIterator&lt;E&gt; (3)private class SubList extends AbstractList&lt;E&gt; implements RandomAccess (4)static final class ArrayListSpliterator&lt;E&gt; implements Spliterator&lt;E&gt; ArrayList有四个内部类，其中的Itr是实现了Iterator接口，同时重写了里面的hasNext()，next()，remove()等方法；其中的ListItr继承Itr，实现了ListIterator接口，同时重写了hasPrevious()，nextIndex()，previousIndex()，previous()，set(E e)，**add(E e)**等方法，所以这也可以看出了 **Iterator和ListIterator的区别:**ListIterator在Iterator的基础上增加了添加对象，修改对象，逆向遍历等方法，这些是Iterator不能实现的。 ArrayList经典Demo 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package list;import java.util.ArrayList;import java.util.Iterator;public class ArrayListDemo &#123; public static void main(String[] srgs)&#123; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;(); System.out.printf(\"Before add:arrayList.size() = %d\\n\",arrayList.size()); arrayList.add(1); arrayList.add(3); arrayList.add(5); arrayList.add(7); arrayList.add(9); System.out.printf(\"After add:arrayList.size() = %d\\n\",arrayList.size()); System.out.println(\"Printing elements of arrayList\"); // 三种遍历方式打印元素 // 第一种：通过迭代器遍历 System.out.print(\"通过迭代器遍历:\"); Iterator&lt;Integer&gt; it = arrayList.iterator(); while(it.hasNext())&#123; System.out.print(it.next() + \" \"); &#125; System.out.println(); // 第二种：通过索引值遍历 System.out.print(\"通过索引值遍历:\"); for(int i = 0; i &lt; arrayList.size(); i++)&#123; System.out.print(arrayList.get(i) + \" \"); &#125; System.out.println(); // 第三种：for循环遍历 System.out.print(\"for循环遍历:\"); for(Integer number : arrayList)&#123; System.out.print(number + \" \"); &#125; // toArray用法 // 第一种方式(最常用) Integer[] integer = arrayList.toArray(new Integer[0]); // 第二种方式(容易理解) Integer[] integer1 = new Integer[arrayList.size()]; arrayList.toArray(integer1); // 抛出异常，java不支持向下转型 //Integer[] integer2 = new Integer[arrayList.size()]; //integer2 = arrayList.toArray(); System.out.println(); // 在指定位置添加元素 arrayList.add(2,2); // 删除指定位置上的元素 arrayList.remove(2); // 删除指定元素 arrayList.remove((Object)3); // 判断arrayList是否包含5 System.out.println(\"ArrayList contains 5 is: \" + arrayList.contains(5)); // 清空ArrayList arrayList.clear(); // 判断ArrayList是否为空 System.out.println(\"ArrayList is empty: \" + arrayList.isEmpty()); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://i.codingce.com.cn/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://i.codingce.com.cn/tags/Java/"}]},{"title":"常见开发单词","slug":"development-words","date":"2020-07-09T11:37:56.000Z","updated":"2020-12-13T04:41:40.438Z","comments":true,"path":"2020/07/09/development-words/","link":"","permalink":"http://i.codingce.com.cn/2020/07/09/development-words/","excerpt":"","text":"开发常见单词™ 单词 音标 释义 Authentication /ɔːˌθentɪˈkeɪʃn/ 证明；鉴定；证实 Authorization /ˌɔːθəraɪˈzeɪʃn/ 授权，认可；批准，委任 primary /ˈpraɪməri/ 主要的；初级的；基本的 Concerns 关注；关注点；关注者 cryptography /krɪpˈtɒɡrəfi/ 密码学；密码使用法 Shiro Java安全框架 security /sɪ'kjʊərətɪ/ 安全，安全性；保证；证券；抵押品 markdown druid /ˈdruːɪd/ Druid是一个为大型冷数据集上实时探索查询而设计的开源数据分析和存储系统，提供极具成本效益并且永远在线的。 Quartz /kwɔːts/ Scheduler /ˈskedʒʊələ；ˈʃedjuːlə/ 任务调度器，所有的任务都是从这里开始。 Trigger /ˈtrɪɡə(r)/ 触发器，定义任务执行的方式、间隔。 JobDetail &amp; Job /ˈdiːteɪl/ 定义任务具体执行的逻辑。 identity /aɪˈdentəti/ 身份 interval /ˈɪntəvl/ 间隔间隙 repeat /rɪˈpiːt/ 重复 UserService UserServiceImpl JPA 标准配置文件 persistence.xml /pəˈsɪstəns/ JPA(Java Persistence API) Spring Data Commons /'kɑmənz/ Repository /rɪˈpɒzətri/ Query /ˈkwɪəri/ JPA 框架 Hades /ˈheɪdiːz/ Transactional /trænˈzækʃənəl/ GenericGenerator /dʒəˈnerɪk/ /ˈdʒenəreɪtər/是Hibernate提供的主键生成策略注解 temp 临时变量 锁 单词 音标 释义 Synchronized /'sɪŋkrənaɪzd/ ReentrantLock /riː’entrənt/ 独占锁(排他锁)也是一种悲观锁思想的实现 java.util.concurrent.atomic /kənˈkʌrənt/ /əˈtɒmɪk/ 互联网提倡的三高(高性能、高可用、高并发) CAS 即 compare and swap /swɒp/ （比较与交换），是一种有名的无锁算法。 AtomicStamped Reference /stæmpt/ /ˈrefrəns/ currentThread /ˈkʌrənt/ 现在的 InterruptedException /ɪntə’rʌptɪd/ 当阻塞方法收到中断请求的时候就会抛出InterruptedException异常 IllegalMonitorStateException /ˈmɒnɪtə®/ 监督状态，监控状态 反射 单词 音标 释义 Method /ˈmeθəd/ 方法 Field /fiːld/ 类中属性 Constructor /kənˈstrʌktə®/ 构造方法 Package 包 Annotation /ˌænəˈteɪʃn/ 注解 Reflect /rɪˈflekt/ 反射 invoke /ɪnˈvəʊk/ 调用 newInstance 反射（实例化用） getDeclaredFileds /dɪˈkleəd/ 取得类中全部成员 IllegalAccessException /ɪˈliːɡl/ 这个异常的解释是”没有访问权限”，当应用程序要调用一个类，但当前的方法即没有对该类的访问权限便会出现这个异常。对程序中用了Package的情况下要注意这个异常。 IllegalArgumentException /ˈɑːɡjumənt/ 不合法的参数异常，看看传值的方法是否参数不正确 NoSuchMethodException 没有发现方法异常，看一下是不是你调用了没有定义的方法 SecurityException /sɪ’kjʊərətɪ/ 安全异常的意思，再仔细检查和安全设置相关的选项是否都设置正确:访问本地文件系统;打开除运行Applet 的主机外的另一个主机的Socket;在运行环境中执行另一个程序","categories":[{"name":"随记","slug":"随记","permalink":"http://i.codingce.com.cn/categories/%E9%9A%8F%E8%AE%B0/"}],"tags":[{"name":"随记","slug":"随记","permalink":"http://i.codingce.com.cn/tags/%E9%9A%8F%E8%AE%B0/"}]},{"title":"随记","slug":"my-blog","date":"2020-07-08T00:06:18.000Z","updated":"2020-12-13T04:41:40.438Z","comments":true,"path":"2020/07/08/my-blog/","link":"","permalink":"http://i.codingce.com.cn/2020/07/08/my-blog/","excerpt":"","text":"怎么可能有顺序呢，当然是随机的~ CWorld's Blog 求知若愚，虚怀若谷 KD's Blog 杂乱的技术小站 OURONGXING 天生骄傲 东方幻梦 只是当时已惘然 墨兰 一只爱折腾的小小白 Vexsy 动漫、追番、电脑迷、上网成瘾；摸鱼型博主 Bark Knowledge is Power 蒟蒻のBLOG 点一下，玩一年。蒟蒻不花一分钱 椎咲良田 昨日、今日、明日 自由灵的梦境 愿美梦成真 Mashiro 樱花庄的白猫 Johnson 行到水穷处 坐看云起时 Heven Kin 不去尝试，怎会成功 Ojhdt’s Blog 隐约雷鸣，阴霾天空 冬马のホワイトアルバム 这个国度..已然 没有我的容身之处了 特殊链接 米坛 创造不一样 糖果城 Skyworld 主题设计网站 AIDN daniwell official website 来语直搜 专注你的热爱 失效友链 失效友链 糟糕的先收起来 keyboard_arrow_down Marti’s Blog 摸鱼天下第一 洋葱落叶的博客 一个 Android 发烧友的博客 小狐妖博客 I'm fine. Raaynk’s Blog Raaynk的个人博客 友链记录册 那些曾经留过痕迹的友链 keyboard_arrow_down 2020 07 07 —— Raaynk’s Blog 消失 2020 07 07 —— 冬马的白色相簿 回归 2020 02 22 —— 半叶子 离开 2020 02 22 —— 冬马的白色相簿 消失 2020 02 02 —— Heven Kin 回归 .friends{display:flex;flex-wrap:wrap;}.friends .brick{-webkit-transition:all .3s ease;transition:all .3s ease;}.friends .brick{display:flex;margin:10px 10px 0 0;text-decoration:none;font-weight:300;padding:10px;background-color:#fff0;border:solid 1px #659eb929;color:#659eb9;text-align:center;border-radius:4px;overflow:hidden}.friends .brick:hover{background-color:#659eb9;color:#fff;border:solid 1px #659eb9;box-shadow:0 6px 16px 0 rgba(80, 178, 243, 0.35);}.blog-avatar:hover{animation:whirl 0.5s;} @keyframes whirl{0%{transform:rotate(0deg);}100%{transform:rotate(360deg);}}.friends .brick:active{-webkit-transform:scale(0.95);-moz-transform:scale(0.95);-ms-transform:scale(0.95);-o-transform:scale(0.95);transform:scale(0.95);}.friends .brick .blog-avatar{background-color:#fff0;color:#fff;border:solid 1px #dbdbdb;border-radius:50%;width:50px;height:50px;}.friends .brick .container{margin-left:10px;}.friends .brick .container .name{font-size:14px;}.friends .brick .container .motto{font-size:12px;margin-top:5px;-webkit-box-orient:vertical;-webkit-line-clamp:1;} @media(max-width:450px){.friends .brick{width:100%;}.friends .brick .container{margin-left:0;width:100%;}.motto{width: 100% !important;}}.motto.long{width:100px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;}.mdui-panel-item[open] .mdui-panel-item-arrow{transform:rotate(180deg);}.mdui-panel-item-body {height:auto!important;} 本站模板 1234名称：CWorld&#39;s Blog链接：https:&#x2F;&#x2F;blog.cworld.top&#x2F;图标：https:&#x2F;&#x2F;www.gravatar.com&#x2F;avatar&#x2F;85b870f6b1a177981d3e9566e3ad7264?s&#x3D;200简介：求知若愚，虚怀若谷。 申请说明 不违反国家法律。 请确保你的站点活着。 在你的友链上添加本站。 格式模板 欢迎评论区留链接。 1234名称：&lt;Name&gt;链接：&lt;Link&gt;图标：&lt;Icon&gt;简介：&lt;Word&gt;","categories":[{"name":"随记","slug":"随记","permalink":"http://i.codingce.com.cn/categories/%E9%9A%8F%E8%AE%B0/"}],"tags":[{"name":"随记","slug":"随记","permalink":"http://i.codingce.com.cn/tags/%E9%9A%8F%E8%AE%B0/"}]},{"title":"My Hexo Blog","slug":"my-hexo-blog","date":"2020-07-07T13:22:21.000Z","updated":"2020-12-13T04:41:40.438Z","comments":true,"path":"2020/07/07/my-hexo-blog/","link":"","permalink":"http://i.codingce.com.cn/2020/07/07/my-hexo-blog/","excerpt":"","text":"我是xzMhehe，一名Java开发者，技术一般，经历平平，但是也一直渴望进步，同时也努力活着，为了人生不留遗憾，也希望能够一直做着自己喜欢的事情，得闲时分享心得、分享一些浅薄的经验，等以后老得不能再老了，就说故事已经讲完了,不去奢求圆满。 相信浏览这段话的你也知道，学习是一件极其枯燥而无聊的过程，甚至有时候显得很无助，我也想告诉你，成长就是这样一件残酷的事情，任何成功都不是一蹴而就，需要坚持、需要付出、需要你的毅力，短期可能看不到收获，因为破茧成蝶所耗费的时间不是一天 关于Blog 本站历史(Hexo 搭建巧了) 博客从2019.8.11至今已经运行 起步 📝记录从初识到熟悉的过程 再次起步 博客园 https://www.cnblogs.com/mzdljgz/ CSDN https://blog.csdn.net/weixin_43874301 简书 https://www.jianshu.com/u/a22e10515f17 知乎 https://www.zhihu.com/people/jing-qing-qiu-52 掘金 https://juejin.im/user/131597127652312 公众号 ThePalmJava 为什么把博客园放在首位, 因为我第一次接触的就是博客园. 当时也发文章, 主要是自己遇到的问题以及解决方案. 不查历史记录的话, 已经忘记了什么时候开始写了（查了下posted @ 2018-11-26 21:08 马总丢了紧箍咒 阅读(71) 评论(0) 推荐(0) 编辑）. 立个flag 无论是处在研发岗位还是管理岗位要一直写下去. 至今 现在还是在校生, 继续技术探索. 致谢 我也是一个平凡人, 编程这东西怎么说呢 , 自我理解的话, 虽然我学了这么多 但是总觉得自己有好多东西要学(其实本来就是, 时刻学习, 终身学习) 当时高考上来的, 刚来的时候对编程一脸懵逼, 但是遇到了好多帮助我的学长学姐以及同届的大佬相助, 在这里对每一个曾经帮助我的学长学姐以及同届大佬们道一声 “谢谢你们”, 我的编程也没什么天赋, 但是心里知道自己的大体方向, 接下来就是埋头自学(笨鸟先飞的道理还是懂得), 对编程的热情不减, 无论35岁以后如何, 我希望自己永远不要忘记此刻对编程的热爱. 看完英雄本色最喜欢的一句话。 我等了三年，就是要等一个机会，我要争一口气，不是证明我了不起，我是要告诉大家，我失去的东西我一定要亲手拿回来」 --《英雄本色》 人生分为不同阶段, 你上一个阶段很失败, 不要丢失下一阶段的信心 There is only one heroism in the world: to see the world as it is and to love it. 事可为全力而为. 2020.9.12 Xinze Ma 花名 邱节 本站微信公众号 function secondToDate(second) { if (!second) { return 0; } var time = new Array(0, 0, 0, 0, 0); if (second >= 365 * 24 * 3600) { time[0] = parseInt(second / (365 * 24 * 3600)); second %= 365 * 24 * 3600; } if (second >= 24 * 3600) { time[1] = parseInt(second / (24 * 3600)); second %= 24 * 3600; } if (second >= 3600) { time[2] = parseInt(second / 3600); second %= 3600; } if (second >= 60) { time[3] = parseInt(second / 60); second %= 60; } if (second > 0) { time[4] = second; } return time; }; function setTime() { // 博客创建时间秒数，时间格式中，月比较特殊，是从0开始的，所以想要显示5月，得写4才行，如下 var create_time = Math.round(new Date(Date.UTC(2019, 8, 11, 18, 37, 16)).getTime() / 1000);// 当前时间秒数,增加时区的差异 var timestamp = Math.round((new Date().getTime() + 8 * 60 * 60 * 1000) / 1000); currentTime = secondToDate((timestamp - create_time)); if (currentTime[0]==0){ currentTimeHtml = currentTime[1] + '天'+ currentTime[2] + '时' + currentTime[3] + '分' + currentTime[4] + '秒'; }else{ currentTimeHtml = currentTime[0] + '年' + currentTime[1] + '天' + currentTime[2] + '时' + currentTime[3] + '分' + currentTime[4] + '秒'; } // 兼容pjax，当htmer_time存在时输出，否则清空计时器 if (document.getElementById(\"htmer_time\")){ document.getElementById(\"htmer_time\").innerHTML = currentTimeHtml; }else{ clearInterval(timer); } } var timer = setInterval(setTime, 1000);","categories":[],"tags":[{"name":"随记","slug":"随记","permalink":"http://i.codingce.com.cn/tags/%E9%9A%8F%E8%AE%B0/"}]}],"categories":[{"name":"Redis","slug":"Redis","permalink":"http://i.codingce.com.cn/categories/Redis/"},{"name":"随记","slug":"随记","permalink":"http://i.codingce.com.cn/categories/%E9%9A%8F%E8%AE%B0/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://i.codingce.com.cn/categories/SpringCloud/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://i.codingce.com.cn/categories/SpringBoot/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://i.codingce.com.cn/categories/SpringMVC/"},{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://i.codingce.com.cn/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"考研","slug":"考研","permalink":"http://i.codingce.com.cn/categories/%E8%80%83%E7%A0%94/"},{"name":"力扣","slug":"力扣","permalink":"http://i.codingce.com.cn/categories/%E5%8A%9B%E6%89%A3/"},{"name":"Java","slug":"Java","permalink":"http://i.codingce.com.cn/categories/Java/"},{"name":"Spring","slug":"Spring","permalink":"http://i.codingce.com.cn/categories/Spring/"},{"name":"Git","slug":"Git","permalink":"http://i.codingce.com.cn/categories/Git/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://i.codingce.com.cn/categories/MyBatis/"},{"name":"Sql","slug":"Sql","permalink":"http://i.codingce.com.cn/categories/Sql/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://i.codingce.com.cn/tags/Redis/"},{"name":"随记","slug":"随记","permalink":"http://i.codingce.com.cn/tags/%E9%9A%8F%E8%AE%B0/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://i.codingce.com.cn/tags/SpringCloud/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://i.codingce.com.cn/tags/SpringBoot/"},{"name":"Java","slug":"Java","permalink":"http://i.codingce.com.cn/tags/Java/"},{"name":"Multithread（多线程）","slug":"Multithread（多线程）","permalink":"http://i.codingce.com.cn/tags/Multithread%EF%BC%88%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%89/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://i.codingce.com.cn/tags/SpringMVC/"},{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://i.codingce.com.cn/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"考研","slug":"考研","permalink":"http://i.codingce.com.cn/tags/%E8%80%83%E7%A0%94/"},{"name":"力扣","slug":"力扣","permalink":"http://i.codingce.com.cn/tags/%E5%8A%9B%E6%89%A3/"},{"name":"Spring","slug":"Spring","permalink":"http://i.codingce.com.cn/tags/Spring/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://i.codingce.com.cn/tags/MyBatis/"},{"name":"Git","slug":"Git","permalink":"http://i.codingce.com.cn/tags/Git/"},{"name":"Sql","slug":"Sql","permalink":"http://i.codingce.com.cn/tags/Sql/"}]}